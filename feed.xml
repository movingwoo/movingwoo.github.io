<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://movingwoo.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://movingwoo.com/" rel="alternate" type="text/html" hreflang="ko-KR" /><updated>2025-05-30T01:02:48+00:00</updated><id>https://movingwoo.com/feed.xml</id><title type="html">뭐라도 하겠지</title><subtitle>나도 사람인데 뭐라도 하겠지</subtitle><entry><title type="html">21308번 Ternary Machine</title><link href="https://movingwoo.com/random-solve/python/2025/05/30/21308.html" rel="alternate" type="text/html" title="21308번 Ternary Machine" /><published>2025-05-30T01:00:00+00:00</published><updated>2025-05-30T01:00:00+00:00</updated><id>https://movingwoo.com/random-solve/python/2025/05/30/21308</id><content type="html" xml:base="https://movingwoo.com/random-solve/python/2025/05/30/21308.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Python/2025-05-30-21308/img01.jpg" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/21308">21308번 Ternary Machine - 백준</a></p>

<blockquote>
  <h4 id="번역">번역</h4>
  <hr />
</blockquote>

<p>롱——문제</p>

<p>3진수 프로그램을 해석하고 실행하는 인터프리터를 구현해야한다.</p>

<p>명령어는 고정된 형식이 존재하며 표를 참조한다.<br />
올바르지 않은 입력에 대해서는 런타임에러를 출력하는데, 실행되지 않는 오류는 무시한다.</p>

<p>프로그램은 최대 8192자이며 입력이 필요한 경우 충분한 입력이 반드시 주어진다.</p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>구현문제로 보이는데 생각할 부분이 다소 많아보인다.<br />
명령어 해석을 빠르게 처리해야하고<br />
스택과 힙을 구현해야하겠고<br />
예외처리도 해야하고…</p>

<p>주어진 것부터 묵묵히 하다보면 풀리겠지??</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-입출력과-기본함수">1. 입출력과 기본함수</h5>

<p>입력은 한번에 받아서 버퍼로 저장해둔다.<br />
필요하면 버퍼에 하나씩 꺼내 쓰도록 하고<br />
출력은 모아뒀다가 한번에 한다.</p>

<p><span style="color: orange;"><strong>오류 출력시에는 기존 프로그램이 생성한 출력은 먼저 출력</strong></span>해야하는 것에 주의</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">isError</span> <span class="o">=</span> <span class="bp">False</span>
<span class="c1"># 입력 버퍼 탐색 인덱스
</span><span class="n">buffer_index</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1"># 프로그램 탐색 인덱스
</span><span class="n">program_index</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1"># 명령어 사전
</span><span class="n">opcodes</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1"># 4자리 명령부터 판단
</span>    <span class="c1"># CODE | PARAM | DESCRIPTION
</span>    <span class="p">(</span><span class="sh">"</span><span class="s">1000</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">ADD</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">1001</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">SUB</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">1002</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">MUL</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">1010</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">DIV</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">1011</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">MOD</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">1200</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">PRINT_CHAR</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">1201</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">PRINT_NUM</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">1210</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">READ_CHAR</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">1211</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">READ_NUM</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">000</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">number</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">PUSH_POS</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">001</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">number</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">PUSH_NEG</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">020</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">DUP</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">021</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">SWAP</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">022</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">DROP</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">110</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">STORE</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">111</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">LOAD</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">200</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">label</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">LABEL</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">201</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">label</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">CALL</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">202</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">label</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">JUMP</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">210</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">label</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">JUMP_IF_ZERO</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">211</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">label</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">JUMP_IF_NEG</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">212</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">RETURN</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">222</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">HALT</span><span class="sh">"</span><span class="p">),</span>
<span class="p">]</span>
<span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">heap</span> <span class="o">=</span> <span class="p">{}</span>
<span class="c1"># 복귀 주소 스택
</span><span class="n">call_stack</span> <span class="o">=</span> <span class="p">[]</span>
<span class="c1"># CALL, JUMP 등을 처리하기 위해 label 위치를 미리 매핑해야함
</span><span class="n">labels</span> <span class="o">=</span> <span class="p">{}</span>
<span class="c1"># 출력은 리스트에 모아두었다가 한 번에 출력
</span><span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">output</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="sh">''</span><span class="p">)</span>

<span class="k">if</span> <span class="n">isError</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">RUN-TIME ERROR</span><span class="sh">"</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="sh">''</span><span class="p">)</span>
</code></pre></div></div>

<p>한자리 숫자, 문자를 읽는 함수, 라벨을 읽는 함수, 프로그램 내 숫자를 읽는 함수가 필요하다.<br />
스택에 넣는 부분이 많아서 그부분도 따로 함수로 뺀다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 버퍼에서 숫자 하나 읽어오는 함수
</span><span class="k">def</span> <span class="nf">read_number</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">buffer_index</span><span class="p">,</span> <span class="n">isError</span>

    <span class="c1"># 입력에 공백이 주어지나??
</span>    <span class="k">while</span> <span class="n">buffer_index</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">)</span> <span class="ow">and</span> <span class="n">input_buffer</span><span class="p">[</span><span class="n">buffer_index</span><span class="p">].</span><span class="nf">isspace</span><span class="p">():</span>
        <span class="n">buffer_index</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">buffer_index</span> <span class="o">&gt;=</span> <span class="nf">len</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">):</span>
        <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="mi">0</span>
    
    <span class="n">start</span> <span class="o">=</span> <span class="n">buffer_index</span>
    <span class="c1"># 입력 값이 음수일 수 있음
</span>    <span class="k">if</span> <span class="n">input_buffer</span><span class="p">[</span><span class="n">buffer_index</span><span class="p">]</span> <span class="o">==</span> <span class="sh">'</span><span class="s">-</span><span class="sh">'</span><span class="p">:</span>
        <span class="n">buffer_index</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="n">buffer_index</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">)</span> <span class="ow">and</span> <span class="n">input_buffer</span><span class="p">[</span><span class="n">buffer_index</span><span class="p">].</span><span class="nf">isdigit</span><span class="p">():</span>
        <span class="n">buffer_index</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">buffer_index</span> <span class="ow">or</span> <span class="p">(</span><span class="n">input_buffer</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">==</span> <span class="sh">'</span><span class="s">-</span><span class="sh">'</span> <span class="ow">and</span> <span class="n">buffer_index</span> <span class="o">==</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="nf">int</span><span class="p">(</span><span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">buffer_index</span><span class="p">]))</span>

<span class="c1"># 버퍼에서 문자 하나 읽어오는 함수
</span><span class="k">def</span> <span class="nf">read_char</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">buffer_index</span><span class="p">,</span> <span class="n">isError</span>

    <span class="k">if</span> <span class="n">buffer_index</span> <span class="o">&gt;=</span> <span class="nf">len</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">):</span>
        <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="mi">0</span>
    
    <span class="n">ch</span> <span class="o">=</span> <span class="n">input_buffer</span><span class="p">[</span><span class="n">buffer_index</span><span class="p">]</span>
    <span class="n">buffer_index</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="nf">ord</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>

<span class="c1"># 프로그램에서 2로 끝나는 레이블을 읽어오는 함수
</span><span class="k">def</span> <span class="nf">read_label</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">program_index</span><span class="p">,</span> <span class="n">isError</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">program_index</span>

    <span class="k">while</span> <span class="n">program_index</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">program</span><span class="p">):</span>
        <span class="n">trit</span> <span class="o">=</span> <span class="n">program</span><span class="p">[</span><span class="n">program_index</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">trit</span> <span class="o">==</span> <span class="sh">'</span><span class="s">2</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">program</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">program_index</span><span class="p">]</span>
            <span class="n">program_index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">label</span>
        
        <span class="k">elif</span> <span class="n">trit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="sh">'</span><span class="s">01</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">return</span> <span class="bp">None</span>
        
        <span class="n">program_index</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">None</span>

<span class="c1"># 프로그램 내의 숫자 파싱하는 함수
</span><span class="k">def</span> <span class="nf">parse_number_program</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">program_index</span><span class="p">,</span> <span class="n">isError</span>
    <span class="n">bits</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">program_index</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">program</span><span class="p">):</span>
        <span class="n">trit</span> <span class="o">=</span> <span class="n">program</span><span class="p">[</span><span class="n">program_index</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">trit</span> <span class="o">==</span> <span class="sh">'</span><span class="s">0</span><span class="sh">'</span> <span class="ow">or</span> <span class="n">trit</span> <span class="o">==</span> <span class="sh">'</span><span class="s">1</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">bits</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">trit</span><span class="p">)</span>
            <span class="n">program_index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">31</span><span class="p">:</span>
                <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">return</span> <span class="mi">0</span>
            
        <span class="k">elif</span> <span class="n">trit</span> <span class="o">==</span> <span class="sh">'</span><span class="s">2</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">program_index</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">bits</span><span class="p">:</span>
                <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">return</span> <span class="mi">0</span>
            
            <span class="k">return</span> <span class="nf">int</span><span class="p">(</span><span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">bits</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">return</span> <span class="mi">0</span>

    <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="c1"># 스택에 넣는 함수
</span><span class="k">def</span> <span class="nf">push_stack</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">stack</span><span class="p">,</span> <span class="n">isError</span>

    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1024</span><span class="p">:</span>
        <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span>
    <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<span class="c1"># 콜스택에 넣는 함수
</span><span class="k">def</span> <span class="nf">push_call_stack</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">call_stack</span><span class="p">,</span> <span class="n">isError</span>

    <span class="c1"># 서브루틴도 1024 체크 필요
</span>    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">call_stack</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1024</span><span class="p">:</span>
        <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span>
    <span class="n">call_stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</code></pre></div></div>

<h5 id="2-레이블-스캔-함수">2. 레이블 스캔 함수</h5>

<p>CALL이나 JUMP 명령 시 어디로 가야하는가?<br />
그것을 미리 알기위해 <span style="color: orange;"><strong>레이블 스캔을 미리 진행</strong></span>한다.<br />
실행 시 찾으려면 비효율적일 것 같아서리</p>

<p>섣불리 에러처리 해버리면 에러 전까지의 프로그램 아웃풋이 없으므로 주의해야한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># label 스캔하는 함수
</span><span class="k">def</span> <span class="nf">scan_labels</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">labels</span><span class="p">,</span> <span class="n">isError</span>
    <span class="n">scan_index</span> <span class="o">=</span> <span class="mi">0</span>


    <span class="k">while</span> <span class="n">scan_index</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">program</span><span class="p">):</span>

        <span class="c1"># 트릿이 아니면 스캔 종료
</span>        <span class="k">if</span> <span class="n">program</span><span class="p">[</span><span class="n">scan_index</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="sh">'</span><span class="s">012</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">break</span>
            
        <span class="n">matched</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">for</span> <span class="n">code</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">description</span> <span class="ow">in</span> <span class="n">opcodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">program</span><span class="p">.</span><span class="nf">startswith</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">scan_index</span><span class="p">):</span>
                <span class="n">scan_index</span> <span class="o">+=</span> <span class="nf">len</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
                <span class="n">matched</span> <span class="o">=</span> <span class="bp">True</span>

                <span class="c1"># HALT 이후까지 스캔하면 불필요한 오류 발생 가능
</span>                <span class="k">if</span> <span class="n">description</span> <span class="o">==</span> <span class="sh">"</span><span class="s">HALT</span><span class="sh">"</span><span class="p">:</span>
                    <span class="c1"># return 해버리니 뒤쪽 레이블이 등록안됨...
</span>                    <span class="k">break</span>
                
                <span class="k">elif</span> <span class="n">description</span> <span class="o">==</span> <span class="sh">"</span><span class="s">LABEL</span><span class="sh">"</span><span class="p">:</span>
                    <span class="c1"># label 읽기
</span>                    <span class="n">start</span> <span class="o">=</span> <span class="n">scan_index</span>

                    <span class="k">while</span> <span class="n">scan_index</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">program</span><span class="p">):</span>
                        <span class="n">trit</span> <span class="o">=</span> <span class="n">program</span><span class="p">[</span><span class="n">scan_index</span><span class="p">]</span>

                        <span class="k">if</span> <span class="n">trit</span> <span class="o">==</span> <span class="sh">'</span><span class="s">2</span><span class="sh">'</span><span class="p">:</span>
                            <span class="n">label</span> <span class="o">=</span> <span class="n">program</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">scan_index</span><span class="p">]</span>
                            <span class="n">scan_index</span> <span class="o">+=</span> <span class="mi">1</span>

                            <span class="k">if</span> <span class="ow">not</span> <span class="n">label</span> <span class="ow">or</span> <span class="nf">any</span><span class="p">(</span><span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="sh">'</span><span class="s">01</span><span class="sh">'</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">label</span><span class="p">):</span>
                                <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
                                <span class="k">return</span>
                            
                            <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                                <span class="c1"># 같은 위치에 중복된 레이블이면 허용
</span>                                <span class="k">if</span> <span class="n">labels</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">!=</span> <span class="n">scan_index</span><span class="p">:</span>
                                    <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
                                    <span class="k">return</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># label 다음 위치
</span>                                <span class="n">labels</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">scan_index</span>
                            <span class="k">break</span>

                        <span class="k">elif</span> <span class="n">trit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="sh">'</span><span class="s">01</span><span class="sh">'</span><span class="p">:</span>
                            <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
                            <span class="k">return</span>
                        <span class="n">scan_index</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># 끝까지 2를 못 만남
</span>                        <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="k">return</span>

                <span class="c1"># 숫자 건너뛰기
</span>                <span class="k">elif</span> <span class="n">param</span> <span class="o">==</span> <span class="sh">"</span><span class="s">number</span><span class="sh">"</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="k">while</span> <span class="n">scan_index</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">program</span><span class="p">):</span>
                        <span class="n">trit</span> <span class="o">=</span> <span class="n">program</span><span class="p">[</span><span class="n">scan_index</span><span class="p">]</span>
                        <span class="n">scan_index</span> <span class="o">+=</span> <span class="mi">1</span>

                        <span class="k">if</span> <span class="n">trit</span> <span class="o">==</span> <span class="sh">'</span><span class="s">2</span><span class="sh">'</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="k">elif</span> <span class="n">trit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="sh">'</span><span class="s">01</span><span class="sh">'</span><span class="p">:</span>
                            <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
                            <span class="k">return</span>
                        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

                        <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">31</span><span class="p">:</span>
                            <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
                            <span class="k">return</span>

                <span class="c1"># 레이블 건너뛰기
</span>                <span class="k">elif</span> <span class="n">param</span> <span class="o">==</span> <span class="sh">"</span><span class="s">label</span><span class="sh">"</span><span class="p">:</span>
                    
                    <span class="k">while</span> <span class="n">scan_index</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">program</span><span class="p">):</span>
                        <span class="n">trit</span> <span class="o">=</span> <span class="n">program</span><span class="p">[</span><span class="n">scan_index</span><span class="p">]</span>
                        <span class="n">scan_index</span> <span class="o">+=</span> <span class="mi">1</span>

                        <span class="k">if</span> <span class="n">trit</span> <span class="o">==</span> <span class="sh">'</span><span class="s">2</span><span class="sh">'</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="k">elif</span> <span class="n">trit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="sh">'</span><span class="s">01</span><span class="sh">'</span><span class="p">:</span>
                            <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
                            <span class="k">return</span>

                <span class="c1"># param 없는 경우
</span>                <span class="k">break</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">matched</span><span class="p">:</span>
            <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">break</span>

    <span class="k">return</span>
</code></pre></div></div>

<h5 id="3-메인-루프">3. 메인 루프</h5>

<p>명령어 조건에 맞춰 메인 루프 작성<br />
가장 단순하고 가장 별거없고 가장 노가다 구간</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 본 로직
</span><span class="k">while</span> <span class="n">program_index</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">program</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">isError</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">halted</span><span class="p">:</span>

    <span class="n">matched</span> <span class="o">=</span> <span class="bp">False</span>
    
    <span class="k">for</span> <span class="n">code</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">description</span> <span class="ow">in</span> <span class="n">opcodes</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">program</span><span class="p">.</span><span class="nf">startswith</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">program_index</span><span class="p">):</span>
            <span class="n">program_index</span> <span class="o">+=</span> <span class="nf">len</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
            <span class="n">matched</span> <span class="o">=</span> <span class="bp">True</span>

            <span class="c1"># 분기 시작
</span>
            <span class="c1"># ... 중략 ...
</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">matched</span><span class="p">:</span>
        <span class="c1"># 남은 코드가 공백이거나 무의미하면 무시하고 종료
</span>        <span class="k">if</span> <span class="n">program_index</span> <span class="o">&gt;=</span> <span class="nf">len</span><span class="p">(</span><span class="n">program</span><span class="p">):</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">break</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Python/2025-05-30-21308/img02.jpg" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>하필 또 파이썬이라 푸는데 엄청 오래 걸린 문제</p>

<p>구현만 잘하면 문제없을 줄 알았는데 생각보다 오류가 엄청났다.<br />
레이블 스캔하는 부분에서 뜻대로 잘 동작하지 않아서 결과가 자꾸 틀어짐…</p>

<p>PyPy는 JIT 컴파일러가 있어서 더 빠르다고해서 Python3와 PyPy3 두개로 제출했다.<br />
생각보다 시간 차이가 안나는데, 메모리는 당연히 PyPy3가 많이 쓸거고<br />
속도는 연산자체가 그리 많은 문제가 아니라 큰 차이 안나는 것으로 보인다.</p>

<p>제한시간 빡빡한 문제에서 다시 한 번 비교해봐야할 듯</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/random-solve/Python/2025-05-30-21308.py">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="random-solve/Python/" /><summary type="html"><![CDATA[문제 21308번 Ternary Machine - 백준 번역 롱——문제 3진수 프로그램을 해석하고 실행하는 인터프리터를 구현해야한다. 명령어는 고정된 형식이 존재하며 표를 참조한다. 올바르지 않은 입력에 대해서는 런타임에러를 출력하는데, 실행되지 않는 오류는 무시한다. 프로그램은 최대 8192자이며 입력이 필요한 경우 충분한 입력이 반드시 주어진다. 설계 구현문제로 보이는데 생각할 부분이 다소 많아보인다. 명령어 해석을 빠르게 처리해야하고 스택과 힙을 구현해야하겠고 예외처리도 해야하고… 주어진 것부터 묵묵히 하다보면 풀리겠지?? 구현 1. 입출력과 기본함수 입력은 한번에 받아서 버퍼로 저장해둔다. 필요하면 버퍼에 하나씩 꺼내 쓰도록 하고 출력은 모아뒀다가 한번에 한다. 오류 출력시에는 기존 프로그램이 생성한 출력은 먼저 출력해야하는 것에 주의 isError = False # 입력 버퍼 탐색 인덱스 buffer_index = 0 # 프로그램 탐색 인덱스 program_index = 0 # 명령어 사전 opcodes = [ # 4자리 명령부터 판단 # CODE | PARAM | DESCRIPTION ("1000", None, "ADD"), ("1001", None, "SUB"), ("1002", None, "MUL"), ("1010", None, "DIV"), ("1011", None, "MOD"), ("1200", None, "PRINT_CHAR"), ("1201", None, "PRINT_NUM"), ("1210", None, "READ_CHAR"), ("1211", None, "READ_NUM"), ("000", "number", "PUSH_POS"), ("001", "number", "PUSH_NEG"), ("020", None, "DUP"), ("021", None, "SWAP"), ("022", None, "DROP"), ("110", None, "STORE"), ("111", None, "LOAD"), ("200", "label", "LABEL"), ("201", "label", "CALL"), ("202", "label", "JUMP"), ("210", "label", "JUMP_IF_ZERO"), ("211", "label", "JUMP_IF_NEG"), ("212", None, "RETURN"), ("222", None, "HALT"), ] stack = [] heap = {} # 복귀 주소 스택 call_stack = [] # CALL, JUMP 등을 처리하기 위해 label 위치를 미리 매핑해야함 labels = {} # 출력은 리스트에 모아두었다가 한 번에 출력 output = [] print(''.join(output), end='') if isError: print("RUN-TIME ERROR", end='') 한자리 숫자, 문자를 읽는 함수, 라벨을 읽는 함수, 프로그램 내 숫자를 읽는 함수가 필요하다. 스택에 넣는 부분이 많아서 그부분도 따로 함수로 뺀다. # 버퍼에서 숫자 하나 읽어오는 함수 def read_number(): global buffer_index, isError # 입력에 공백이 주어지나?? while buffer_index &lt; len(input_buffer) and input_buffer[buffer_index].isspace(): buffer_index += 1 if buffer_index &gt;= len(input_buffer): isError = True return 0 start = buffer_index # 입력 값이 음수일 수 있음 if input_buffer[buffer_index] == '-': buffer_index += 1 while buffer_index &lt; len(input_buffer) and input_buffer[buffer_index].isdigit(): buffer_index += 1 if start == buffer_index or (input_buffer[start] == '-' and buffer_index == start + 1): isError = True return 0 return int(''.join(input_buffer[start:buffer_index])) # 버퍼에서 문자 하나 읽어오는 함수 def read_char(): global buffer_index, isError if buffer_index &gt;= len(input_buffer): isError = True return 0 ch = input_buffer[buffer_index] buffer_index += 1 return ord(ch) # 프로그램에서 2로 끝나는 레이블을 읽어오는 함수 def read_label(): global program_index, isError start = program_index while program_index &lt; len(program): trit = program[program_index] if trit == '2': label = program[start:program_index] program_index += 1 return label elif trit not in '01': isError = True return None program_index += 1 isError = True return None # 프로그램 내의 숫자 파싱하는 함수 def parse_number_program(): global program_index, isError bits = [] count = 0 while program_index &lt; len(program): trit = program[program_index] if trit == '0' or trit == '1': bits.append(trit) program_index += 1 count += 1 if count &gt; 31: isError = True return 0 elif trit == '2': program_index += 1 if not bits: isError = True return 0 return int(''.join(bits), 2) else: isError = True return 0 isError = True return 0 # 스택에 넣는 함수 def push_stack(value): global stack, isError if len(stack) &gt;= 1024: isError = True return stack.append(value) # 콜스택에 넣는 함수 def push_call_stack(value): global call_stack, isError # 서브루틴도 1024 체크 필요 if len(call_stack) &gt;= 1024: isError = True return call_stack.append(value) 2. 레이블 스캔 함수 CALL이나 JUMP 명령 시 어디로 가야하는가? 그것을 미리 알기위해 레이블 스캔을 미리 진행한다. 실행 시 찾으려면 비효율적일 것 같아서리 섣불리 에러처리 해버리면 에러 전까지의 프로그램 아웃풋이 없으므로 주의해야한다. # label 스캔하는 함수 def scan_labels(): global labels, isError scan_index = 0 while scan_index &lt; len(program): # 트릿이 아니면 스캔 종료 if program[scan_index] not in '012': break matched = False for code, param, description in opcodes: if program.startswith(code, scan_index): scan_index += len(code) matched = True # HALT 이후까지 스캔하면 불필요한 오류 발생 가능 if description == "HALT": # return 해버리니 뒤쪽 레이블이 등록안됨... break elif description == "LABEL": # label 읽기 start = scan_index while scan_index &lt; len(program): trit = program[scan_index] if trit == '2': label = program[start:scan_index] scan_index += 1 if not label or any(c not in '01' for c in label): isError = True return if label in labels: # 같은 위치에 중복된 레이블이면 허용 if labels[label] != scan_index: isError = True return else: # label 다음 위치 labels[label] = scan_index break elif trit not in '01': isError = True return scan_index += 1 else: # 끝까지 2를 못 만남 isError = True return # 숫자 건너뛰기 elif param == "number": count = 0 while scan_index &lt; len(program): trit = program[scan_index] scan_index += 1 if trit == '2': break elif trit not in '01': isError = True return count += 1 if count &gt; 31: isError = True return # 레이블 건너뛰기 elif param == "label": while scan_index &lt; len(program): trit = program[scan_index] scan_index += 1 if trit == '2': break elif trit not in '01': isError = True return # param 없는 경우 break if not matched: isError = True break return 3. 메인 루프 명령어 조건에 맞춰 메인 루프 작성 가장 단순하고 가장 별거없고 가장 노가다 구간 # 본 로직 while program_index &lt; len(program) and not isError and not halted: matched = False for code, param, description in opcodes: if program.startswith(code, program_index): program_index += len(code) matched = True # 분기 시작 # ... 중략 ... if not matched: # 남은 코드가 공백이거나 무의미하면 무시하고 종료 if program_index &gt;= len(program): break else: isError = True break 채점 반성 하필 또 파이썬이라 푸는데 엄청 오래 걸린 문제 구현만 잘하면 문제없을 줄 알았는데 생각보다 오류가 엄청났다. 레이블 스캔하는 부분에서 뜻대로 잘 동작하지 않아서 결과가 자꾸 틀어짐… PyPy는 JIT 컴파일러가 있어서 더 빠르다고해서 Python3와 PyPy3 두개로 제출했다. 생각보다 시간 차이가 안나는데, 메모리는 당연히 PyPy3가 많이 쓸거고 속도는 연산자체가 그리 많은 문제가 아니라 큰 차이 안나는 것으로 보인다. 제한시간 빡빡한 문제에서 다시 한 번 비교해봐야할 듯 코드 확인 Link to GitHub]]></summary></entry><entry><title type="html">11982번 Angry Cows (Gold)</title><link href="https://movingwoo.com/random-solve/java/2025/05/28/11982.html" rel="alternate" type="text/html" title="11982번 Angry Cows (Gold)" /><published>2025-05-28T08:00:00+00:00</published><updated>2025-05-28T08:00:00+00:00</updated><id>https://movingwoo.com/random-solve/java/2025/05/28/11982</id><content type="html" xml:base="https://movingwoo.com/random-solve/java/2025/05/28/11982.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Java/2025-05-28-11982/img01.jpg" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/11982">11982번 Angry Cows (Gold) - 백준</a></p>

<blockquote>
  <h4 id="번역">번역</h4>
  <hr />
</blockquote>

<p>오 뭔가 재밌어보이는 문제</p>

<p>‘Angry Cows’ 라는 게임이 있다.<br />
소를 쏴서 건초더미를 폭발시키는 게임이다.</p>

<p>R의 힘으로 쏘면 x - R, x + R 범위의 건초더미를 폭발시키고<br />
폭발한 건초더미는 R - 1의 힘으로 다시 폭발한다.<br />
R이 0이 될 때까지 폭발이 계속된다.<br />
이때 소 하나를 쏴서 모든 건초더미를 날릴 수 있는 R을 구하시오.</p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>예체 출력이 실수형이라 골치가 아픈데…</p>

<p>1차 시도) 
우선 건초더미를 정렬해 이진탐색<br />
실수단위로 정확도를 판단해야해서 여러번 돌리고 건초더미에 쏠 경우, 가운데의 쏠 경우를 모두 고려해야했다.<br />
솔직히 시간초과 날 것 같았음</p>

<p>2차 시도)
문제 알고리즘 분류대로 DP 활용<br />
소숫점 계산을 위해 <span style="color: orange;"><strong>2배 스케일링</strong></span> 후 <span style="color: orange;"><strong>DP</strong></span>로 왼쪽, 오른쪽 전파에 필요한 최소 범위를 계산하고<br />
<span style="color: orange;"><strong>두 포인터</strong></span>로 구간 분할해 최소 반경을 구한다.</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-건초-배열-dp-배열">1. 건초 배열, DP 배열</h5>

<p>2배 스케일링해도 int 범위 내지만 오버플로우 날 수 있을 것 같아서 long으로 처리한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
<span class="kt">long</span><span class="o">[]</span> <span class="n">hayBales</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>

<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
	<span class="c1">// 소숫점 처리를 위해 2배 스케일링 </span>
	<span class="n">hayBales</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 오름차순</span>
<span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">hayBales</span><span class="o">);</span>

<span class="kt">long</span><span class="o">[]</span> <span class="n">leftDP</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
<span class="kt">long</span><span class="o">[]</span> <span class="n">rightDP</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
<span class="c1">// 큰 값으로 초기화 (2 더하면 오버플로우남)</span>
<span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">leftDP</span><span class="o">,</span> <span class="nc">Long</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">-</span> <span class="mi">2</span><span class="o">);</span>
<span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">rightDP</span><span class="o">,</span> <span class="nc">Long</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">-</span> <span class="mi">2</span><span class="o">);</span>
</code></pre></div></div>

<h5 id="2-dp">2. DP</h5>

<p>2배 스케일링되어 있기 때문에 2씩 조절해야한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 2배 스케일링해서 2씩 조절함</span>
<span class="c1">// 왼쪽 전파 DP</span>
<span class="n">leftDP</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">;</span>  
<span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
	<span class="c1">// last를 오른쪽으로 밀며 폭발이 닿을 때까지</span>
	<span class="k">while</span> <span class="o">(</span><span class="n">last</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">hayBales</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">hayBales</span><span class="o">[</span><span class="n">last</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">leftDP</span><span class="o">[</span><span class="n">last</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">last</span><span class="o">++;</span>
	<span class="o">}</span>
	<span class="c1">// hayBales 직접 연결 범위, DP[last+1]에 한 단계 추가한 값 중 작은 쪽</span>
	<span class="n">leftDP</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">hayBales</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">hayBales</span><span class="o">[</span><span class="n">last</span><span class="o">],</span> <span class="n">leftDP</span><span class="o">[</span><span class="n">last</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 오른쪽 전파 DP</span>
<span class="n">rightDP</span><span class="o">[</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">;</span>
<span class="n">last</span> <span class="o">=</span> <span class="no">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="no">N</span> <span class="o">-</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
	<span class="c1">// 왼쪽으로 밀며 체크</span>
	<span class="k">while</span> <span class="o">(</span><span class="n">last</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">hayBales</span><span class="o">[</span><span class="n">last</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">hayBales</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">rightDP</span><span class="o">[</span><span class="n">last</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">last</span><span class="o">--;</span>
	<span class="o">}</span>
	
	<span class="c1">// 한 단계 줄인 값과 비교</span>
	<span class="n">rightDP</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">hayBales</span><span class="o">[</span><span class="n">last</span><span class="o">]</span> <span class="o">-</span> <span class="n">hayBales</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">rightDP</span><span class="o">[</span><span class="n">last</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h5 id="3-두-포인터">3. 두 포인터</h5>

<p>구간을 분할해 DP값과 구간 절반 거리를 비교하며 최소 범위를 찾아낸다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 두 포인터로 분할점 i &lt; j를 탐색하며 최적 반경을 찾음</span>
<span class="kt">long</span> <span class="n">best</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="no">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
	<span class="c1">// i~j 구간의 가운데와 전파에 필요한 직경 비교</span>
	<span class="kt">long</span> <span class="n">need</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">((</span><span class="n">hayBales</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">-</span> <span class="n">hayBales</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">leftDP</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">rightDP</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">+</span> <span class="mi">2</span><span class="o">);</span>
	<span class="n">best</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">best</span><span class="o">,</span> <span class="n">need</span><span class="o">);</span>

	<span class="c1">// 어느 쪽 DP가 더 작은가에 따라 포인터 이동</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">leftDP</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">rightDP</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
		<span class="n">i</span><span class="o">++;</span>
	<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
		<span class="n">j</span><span class="o">--;</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 2배 스케일링 된 상태이므로 나눠서 소숫점 붙이기</span>
<span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">best</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%d.0\n"</span><span class="o">,</span> <span class="n">best</span><span class="o">/</span><span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%d.5\n"</span><span class="o">,</span> <span class="n">best</span><span class="o">/</span><span class="mi">2</span><span class="o">));</span>
<span class="n">bw</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Java/2025-05-28-11982/img02.jpg" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>코드 그대로 Angry Cows Silver 문제에 붙였는데 런타임에러가 떨어졌다.<br />
번역해보니 문제가 다르더라… 날먹 실패<br />
다음에 언젠가 걸리면 풀겠지 뭐</p>

<p>항상 고급문제를 풀면 시간초과가 걸리적거린다.<br />
가장 효율적인 방안을 바로 찾기가 쉽지 않다.</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/random-solve/Java/2025-05-28-11982.java">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="random-solve/Java/" /><summary type="html"><![CDATA[문제 11982번 Angry Cows (Gold) - 백준 번역 오 뭔가 재밌어보이는 문제 ‘Angry Cows’ 라는 게임이 있다. 소를 쏴서 건초더미를 폭발시키는 게임이다. R의 힘으로 쏘면 x - R, x + R 범위의 건초더미를 폭발시키고 폭발한 건초더미는 R - 1의 힘으로 다시 폭발한다. R이 0이 될 때까지 폭발이 계속된다. 이때 소 하나를 쏴서 모든 건초더미를 날릴 수 있는 R을 구하시오. 설계 예체 출력이 실수형이라 골치가 아픈데… 1차 시도) 우선 건초더미를 정렬해 이진탐색 실수단위로 정확도를 판단해야해서 여러번 돌리고 건초더미에 쏠 경우, 가운데의 쏠 경우를 모두 고려해야했다. 솔직히 시간초과 날 것 같았음 2차 시도) 문제 알고리즘 분류대로 DP 활용 소숫점 계산을 위해 2배 스케일링 후 DP로 왼쪽, 오른쪽 전파에 필요한 최소 범위를 계산하고 두 포인터로 구간 분할해 최소 반경을 구한다. 구현 1. 건초 배열, DP 배열 2배 스케일링해도 int 범위 내지만 오버플로우 날 수 있을 것 같아서 long으로 처리한다. int N = Integer.parseInt(br.readLine()); long[] hayBales = new long[N]; for (int i = 0; i &lt; N; i++) { // 소숫점 처리를 위해 2배 스케일링 hayBales[i] = Long.parseLong(br.readLine()) * 2; } // 오름차순 Arrays.sort(hayBales); long[] leftDP = new long[N]; long[] rightDP = new long[N]; // 큰 값으로 초기화 (2 더하면 오버플로우남) Arrays.fill(leftDP, Long.MAX_VALUE - 2); Arrays.fill(rightDP, Long.MAX_VALUE - 2); 2. DP 2배 스케일링되어 있기 때문에 2씩 조절해야한다. // 2배 스케일링해서 2씩 조절함 // 왼쪽 전파 DP leftDP[0] = -2; int last = 0; for (int i = 1; i &lt; N; i++) { // last를 오른쪽으로 밀며 폭발이 닿을 때까지 while (last + 1 &lt; i &amp;&amp; hayBales[i] - hayBales[last+1] &gt; leftDP[last+1] + 2) { last++; } // hayBales 직접 연결 범위, DP[last+1]에 한 단계 추가한 값 중 작은 쪽 leftDP[i] = Math.min(hayBales[i] - hayBales[last], leftDP[last+1] + 2); } // 오른쪽 전파 DP rightDP[N-1] = -2; last = N - 1; for (int i = N - 2; i &gt;= 0; i--) { // 왼쪽으로 밀며 체크 while (last - 1 &gt; i &amp;&amp; hayBales[last-1] - hayBales[i] &gt; rightDP[last-1] + 2) { last--; } // 한 단계 줄인 값과 비교 rightDP[i] = Math.min(hayBales[last] - hayBales[i], rightDP[last-1] + 2); } 3. 두 포인터 구간을 분할해 DP값과 구간 절반 거리를 비교하며 최소 범위를 찾아낸다. // 두 포인터로 분할점 i &lt; j를 탐색하며 최적 반경을 찾음 long best = Long.MAX_VALUE; int i = 0; int j = N - 1; while (i &lt; j) { // i~j 구간의 가운데와 전파에 필요한 직경 비교 long need = Math.max((hayBales[j] - hayBales[i]) / 2, Math.max(leftDP[i], rightDP[j]) + 2); best = Math.min(best, need); // 어느 쪽 DP가 더 작은가에 따라 포인터 이동 if (leftDP[i+1] &lt; rightDP[j-1]) { i++; } else { j--; } } // 2배 스케일링 된 상태이므로 나눠서 소숫점 붙이기 bw.write(best % 2 == 0 ? String.format("%d.0\n", best/2) : String.format("%d.5\n", best/2)); bw.flush(); 채점 반성 코드 그대로 Angry Cows Silver 문제에 붙였는데 런타임에러가 떨어졌다. 번역해보니 문제가 다르더라… 날먹 실패 다음에 언젠가 걸리면 풀겠지 뭐 항상 고급문제를 풀면 시간초과가 걸리적거린다. 가장 효율적인 방안을 바로 찾기가 쉽지 않다. 코드 확인 Link to GitHub]]></summary></entry><entry><title type="html">16085번 Гэмт хэрэг</title><link href="https://movingwoo.com/random-solve/c++/2025/05/28/16085.html" rel="alternate" type="text/html" title="16085번 Гэмт хэрэг" /><published>2025-05-28T05:00:00+00:00</published><updated>2025-05-28T05:00:00+00:00</updated><id>https://movingwoo.com/random-solve/c++/2025/05/28/16085</id><content type="html" xml:base="https://movingwoo.com/random-solve/c++/2025/05/28/16085.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/C++/2025-05-28-16085/img01.jpg" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/16085">16085번 Гэмт хэрэг - 백준</a></p>

<blockquote>
  <h4 id="번역">번역</h4>
  <hr />
</blockquote>

<p>형사가 용의자가 있을 수 있는 지역의 넓이를 계산하는 문제.</p>

<p>정보가 들어온지 T초가 지났다.<br />
차량은 오직 도로 위로만 이동하며 도로는 단 하나 존재한다.(x축)<br />
도보로는 도로를 벗어날 수 있다.(y축)<br />
도보로는 초당 W미터, 차를 타면 초당 C 미터 이동 가능하다.<br />
탑승, 하차 시간은 계산하지 않음.</p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>단순히 원형, 캡슐형을 생각해서 계산하니 예제에 맞지 않는다.<br />
우선 분기해야하는 부분이 C와 W 속도 차이.<br />
차량보다 도보가 빠르면 차량을 탈 이유가 없다.<br />
따라서 <span style="color: orange;"><strong>W가 C보다 크거나 같을 경우 도보로 가능한 원의 너비를 계산</strong></span>하면 끝.</p>

<p>C가 W보다 큰게 문제인데<br />
우선 도로를 타고 차량을 타고 이동한다.<br />
거기서 내린 뒤 남은 시간동안 도보로 이동할 수 있다.</p>

<p>도보로 이동하는 거리는 차량을 쓰는 만큼 줄어든다.<br />
0 &lt;= x &lt;= T * C 만큼 차를 타고 이동하면 남은 시간은 T - x / C 이며<br />
보행반경이 W * (T - x / C) 만큼 줄어든다.</p>

<p>순수 도보로 그려지는 원의 경계가 더 큰 동안 원의 경계를 따르고<br />
이후 차량-&gt;도보로 그려지는 선형구간의 넓이를 추가한다.</p>

<p>도보 원의 세그먼트 면적과 차량-&gt;도보로 이어지는 선형구간을 합하고 양쪽으로 갈 수 있으니 2를 곱해서 나오는 공식은<br />
<span style="color: orange;"><strong>2 * T^2 * (W^2 * arcsin(W/C) + W * sqrt(C^2 - W^2))</strong></span></p>

<p>아 머리아파</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="n">T</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">C</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">T</span> <span class="o">&gt;&gt;</span> <span class="n">W</span> <span class="o">&gt;&gt;</span> <span class="n">C</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">result</span><span class="p">;</span>


        <span class="k">if</span> <span class="p">(</span><span class="n">C</span> <span class="o">&lt;=</span> <span class="n">W</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 도보가 빠르면 원 면적 계산</span>
            <span class="c1">// (W*T)^2 * π</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">W</span> <span class="o">*</span> <span class="n">W</span> <span class="o">*</span> <span class="n">T</span> <span class="o">*</span> <span class="n">T</span> <span class="o">*</span> <span class="n">M_PI</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 차량이 빠르면 공식에 대입</span>
            <span class="c1">// 2 * T^2 * (W^2 * arcsin(W/C) + W * sqrt(C^2 - W^2))</span>
            <span class="kt">double</span> <span class="n">term1</span> <span class="o">=</span> <span class="n">W</span> <span class="o">*</span> <span class="n">W</span> <span class="o">*</span> <span class="n">asin</span><span class="p">(</span><span class="n">W</span> <span class="o">/</span> <span class="n">C</span><span class="p">);</span> <span class="c1">// W^2 * arcsin(W/C)</span>
            <span class="kt">double</span> <span class="n">term2</span> <span class="o">=</span> <span class="n">W</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span> <span class="n">C</span> <span class="o">-</span> <span class="n">W</span> <span class="o">*</span> <span class="n">W</span><span class="p">);</span> <span class="c1">// W * sqrt(C^2 - W^2)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">T</span> <span class="o">*</span> <span class="n">T</span> <span class="o">*</span> <span class="p">(</span><span class="n">term1</span> <span class="o">+</span> <span class="n">term2</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// 소수점 셋째 자리까지 출력</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%.3f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/C++/2025-05-28-16085/img02.jpg" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>이딴게 왜 골드? 하고 접근했다가<br />
예제 다틀려서 상당히 당황했다.</p>

<p>세상만사 다 이유가 있지…</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/random-solve/C%2B%2B/2025-05-28-16085.cpp">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="random-solve/C++/" /><summary type="html"><![CDATA[문제 16085번 Гэмт хэрэг - 백준 번역 형사가 용의자가 있을 수 있는 지역의 넓이를 계산하는 문제. 정보가 들어온지 T초가 지났다. 차량은 오직 도로 위로만 이동하며 도로는 단 하나 존재한다.(x축) 도보로는 도로를 벗어날 수 있다.(y축) 도보로는 초당 W미터, 차를 타면 초당 C 미터 이동 가능하다. 탑승, 하차 시간은 계산하지 않음. 설계 단순히 원형, 캡슐형을 생각해서 계산하니 예제에 맞지 않는다. 우선 분기해야하는 부분이 C와 W 속도 차이. 차량보다 도보가 빠르면 차량을 탈 이유가 없다. 따라서 W가 C보다 크거나 같을 경우 도보로 가능한 원의 너비를 계산하면 끝. C가 W보다 큰게 문제인데 우선 도로를 타고 차량을 타고 이동한다. 거기서 내린 뒤 남은 시간동안 도보로 이동할 수 있다. 도보로 이동하는 거리는 차량을 쓰는 만큼 줄어든다. 0 &lt;= x &lt;= T * C 만큼 차를 타고 이동하면 남은 시간은 T - x / C 이며 보행반경이 W * (T - x / C) 만큼 줄어든다. 순수 도보로 그려지는 원의 경계가 더 큰 동안 원의 경계를 따르고 이후 차량-&gt;도보로 그려지는 선형구간의 넓이를 추가한다. 도보 원의 세그먼트 면적과 차량-&gt;도보로 이어지는 선형구간을 합하고 양쪽으로 갈 수 있으니 2를 곱해서 나오는 공식은 2 * T^2 * (W^2 * arcsin(W/C) + W * sqrt(C^2 - W^2)) 아 머리아파 구현 #include &lt;iostream&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; using namespace std; int main() { int n; cin &gt;&gt; n; while (n--) { double T, W, C; cin &gt;&gt; T &gt;&gt; W &gt;&gt; C; double result; if (C &lt;= W) { // 도보가 빠르면 원 면적 계산 // (W*T)^2 * π result = W * W * T * T * M_PI; } else { // 차량이 빠르면 공식에 대입 // 2 * T^2 * (W^2 * arcsin(W/C) + W * sqrt(C^2 - W^2)) double term1 = W * W * asin(W / C); // W^2 * arcsin(W/C) double term2 = W * sqrt(C * C - W * W); // W * sqrt(C^2 - W^2) result = 2.0 * T * T * (term1 + term2); } // 소수점 셋째 자리까지 출력 printf("%.3f\n", result); } return 0; } 채점 반성 이딴게 왜 골드? 하고 접근했다가 예제 다틀려서 상당히 당황했다. 세상만사 다 이유가 있지… 코드 확인 Link to GitHub]]></summary></entry><entry><title type="html">던전 생성기 02</title><link href="https://movingwoo.com/one-pan/javascript/2025/05/28/Dungeon-Generator-02.html" rel="alternate" type="text/html" title="던전 생성기 02" /><published>2025-05-28T02:00:00+00:00</published><updated>2025-05-28T02:00:00+00:00</updated><id>https://movingwoo.com/one-pan/javascript/2025/05/28/Dungeon%20Generator%2002</id><content type="html" xml:base="https://movingwoo.com/one-pan/javascript/2025/05/28/Dungeon-Generator-02.html"><![CDATA[<blockquote>
  <h4 id="개요">개요</h4>
  <hr />
</blockquote>

<p>남은 두개의 알고리즘으로 맵 만들기<br />
<span style="color: orange;"><strong>즐 겁 다 !!</strong></span></p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-delaunay-triangulation--mst">1. Delaunay Triangulation + MST</h5>

<p>얘는 왜 두개가 합쳐졌느냐???</p>

<p>우선 랜덤한 점을 방의 중심점으로 사용해 방을 넒힌다.  <br />
그리고 Delaunay Triangulation 알고리즘으로 모든 점을 삼각형으로 연결해<br />
각 삼각형의 외접원이 다른 점을 포함하지 않도록 최적의 삼각형 분할을 생성한다.<br />
마지막으로 MST 알고리즘은 모든 방을 연결하는 최소 비용의 통로를 생성한다.</p>

<p>Delaunay Triangulation만 사용할 경우 모든 점이 서로 연결되어 너무 많은 통로가 생성되어 어지럽다.<br />
이를 커버하는게 MST의 역할이다.</p>

<p>덕분에 자연스러운 방 배치와 효율적인 통로 연결이 이루어지게 된다.</p>

<p>삼각형 생성이 중요한데 삼각형을 생성하는 것으로 아래와 같은 일들이 가능해진다.</p>
<ul>
  <li><span style="color: orange;"><strong>국지적 연결을 최적화해 가까운 방들끼리 통로가 생기는 기반 마련</strong></span></li>
  <li><span style="color: orange;"><strong>삼각형의 변이 후보 연결선이 됨</strong></span></li>
  <li><span style="color: orange;"><strong>삼각형은 면을 채울 수 있는 기본 단위라 공간을 균형있게 분할하기 유리함</strong></span></li>
</ul>

<p>이렇게 생성된 삼각형들을 MST가 간소화해 효율성을 확보한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 점 클래스</span>
<span class="kd">class</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="nf">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nf">equals</span><span class="p">(</span><span class="nx">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">===</span> <span class="nx">other</span><span class="p">.</span><span class="nx">x</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">===</span> <span class="nx">other</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 간선 클래스</span>
<span class="kd">class</span> <span class="nc">Edge</span> <span class="p">{</span>
    <span class="nf">constructor</span><span class="p">(</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">p1</span> <span class="o">=</span> <span class="nx">p1</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">p2</span> <span class="o">=</span> <span class="nx">p2</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">weight</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span>
            <span class="nb">Math</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="nx">p2</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="nx">p1</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="nx">p2</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">p1</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 삼각형 클래스</span>
<span class="kd">class</span> <span class="nc">Triangle</span> <span class="p">{</span>
    <span class="nf">constructor</span><span class="p">(</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">p3</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">p1</span> <span class="o">=</span> <span class="nx">p1</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">p2</span> <span class="o">=</span> <span class="nx">p2</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">p3</span> <span class="o">=</span> <span class="nx">p3</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 외접원의 중심과 반지름 계산</span>
    <span class="nf">circumcircle</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">d</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="o">+</span> 
                      <span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="o">+</span> 
                      <span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">y</span><span class="p">));</span>
        <span class="kd">const</span> <span class="nx">ux</span> <span class="o">=</span> <span class="p">((</span><span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="o">+</span>
                   <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="o">+</span>
                   <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">y</span><span class="p">))</span> <span class="o">/</span> <span class="nx">d</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">uy</span> <span class="o">=</span> <span class="p">((</span><span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">x</span><span class="p">)</span> <span class="o">+</span>
                   <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">x</span><span class="p">)</span> <span class="o">+</span>
                   <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">x</span><span class="p">))</span> <span class="o">/</span> <span class="nx">d</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">center</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="p">(</span><span class="nx">ux</span><span class="p">,</span> <span class="nx">uy</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">radius</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span>
            <span class="nb">Math</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="nx">center</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">center</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">);</span>
        <span class="k">return</span> <span class="p">{</span> <span class="nx">center</span><span class="p">,</span> <span class="nx">radius</span> <span class="p">};</span>
    <span class="p">}</span>

    <span class="c1">// 점이 외접원 내부에 있는지 확인</span>
    <span class="nf">containsPoint</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="p">{</span> <span class="nx">center</span><span class="p">,</span> <span class="nx">radius</span> <span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nf">circumcircle</span><span class="p">();</span>
        <span class="kd">const</span> <span class="nx">distance</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span>
            <span class="nb">Math</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="nx">center</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">center</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">);</span>
        <span class="k">return</span> <span class="nx">distance</span> <span class="o">&lt;</span> <span class="nx">radius</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">async</span> <span class="kd">function</span> <span class="nf">startDelaunay</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">initMap</span><span class="p">();</span>
    
    <span class="c1">// 랜덤 점 생성 (방의 중심점)</span>
    <span class="kd">const</span> <span class="nx">points</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">const</span> <span class="nx">numPoints</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">// 방의 개수</span>
    <span class="kd">const</span> <span class="nx">roomSize</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 방 크기</span>
    <span class="kd">const</span> <span class="nx">margin</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 방 사이의 최소 간격</span>
    
    <span class="c1">// 방이 겹치는지 확인</span>
    <span class="kd">function</span> <span class="nf">isOverlapping</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">dy</span> <span class="o">=</span> <span class="o">-</span><span class="nx">size</span> <span class="o">-</span> <span class="nx">margin</span><span class="p">;</span> <span class="nx">dy</span> <span class="o">&lt;=</span> <span class="nx">size</span> <span class="o">+</span> <span class="nx">margin</span><span class="p">;</span> <span class="nx">dy</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">dx</span> <span class="o">=</span> <span class="o">-</span><span class="nx">size</span> <span class="o">-</span> <span class="nx">margin</span><span class="p">;</span> <span class="nx">dx</span> <span class="o">&lt;=</span> <span class="nx">size</span> <span class="o">+</span> <span class="nx">margin</span><span class="p">;</span> <span class="nx">dx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kd">const</span> <span class="nx">nx</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">;</span>
                <span class="kd">const</span> <span class="nx">ny</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">;</span>
                <span class="k">if </span><span class="p">(</span><span class="nx">nx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nx</span> <span class="o">&lt;</span> <span class="nx">cols</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&lt;</span> <span class="nx">rows</span> <span class="o">&amp;&amp;</span> <span class="nx">map</span><span class="p">[</span><span class="nx">ny</span><span class="p">][</span><span class="nx">nx</span><span class="p">]</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// 안전한 위치 찾기</span>
    <span class="kd">function</span> <span class="nf">findSafePosition</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">attempts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">maxAttempts</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
        
        <span class="k">do</span> <span class="p">{</span>
            <span class="nx">x</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">cols</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">roomSize</span><span class="p">))</span> <span class="o">+</span> <span class="nx">roomSize</span><span class="p">;</span>
            <span class="nx">y</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">rows</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">roomSize</span><span class="p">))</span> <span class="o">+</span> <span class="nx">roomSize</span><span class="p">;</span>
            <span class="nx">attempts</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while </span><span class="p">(</span><span class="nf">isOverlapping</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">roomSize</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">attempts</span> <span class="o">&lt;</span> <span class="nx">maxAttempts</span><span class="p">);</span>
        
        <span class="k">return</span> <span class="nx">attempts</span> <span class="o">&lt;</span> <span class="nx">maxAttempts</span> <span class="p">?</span> <span class="p">{</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">}</span> <span class="p">:</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// 방 생성</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">numPoints</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">pos</span> <span class="o">=</span> <span class="nf">findSafePosition</span><span class="p">();</span>
        <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">pos</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// 안전한 위치를 찾지 못하면 건너뛰기</span>
        
        <span class="nx">points</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="k">new</span> <span class="nc">Point</span><span class="p">(</span><span class="nx">pos</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">pos</span><span class="p">.</span><span class="nx">y</span><span class="p">));</span>
        
        <span class="c1">// 방 생성</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">dy</span> <span class="o">=</span> <span class="o">-</span><span class="nx">roomSize</span><span class="p">;</span> <span class="nx">dy</span> <span class="o">&lt;=</span> <span class="nx">roomSize</span><span class="p">;</span> <span class="nx">dy</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">dx</span> <span class="o">=</span> <span class="o">-</span><span class="nx">roomSize</span><span class="p">;</span> <span class="nx">dx</span> <span class="o">&lt;=</span> <span class="nx">roomSize</span><span class="p">;</span> <span class="nx">dx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kd">const</span> <span class="nx">nx</span> <span class="o">=</span> <span class="nx">pos</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">;</span>
                <span class="kd">const</span> <span class="nx">ny</span> <span class="o">=</span> <span class="nx">pos</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">;</span>
                <span class="k">if </span><span class="p">(</span><span class="nx">nx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nx</span> <span class="o">&lt;</span> <span class="nx">cols</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">map</span><span class="p">[</span><span class="nx">ny</span><span class="p">][</span><span class="nx">nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">nx</span><span class="p">,</span> <span class="nx">ny</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="kd">const</span> <span class="nx">triangles</span> <span class="o">=</span> <span class="nf">delaunayTriangulation</span><span class="p">(</span><span class="nx">points</span><span class="p">);</span>
    
    <span class="c1">// 간선 추출</span>
    <span class="kd">const</span> <span class="nx">edges</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">();</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">triangle</span> <span class="k">of</span> <span class="nx">triangles</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">edges</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="k">new</span> <span class="nc">Edge</span><span class="p">(</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">triangle</span><span class="p">.</span><span class="nx">p2</span><span class="p">));</span>
        <span class="nx">edges</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="k">new</span> <span class="nc">Edge</span><span class="p">(</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p2</span><span class="p">,</span> <span class="nx">triangle</span><span class="p">.</span><span class="nx">p3</span><span class="p">));</span>
        <span class="nx">edges</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="k">new</span> <span class="nc">Edge</span><span class="p">(</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p3</span><span class="p">,</span> <span class="nx">triangle</span><span class="p">.</span><span class="nx">p1</span><span class="p">));</span>
    <span class="p">}</span>
    
    <span class="kd">const</span> <span class="nx">mstEdges</span> <span class="o">=</span> <span class="nf">kruskalMST</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">edges</span><span class="p">));</span>
    
    <span class="c1">// MST 간선을 따라 통로 생성</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">edge</span> <span class="k">of</span> <span class="nx">mstEdges</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">await</span> <span class="nf">createCorridor</span><span class="p">(</span><span class="nx">edge</span><span class="p">.</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">edge</span><span class="p">.</span><span class="nx">p2</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="nf">generateEntrance</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Delaunay Triangulation 알고리즘</span>
<span class="kd">function</span> <span class="nf">delaunayTriangulation</span><span class="p">(</span><span class="nx">points</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">triangles</span> <span class="o">=</span> <span class="p">[];</span>
    
    <span class="c1">// 슈퍼 삼각형 생성 (모든 점을 포함하는 큰 삼각형)</span>
    <span class="c1">// 초기 삼각형이 필요해 생성하며 나중에 제거함</span>
    <span class="kd">const</span> <span class="nx">superTriangle</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Triangle</span><span class="p">(</span>
        <span class="k">new</span> <span class="nc">Point</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">),</span>
        <span class="k">new</span> <span class="nc">Point</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">),</span>
        <span class="k">new</span> <span class="nc">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="p">);</span>
    <span class="nx">triangles</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">superTriangle</span><span class="p">);</span>
    
    <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">point</span> <span class="k">of</span> <span class="nx">points</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">badTriangles</span> <span class="o">=</span> <span class="p">[];</span>
        
        <span class="c1">// 현재 점을 포함하는 삼각형 찾기</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">triangle</span> <span class="k">of</span> <span class="nx">triangles</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if </span><span class="p">(</span><span class="nx">triangle</span><span class="p">.</span><span class="nf">containsPoint</span><span class="p">(</span><span class="nx">point</span><span class="p">))</span> <span class="p">{</span>
                <span class="nx">badTriangles</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">triangle</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// 나쁜 삼각형들의 간선 찾기</span>
        <span class="c1">// 나쁜 삼각형은 너무 뾰족하거나 한 꼭지점에 너무 몰려 있는 못난 삼각형</span>
        <span class="kd">const</span> <span class="nx">edges</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">();</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">triangle</span> <span class="k">of</span> <span class="nx">badTriangles</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">edges</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="k">new</span> <span class="nc">Edge</span><span class="p">(</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">triangle</span><span class="p">.</span><span class="nx">p2</span><span class="p">));</span>
            <span class="nx">edges</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="k">new</span> <span class="nc">Edge</span><span class="p">(</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p2</span><span class="p">,</span> <span class="nx">triangle</span><span class="p">.</span><span class="nx">p3</span><span class="p">));</span>
            <span class="nx">edges</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="k">new</span> <span class="nc">Edge</span><span class="p">(</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p3</span><span class="p">,</span> <span class="nx">triangle</span><span class="p">.</span><span class="nx">p1</span><span class="p">));</span>
        <span class="p">}</span>
        
        <span class="c1">// 나쁜 삼각형 제거</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">triangle</span> <span class="k">of</span> <span class="nx">badTriangles</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">triangles</span><span class="p">.</span><span class="nf">indexOf</span><span class="p">(</span><span class="nx">triangle</span><span class="p">);</span>
            <span class="k">if </span><span class="p">(</span><span class="nx">index</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">triangles</span><span class="p">.</span><span class="nf">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// 새로운 삼각형 생성</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">edge</span> <span class="k">of</span> <span class="nx">edges</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">triangles</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="k">new</span> <span class="nc">Triangle</span><span class="p">(</span><span class="nx">edge</span><span class="p">.</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">edge</span><span class="p">.</span><span class="nx">p2</span><span class="p">,</span> <span class="nx">point</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// 슈퍼 삼각형과 관련된 삼각형 제거</span>
    <span class="k">return</span> <span class="nx">triangles</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="nx">triangle</span> <span class="o">=&gt;</span> 
        <span class="o">!</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nf">equals</span><span class="p">(</span><span class="nx">superTriangle</span><span class="p">.</span><span class="nx">p1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nf">equals</span><span class="p">(</span><span class="nx">superTriangle</span><span class="p">.</span><span class="nx">p2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nf">equals</span><span class="p">(</span><span class="nx">superTriangle</span><span class="p">.</span><span class="nx">p3</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nf">equals</span><span class="p">(</span><span class="nx">superTriangle</span><span class="p">.</span><span class="nx">p1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nf">equals</span><span class="p">(</span><span class="nx">superTriangle</span><span class="p">.</span><span class="nx">p2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nf">equals</span><span class="p">(</span><span class="nx">superTriangle</span><span class="p">.</span><span class="nx">p3</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nf">equals</span><span class="p">(</span><span class="nx">superTriangle</span><span class="p">.</span><span class="nx">p1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nf">equals</span><span class="p">(</span><span class="nx">superTriangle</span><span class="p">.</span><span class="nx">p2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nf">equals</span><span class="p">(</span><span class="nx">superTriangle</span><span class="p">.</span><span class="nx">p3</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Kruskal's MST 알고리즘</span>
<span class="kd">function</span> <span class="nf">kruskalMST</span><span class="p">(</span><span class="nx">edges</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 간선을 가중치 순으로 정렬</span>
    <span class="nx">edges</span><span class="p">.</span><span class="nf">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">weight</span> <span class="o">-</span> <span class="nx">b</span><span class="p">.</span><span class="nx">weight</span><span class="p">);</span>
    
    <span class="kd">const</span> <span class="nx">mst</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">const</span> <span class="nx">sets</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Map</span><span class="p">();</span>
    
    <span class="c1">// 각 점을 독립적인 집합으로 초기화</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">edge</span> <span class="k">of</span> <span class="nx">edges</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">sets</span><span class="p">.</span><span class="nf">has</span><span class="p">(</span><span class="nx">edge</span><span class="p">.</span><span class="nx">p1</span><span class="p">))</span> <span class="nx">sets</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">edge</span><span class="p">.</span><span class="nx">p1</span><span class="p">,</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">([</span><span class="nx">edge</span><span class="p">.</span><span class="nx">p1</span><span class="p">]));</span>
        <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">sets</span><span class="p">.</span><span class="nf">has</span><span class="p">(</span><span class="nx">edge</span><span class="p">.</span><span class="nx">p2</span><span class="p">))</span> <span class="nx">sets</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">edge</span><span class="p">.</span><span class="nx">p2</span><span class="p">,</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">([</span><span class="nx">edge</span><span class="p">.</span><span class="nx">p2</span><span class="p">]));</span>
    <span class="p">}</span>
    
    <span class="c1">// 사이클을 형성하지 않는 간선만 선택</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">edge</span> <span class="k">of</span> <span class="nx">edges</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">set1</span> <span class="o">=</span> <span class="nx">sets</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">edge</span><span class="p">.</span><span class="nx">p1</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">set2</span> <span class="o">=</span> <span class="nx">sets</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">edge</span><span class="p">.</span><span class="nx">p2</span><span class="p">);</span>
        
        <span class="k">if </span><span class="p">(</span><span class="nx">set1</span> <span class="o">!==</span> <span class="nx">set2</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">mst</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">edge</span><span class="p">);</span>
            
            <span class="c1">// 두 집합 합치기</span>
            <span class="kd">const</span> <span class="nx">union</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">();</span>
            <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">p</span> <span class="k">of</span> <span class="nx">set1</span><span class="p">)</span> <span class="nx">union</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
            <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">p</span> <span class="k">of</span> <span class="nx">set2</span><span class="p">)</span> <span class="nx">union</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>

            <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">point</span> <span class="k">of</span> <span class="nx">union</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">sets</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">point</span><span class="p">,</span> <span class="nx">union</span><span class="p">);</span>  <span class="c1">// 각 포인트가 새로운 union 집합을 참조하도록 갱신</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="nx">mst</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 두 점 사이의 통로 생성</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">createCorridor</span><span class="p">(</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">dx</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sign</span><span class="p">(</span><span class="nx">p2</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="nx">p1</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">dy</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sign</span><span class="p">(</span><span class="nx">p2</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">p1</span><span class="p">.</span><span class="nx">y</span><span class="p">);</span>
    
    <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">p1</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">p1</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span>
    
    <span class="c1">// x축 방향으로 먼저 이동</span>
    <span class="k">while </span><span class="p">(</span><span class="nx">x</span> <span class="o">!==</span> <span class="nx">p2</span><span class="p">.</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">map</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
        <span class="nx">x</span> <span class="o">+=</span> <span class="nx">dx</span><span class="p">;</span>
        <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">// y축 방향으로 이동</span>
    <span class="k">while </span><span class="p">(</span><span class="nx">y</span> <span class="o">!==</span> <span class="nx">p2</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">map</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
        <span class="nx">y</span> <span class="o">+=</span> <span class="nx">dy</span><span class="p">;</span>
        <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="2-wfc-알고리즘">2. WFC 알고리즘</h5>

<p>다소 난해했던 알고리즘<br />
주변 셀에 따라 가능한 옵션을 줄이며 점차 결정하는 방식이다.<br />
규칙을 설정해두는게 무엇보다 중요하다.</p>

<p>WFC는 Wave Function Collapse의 약자인데<br />
Wave Function은 모든 타일이 겹쳐진 상태를 의미하고 Collapse는 결정하는 과정을 말한다.<br />
다른 내용은 괜찮은데 엔트로피 개념이 갑자기 끼어들어서 헷갈렸다.<br />
WFC에서의 <span style="color: orange;"><strong>엔트로피는 셀의 불확실성 정도, 그 셀에서 가능한 타일 후보 수</strong></span>를 의미한다.<br />
가능한 타일이 많을수록 엔트로피가 높은 셀인 것.</p>

<p>흐름은 아래와 같다.</p>
<ul>
  <li><span style="color: orange;"><strong>모든 셀은 타일 후보를 가지고 시작</strong></span></li>
  <li><span style="color: orange;"><strong>가장 적은 옵션을 가진 셀 선택(엔트로피가 가장 낮은 셀)</strong></span></li>
  <li><span style="color: orange;"><strong>그 셀이 가능한 타일 중 하나를 무작위로 결정(collapse)</strong></span></li>
  <li><span style="color: orange;"><strong>전파(Propagation)</strong></span></li>
  <li><span style="color: orange;"><strong>결정과 전파 반복</strong></span></li>
</ul>

<p>설정한 타일로 가득 채워진 맵을 얻을 수 있으며 타일을 잘 설정할수록 상당히 구조적인 맵이 나온다.<br />
나는 불확실성으로 가득찬게 좋아서 타일을 8개 맘대로 집어넣었더니 결과물이 깔끔해 보이진 않는다.</p>

<p>개념을 확실히 정립하기 전에는 방 전체가 뚫린다던가 죄다 벽이라던가 구현이 어려웠다.<br />
그래도 전파되며 만들어지는 모습이 아름답다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 2x2 타일 사전 정의</span>
<span class="kd">const</span> <span class="nx">tiles</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span>
        <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">wall</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// 전체 벽</span>
        <span class="na">data</span><span class="p">:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
        <span class="na">edges</span><span class="p">:</span> <span class="p">{</span> <span class="na">up</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">right</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">down</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">left</span><span class="p">:</span> <span class="mi">1</span> <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">floor</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// 전체 통로</span>
        <span class="na">data</span><span class="p">:</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
        <span class="na">edges</span><span class="p">:</span> <span class="p">{</span> <span class="na">up</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">right</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">down</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">left</span><span class="p">:</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">hall_h</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// 수평 복도</span>
        <span class="na">data</span><span class="p">:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
        <span class="na">edges</span><span class="p">:</span> <span class="p">{</span> <span class="na">up</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">right</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">down</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">left</span><span class="p">:</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">hall_v</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// 수직 복도</span>
        <span class="na">data</span><span class="p">:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
        <span class="na">edges</span><span class="p">:</span> <span class="p">{</span> <span class="na">up</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">right</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">down</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">left</span><span class="p">:</span> <span class="mi">1</span> <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">room_corner_top_left</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// 위/왼쪽이 열린 방 구석</span>
        <span class="na">data</span><span class="p">:</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
        <span class="na">edges</span><span class="p">:</span> <span class="p">{</span> <span class="na">up</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">right</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">down</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">left</span><span class="p">:</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">room_corner_bottom_right</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// 아래/오른쪽 열린 방 구석</span>
        <span class="na">data</span><span class="p">:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
        <span class="na">edges</span><span class="p">:</span> <span class="p">{</span> <span class="na">up</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">right</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">down</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">left</span><span class="p">:</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">junction_T_up</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// T자 모양 (위쪽 갈래)</span>
        <span class="na">data</span><span class="p">:</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
        <span class="na">edges</span><span class="p">:</span> <span class="p">{</span> <span class="na">up</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">right</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">down</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">left</span><span class="p">:</span> <span class="mi">1</span> <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">dead_end_left</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// 왼쪽에만 열린 막다른길</span>
        <span class="na">data</span><span class="p">:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
        <span class="na">edges</span><span class="p">:</span> <span class="p">{</span> <span class="na">up</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">right</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">down</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">left</span><span class="p">:</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">];</span>
  
<span class="c1">// 붙으려는 상대방 타일의 방향을 찾기 위한 반대 방향 매핑</span>
<span class="kd">const</span> <span class="nx">opposite</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">up</span><span class="p">:</span> <span class="dl">"</span><span class="s2">down</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">down</span><span class="p">:</span> <span class="dl">"</span><span class="s2">up</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">left</span><span class="p">:</span> <span class="dl">"</span><span class="s2">right</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">right</span><span class="p">:</span> <span class="dl">"</span><span class="s2">left</span><span class="dl">"</span>
<span class="p">};</span>

<span class="c1">// 타일 간 인접성 판단</span>
<span class="kd">function</span> <span class="nf">compatible</span><span class="p">(</span><span class="nx">tileA</span><span class="p">,</span> <span class="nx">tileB</span><span class="p">,</span> <span class="nx">direction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">tileA</span><span class="p">.</span><span class="nx">edges</span><span class="p">[</span><span class="nx">direction</span><span class="p">]</span> <span class="o">===</span> <span class="nx">tileB</span><span class="p">.</span><span class="nx">edges</span><span class="p">[</span><span class="nx">opposite</span><span class="p">[</span><span class="nx">direction</span><span class="p">]];</span>
<span class="p">}</span>

<span class="c1">// 셀 클래스 (1칸마다 타일 1개)</span>
<span class="kd">class</span> <span class="nc">WFC_TileCell</span> <span class="p">{</span>
    <span class="nf">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">options</span> <span class="o">=</span> <span class="nx">tiles</span><span class="p">.</span><span class="nf">slice</span><span class="p">();</span> <span class="c1">// 가능한 타일들</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">collapsed</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nf">collapse</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">pick</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">options</span><span class="p">[</span><span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">length</span><span class="p">)];</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">options</span> <span class="o">=</span> <span class="p">[</span><span class="nx">pick</span><span class="p">];</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">collapsed</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">pick</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nf">getTile</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">options</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">async</span> <span class="kd">function</span> <span class="nf">startWFC</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">initMap</span><span class="p">();</span>

    <span class="kd">const</span> <span class="nx">tileSize</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 2x2 타일</span>
    <span class="kd">const</span> <span class="nx">tileCols</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nx">cols</span> <span class="o">/</span> <span class="nx">tileSize</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">tileRows</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nx">rows</span> <span class="o">/</span> <span class="nx">tileSize</span><span class="p">);</span>

    <span class="kd">const</span> <span class="nx">grid</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">({</span> <span class="na">length</span><span class="p">:</span> <span class="nx">tileRows</span> <span class="p">},</span> <span class="p">(</span><span class="nx">_</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">({</span> <span class="na">length</span><span class="p">:</span> <span class="nx">tileCols</span> <span class="p">},</span> <span class="p">(</span><span class="nx">_</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nc">WFC_TileCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">))</span>
    <span class="p">);</span>

    <span class="c1">// collapse 루프</span>
    <span class="kd">let</span> <span class="nx">pending</span> <span class="o">=</span> <span class="nx">grid</span><span class="p">.</span><span class="nf">flat</span><span class="p">().</span><span class="nf">filter</span><span class="p">(</span><span class="nx">cell</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="nx">cell</span><span class="p">.</span><span class="nx">collapsed</span><span class="p">);</span>

    <span class="k">while </span><span class="p">(</span><span class="nx">pending</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 아직 collapse되지 않은 셀 중에서 가능한 옵션이 가장 적은 값 찾기</span>
        <span class="kd">let</span> <span class="nx">minEntropy</span> <span class="o">=</span> <span class="nx">pending</span><span class="p">.</span><span class="nf">reduce</span><span class="p">((</span><span class="nx">min</span><span class="p">,</span> <span class="nx">cell</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="nx">min</span><span class="p">,</span> <span class="nx">cell</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">length</span><span class="p">),</span> <span class="kc">Infinity</span><span class="p">);</span>
        <span class="c1">// 가능한 옵션 수가 최소인 셀들만 필터링</span>
        <span class="kd">let</span> <span class="nx">choices</span> <span class="o">=</span> <span class="nx">pending</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="nx">c</span> <span class="o">=&gt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="nx">minEntropy</span><span class="p">);</span>
        <span class="c1">// 그 중 하나를 랜덤 선택</span>
        <span class="kd">let</span> <span class="nx">cell</span> <span class="o">=</span> <span class="nx">choices</span><span class="p">[</span><span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">choices</span><span class="p">.</span><span class="nx">length</span><span class="p">)];</span>

        <span class="kd">const</span> <span class="nx">tile</span> <span class="o">=</span> <span class="nx">cell</span><span class="p">.</span><span class="nf">collapse</span><span class="p">();</span>

        <span class="c1">// 타일을 실제 맵에 그리기</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">dy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">dy</span> <span class="o">&lt;</span> <span class="nx">tileSize</span><span class="p">;</span> <span class="nx">dy</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">dx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">dx</span> <span class="o">&lt;</span> <span class="nx">tileSize</span><span class="p">;</span> <span class="nx">dx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">mx</span> <span class="o">=</span> <span class="nx">cell</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="nx">tileSize</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">;</span>
            <span class="kd">const</span> <span class="nx">my</span> <span class="o">=</span> <span class="nx">cell</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="nx">tileSize</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">;</span>

            <span class="k">if </span><span class="p">(</span><span class="nx">mx</span> <span class="o">&lt;</span> <span class="nx">cols</span> <span class="o">&amp;&amp;</span> <span class="nx">my</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">map</span><span class="p">[</span><span class="nx">my</span><span class="p">][</span><span class="nx">mx</span><span class="p">]</span> <span class="o">=</span> <span class="nx">tile</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">dy</span><span class="p">][</span><span class="nx">dx</span><span class="p">];</span>
              <span class="nf">drawCell</span><span class="p">(</span><span class="nx">mx</span><span class="p">,</span> <span class="nx">my</span><span class="p">,</span> <span class="nx">tile</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">dy</span><span class="p">][</span><span class="nx">dx</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

        <span class="c1">// 주변 셀 옵션 줄이기</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="p">[</span><span class="nx">dir</span><span class="p">,</span> <span class="p">[</span><span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">]]</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">entries</span><span class="p">({</span>
            <span class="na">up</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="na">right</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="na">down</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="na">left</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="p">}))</span> <span class="p">{</span>
                <span class="kd">const</span> <span class="nx">nx</span> <span class="o">=</span> <span class="nx">cell</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">;</span>
                <span class="kd">const</span> <span class="nx">ny</span> <span class="o">=</span> <span class="nx">cell</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">;</span>

                <span class="k">if </span><span class="p">(</span><span class="nx">nx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">ny</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">nx</span> <span class="o">&gt;=</span> <span class="nx">tileCols</span> <span class="o">||</span> <span class="nx">ny</span> <span class="o">&gt;=</span> <span class="nx">tileRows</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

                <span class="kd">const</span> <span class="nx">neighbor</span> <span class="o">=</span> <span class="nx">grid</span><span class="p">[</span><span class="nx">ny</span><span class="p">][</span><span class="nx">nx</span><span class="p">];</span>
                <span class="k">if </span><span class="p">(</span><span class="nx">neighbor</span><span class="p">.</span><span class="nx">collapsed</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

                <span class="c1">// 현재 셀과 호환되는 타일만 남김</span>
                <span class="nx">neighbor</span><span class="p">.</span><span class="nx">options</span> <span class="o">=</span> <span class="nx">neighbor</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="nx">opt</span> <span class="o">=&gt;</span>
                    <span class="nf">compatible</span><span class="p">(</span><span class="nx">tile</span><span class="p">,</span> <span class="nx">opt</span><span class="p">,</span> <span class="nx">dir</span><span class="p">)</span>
                <span class="p">);</span>
            <span class="p">}</span>

            <span class="nx">pending</span> <span class="o">=</span> <span class="nx">grid</span><span class="p">.</span><span class="nf">flat</span><span class="p">().</span><span class="nf">filter</span><span class="p">(</span><span class="nx">c</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="nx">c</span><span class="p">.</span><span class="nx">collapsed</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">await</span> <span class="nf">generateEntrance</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="완성">완성</h4>
  <hr />
</blockquote>

<p>Delaunay Triangulation + MST<br />
<img src="/assets/images/posts/one-pan/JavaScript/2025-05-28-Dungeon Generator 02/img01.gif" alt="img01" /></p>

<p>WFC<br />
<img src="/assets/images/posts/one-pan/JavaScript/2025-05-28-Dungeon Generator 02/img02.gif" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>동굴 지형같은 구불구불 무작위보다 구조적인 지형을 구성하는게 무엇보다 더 어려운 느낌이다.<br />
우연하게 태어난 아름다움과 철저히 설계된 아름다움의 차이로 느껴진다.<br />
아 감성적인 하루</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="/play/Dungeon%20Generator.html" target="_blank" rel="noopener noreferrer">
  직접 해보기
</a></p>

<p>Delaunay Triangulation + MST<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-28-Delaunay.js">Link to GitHub</a></p>

<p>WFC<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-28-WFC.js">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="one-pan/JavaScript/" /><summary type="html"><![CDATA[개요 남은 두개의 알고리즘으로 맵 만들기 즐 겁 다 !! 구현 1. Delaunay Triangulation + MST 얘는 왜 두개가 합쳐졌느냐??? 우선 랜덤한 점을 방의 중심점으로 사용해 방을 넒힌다. 그리고 Delaunay Triangulation 알고리즘으로 모든 점을 삼각형으로 연결해 각 삼각형의 외접원이 다른 점을 포함하지 않도록 최적의 삼각형 분할을 생성한다. 마지막으로 MST 알고리즘은 모든 방을 연결하는 최소 비용의 통로를 생성한다. Delaunay Triangulation만 사용할 경우 모든 점이 서로 연결되어 너무 많은 통로가 생성되어 어지럽다. 이를 커버하는게 MST의 역할이다. 덕분에 자연스러운 방 배치와 효율적인 통로 연결이 이루어지게 된다. 삼각형 생성이 중요한데 삼각형을 생성하는 것으로 아래와 같은 일들이 가능해진다. 국지적 연결을 최적화해 가까운 방들끼리 통로가 생기는 기반 마련 삼각형의 변이 후보 연결선이 됨 삼각형은 면을 채울 수 있는 기본 단위라 공간을 균형있게 분할하기 유리함 이렇게 생성된 삼각형들을 MST가 간소화해 효율성을 확보한다. // 점 클래스 class Point { constructor(x, y) { this.x = x; this.y = y; } equals(other) { return this.x === other.x &amp;&amp; this.y === other.y; } } // 간선 클래스 class Edge { constructor(p1, p2) { this.p1 = p1; this.p2 = p2; this.weight = Math.sqrt( Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2) ); } } // 삼각형 클래스 class Triangle { constructor(p1, p2, p3) { this.p1 = p1; this.p2 = p2; this.p3 = p3; } // 외접원의 중심과 반지름 계산 circumcircle() { const d = 2 * (this.p1.x * (this.p2.y - this.p3.y) + this.p2.x * (this.p3.y - this.p1.y) + this.p3.x * (this.p1.y - this.p2.y)); const ux = ((this.p1.x * this.p1.x + this.p1.y * this.p1.y) * (this.p2.y - this.p3.y) + (this.p2.x * this.p2.x + this.p2.y * this.p2.y) * (this.p3.y - this.p1.y) + (this.p3.x * this.p3.x + this.p3.y * this.p3.y) * (this.p1.y - this.p2.y)) / d; const uy = ((this.p1.x * this.p1.x + this.p1.y * this.p1.y) * (this.p3.x - this.p2.x) + (this.p2.x * this.p2.x + this.p2.y * this.p2.y) * (this.p1.x - this.p3.x) + (this.p3.x * this.p3.x + this.p3.y * this.p3.y) * (this.p2.x - this.p1.x)) / d; const center = new Point(ux, uy); const radius = Math.sqrt( Math.pow(this.p1.x - center.x, 2) + Math.pow(this.p1.y - center.y, 2) ); return { center, radius }; } // 점이 외접원 내부에 있는지 확인 containsPoint(p) { const { center, radius } = this.circumcircle(); const distance = Math.sqrt( Math.pow(p.x - center.x, 2) + Math.pow(p.y - center.y, 2) ); return distance &lt; radius; } } async function startDelaunay() { initMap(); // 랜덤 점 생성 (방의 중심점) const points = []; const numPoints = 20; // 방의 개수 const roomSize = 2; // 방 크기 const margin = 2; // 방 사이의 최소 간격 // 방이 겹치는지 확인 function isOverlapping(x, y, size) { for (let dy = -size - margin; dy &lt;= size + margin; dy++) { for (let dx = -size - margin; dx &lt;= size + margin; dx++) { const nx = x + dx; const ny = y + dy; if (nx &gt;= 0 &amp;&amp; nx &lt; cols &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; rows &amp;&amp; map[ny][nx] === 0) { return true; } } } return false; } // 안전한 위치 찾기 function findSafePosition() { let x, y; let attempts = 0; const maxAttempts = 100; do { x = Math.floor(Math.random() * (cols - 2 * roomSize)) + roomSize; y = Math.floor(Math.random() * (rows - 2 * roomSize)) + roomSize; attempts++; } while (isOverlapping(x, y, roomSize) &amp;&amp; attempts &lt; maxAttempts); return attempts &lt; maxAttempts ? {x, y} : null; } // 방 생성 for (let i = 0; i &lt; numPoints; i++) { const pos = findSafePosition(); if (!pos) continue; // 안전한 위치를 찾지 못하면 건너뛰기 points.push(new Point(pos.x, pos.y)); // 방 생성 for (let dy = -roomSize; dy &lt;= roomSize; dy++) { for (let dx = -roomSize; dx &lt;= roomSize; dx++) { const nx = pos.x + dx; const ny = pos.y + dy; if (nx &gt;= 0 &amp;&amp; nx &lt; cols &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; rows) { map[ny][nx] = 0; drawCell(nx, ny, 'white'); } } } await sleep(50); } const triangles = delaunayTriangulation(points); // 간선 추출 const edges = new Set(); for (const triangle of triangles) { edges.add(new Edge(triangle.p1, triangle.p2)); edges.add(new Edge(triangle.p2, triangle.p3)); edges.add(new Edge(triangle.p3, triangle.p1)); } const mstEdges = kruskalMST(Array.from(edges)); // MST 간선을 따라 통로 생성 for (const edge of mstEdges) { await createCorridor(edge.p1, edge.p2); } generateEntrance(); } // Delaunay Triangulation 알고리즘 function delaunayTriangulation(points) { const triangles = []; // 슈퍼 삼각형 생성 (모든 점을 포함하는 큰 삼각형) // 초기 삼각형이 필요해 생성하며 나중에 제거함 const superTriangle = new Triangle( new Point(-100, -100), new Point(100, -100), new Point(0, 100) ); triangles.push(superTriangle); for (const point of points) { const badTriangles = []; // 현재 점을 포함하는 삼각형 찾기 for (const triangle of triangles) { if (triangle.containsPoint(point)) { badTriangles.push(triangle); } } // 나쁜 삼각형들의 간선 찾기 // 나쁜 삼각형은 너무 뾰족하거나 한 꼭지점에 너무 몰려 있는 못난 삼각형 const edges = new Set(); for (const triangle of badTriangles) { edges.add(new Edge(triangle.p1, triangle.p2)); edges.add(new Edge(triangle.p2, triangle.p3)); edges.add(new Edge(triangle.p3, triangle.p1)); } // 나쁜 삼각형 제거 for (const triangle of badTriangles) { const index = triangles.indexOf(triangle); if (index &gt; -1) { triangles.splice(index, 1); } } // 새로운 삼각형 생성 for (const edge of edges) { triangles.push(new Triangle(edge.p1, edge.p2, point)); } } // 슈퍼 삼각형과 관련된 삼각형 제거 return triangles.filter(triangle =&gt; !triangle.p1.equals(superTriangle.p1) &amp;&amp; !triangle.p1.equals(superTriangle.p2) &amp;&amp; !triangle.p1.equals(superTriangle.p3) &amp;&amp; !triangle.p2.equals(superTriangle.p1) &amp;&amp; !triangle.p2.equals(superTriangle.p2) &amp;&amp; !triangle.p2.equals(superTriangle.p3) &amp;&amp; !triangle.p3.equals(superTriangle.p1) &amp;&amp; !triangle.p3.equals(superTriangle.p2) &amp;&amp; !triangle.p3.equals(superTriangle.p3) ); } // Kruskal's MST 알고리즘 function kruskalMST(edges) { // 간선을 가중치 순으로 정렬 edges.sort((a, b) =&gt; a.weight - b.weight); const mst = []; const sets = new Map(); // 각 점을 독립적인 집합으로 초기화 for (const edge of edges) { if (!sets.has(edge.p1)) sets.set(edge.p1, new Set([edge.p1])); if (!sets.has(edge.p2)) sets.set(edge.p2, new Set([edge.p2])); } // 사이클을 형성하지 않는 간선만 선택 for (const edge of edges) { const set1 = sets.get(edge.p1); const set2 = sets.get(edge.p2); if (set1 !== set2) { mst.push(edge); // 두 집합 합치기 const union = new Set(); for (const p of set1) union.add(p); for (const p of set2) union.add(p); for (const point of union) { sets.set(point, union); // 각 포인트가 새로운 union 집합을 참조하도록 갱신 } } } return mst; } // 두 점 사이의 통로 생성 async function createCorridor(p1, p2) { const dx = Math.sign(p2.x - p1.x); const dy = Math.sign(p2.y - p1.y); let x = p1.x; let y = p1.y; // x축 방향으로 먼저 이동 while (x !== p2.x) { map[y][x] = 0; drawCell(x, y, 'white'); x += dx; await sleep(1); } // y축 방향으로 이동 while (y !== p2.y) { map[y][x] = 0; drawCell(x, y, 'white'); y += dy; await sleep(1); } } 2. WFC 알고리즘 다소 난해했던 알고리즘 주변 셀에 따라 가능한 옵션을 줄이며 점차 결정하는 방식이다. 규칙을 설정해두는게 무엇보다 중요하다. WFC는 Wave Function Collapse의 약자인데 Wave Function은 모든 타일이 겹쳐진 상태를 의미하고 Collapse는 결정하는 과정을 말한다. 다른 내용은 괜찮은데 엔트로피 개념이 갑자기 끼어들어서 헷갈렸다. WFC에서의 엔트로피는 셀의 불확실성 정도, 그 셀에서 가능한 타일 후보 수를 의미한다. 가능한 타일이 많을수록 엔트로피가 높은 셀인 것. 흐름은 아래와 같다. 모든 셀은 타일 후보를 가지고 시작 가장 적은 옵션을 가진 셀 선택(엔트로피가 가장 낮은 셀) 그 셀이 가능한 타일 중 하나를 무작위로 결정(collapse) 전파(Propagation) 결정과 전파 반복 설정한 타일로 가득 채워진 맵을 얻을 수 있으며 타일을 잘 설정할수록 상당히 구조적인 맵이 나온다. 나는 불확실성으로 가득찬게 좋아서 타일을 8개 맘대로 집어넣었더니 결과물이 깔끔해 보이진 않는다. 개념을 확실히 정립하기 전에는 방 전체가 뚫린다던가 죄다 벽이라던가 구현이 어려웠다. 그래도 전파되며 만들어지는 모습이 아름답다. // 2x2 타일 사전 정의 const tiles = [ { name: "wall", // 전체 벽 data: [[1, 1], [1, 1]], edges: { up: 1, right: 1, down: 1, left: 1 } }, { name: "floor", // 전체 통로 data: [[0, 0], [0, 0]], edges: { up: 0, right: 0, down: 0, left: 0 } }, { name: "hall_h", // 수평 복도 data: [[1, 1], [0, 0]], edges: { up: 1, right: 0, down: 1, left: 0 } }, { name: "hall_v", // 수직 복도 data: [[1, 0], [1, 0]], edges: { up: 0, right: 1, down: 0, left: 1 } }, { name: "room_corner_top_left", // 위/왼쪽이 열린 방 구석 data: [[0, 0], [0, 1]], edges: { up: 0, right: 0, down: 1, left: 0 } }, { name: "room_corner_bottom_right", // 아래/오른쪽 열린 방 구석 data: [[1, 0], [0, 0]], edges: { up: 1, right: 0, down: 0, left: 0 } }, { name: "junction_T_up", // T자 모양 (위쪽 갈래) data: [[0, 0], [1, 0]], edges: { up: 0, right: 0, down: 1, left: 1 } }, { name: "dead_end_left", // 왼쪽에만 열린 막다른길 data: [[1, 1], [0, 1]], edges: { up: 1, right: 1, down: 1, left: 0 } } ]; // 붙으려는 상대방 타일의 방향을 찾기 위한 반대 방향 매핑 const opposite = { up: "down", down: "up", left: "right", right: "left" }; // 타일 간 인접성 판단 function compatible(tileA, tileB, direction) { return tileA.edges[direction] === tileB.edges[opposite[direction]]; } // 셀 클래스 (1칸마다 타일 1개) class WFC_TileCell { constructor(x, y) { this.x = x; this.y = y; this.options = tiles.slice(); // 가능한 타일들 this.collapsed = false; } collapse() { const pick = this.options[Math.floor(Math.random() * this.options.length)]; this.options = [pick]; this.collapsed = true; return pick; } getTile() { return this.options[0]; } } async function startWFC() { initMap(); const tileSize = 2; // 2x2 타일 const tileCols = Math.floor(cols / tileSize); const tileRows = Math.floor(rows / tileSize); const grid = Array.from({ length: tileRows }, (_, y) =&gt; Array.from({ length: tileCols }, (_, x) =&gt; new WFC_TileCell(x, y)) ); // collapse 루프 let pending = grid.flat().filter(cell =&gt; !cell.collapsed); while (pending.length &gt; 0) { // 아직 collapse되지 않은 셀 중에서 가능한 옵션이 가장 적은 값 찾기 let minEntropy = pending.reduce((min, cell) =&gt; Math.min(min, cell.options.length), Infinity); // 가능한 옵션 수가 최소인 셀들만 필터링 let choices = pending.filter(c =&gt; c.options.length === minEntropy); // 그 중 하나를 랜덤 선택 let cell = choices[Math.floor(Math.random() * choices.length)]; const tile = cell.collapse(); // 타일을 실제 맵에 그리기 for (let dy = 0; dy &lt; tileSize; dy++) { for (let dx = 0; dx &lt; tileSize; dx++) { const mx = cell.x * tileSize + dx; const my = cell.y * tileSize + dy; if (mx &lt; cols &amp;&amp; my &lt; rows) { map[my][mx] = tile.data[dy][dx]; drawCell(mx, my, tile.data[dy][dx] === 1 ? 'black' : 'white'); } } await sleep(5); // 주변 셀 옵션 줄이기 for (const [dir, [dx, dy]] of Object.entries({ up: [0, -1], right: [1, 0], down: [0, 1], left: [-1, 0] })) { const nx = cell.x + dx; const ny = cell.y + dy; if (nx &lt; 0 || ny &lt; 0 || nx &gt;= tileCols || ny &gt;= tileRows) continue; const neighbor = grid[ny][nx]; if (neighbor.collapsed) continue; // 현재 셀과 호환되는 타일만 남김 neighbor.options = neighbor.options.filter(opt =&gt; compatible(tile, opt, dir) ); } pending = grid.flat().filter(c =&gt; !c.collapsed); } } await generateEntrance(); } 완성 Delaunay Triangulation + MST WFC 반성 동굴 지형같은 구불구불 무작위보다 구조적인 지형을 구성하는게 무엇보다 더 어려운 느낌이다. 우연하게 태어난 아름다움과 철저히 설계된 아름다움의 차이로 느껴진다. 아 감성적인 하루 코드 확인 직접 해보기 Delaunay Triangulation + MST Link to GitHub WFC Link to GitHub]]></summary></entry><entry><title type="html">7106번 Wonderful Fours</title><link href="https://movingwoo.com/random-solve/python/2025/05/27/7106.html" rel="alternate" type="text/html" title="7106번 Wonderful Fours" /><published>2025-05-27T07:00:00+00:00</published><updated>2025-05-27T07:00:00+00:00</updated><id>https://movingwoo.com/random-solve/python/2025/05/27/7106</id><content type="html" xml:base="https://movingwoo.com/random-solve/python/2025/05/27/7106.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Python/2025-05-27-7106/img01.jpg" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/7106">7106번 Wonderful Fours - 백준</a></p>

<blockquote>
  <h4 id="번역">번역</h4>
  <hr />
</blockquote>

<p>브론즈 문제 하나, 텍스트 제출 문제 하나 거르고 나온 실버 문제.<br />
내 그지같은 파이썬 실력에 알맞은 난이도다.<br />
찬찬히 해석해보면…</p>

<p>십진수 숫자 5개를 K5라 부른다.<br />
모두 사용하되 0으로 시작하지 않는 숫자를 만들면 그 숫자는 <span style="color: orange;"><strong>‘적절히’</strong></span> 만들어진 것이다.<br />
그리고 아래 내용이 모두 참일 경우 <span style="color: orange;"><strong>완다풀 포</strong></span>가 된다.</p>
<ul>
  <li>4개의 5자리 자연수가 모두 적절하게 만들어짐</li>
  <li>4개의 5자리 자연수는 모두 다른 숫자</li>
  <li>s1 + s2 + s3 = s4</li>
</ul>

<p>여기서 주어진 K5로 몇 개의 서로 다른 완다풀 포를 만들 수 있는지 계산하시오.</p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>뭐 방법이 있나?<br />
숫자 크기도 작고 그냥 세개 뽑아서 합해서 찾아보면 되겠다.<br />
중복 제거에만 신경쓰면 될 듯</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<p>중복 제거를 고민해봤는데<br />
처음부터 ‘적절한’ 숫자를 만들며 중복되는걸 날려버리면 끝이다.</p>

<h5 id="1-입력받아-적절한-숫자-만들기">1. 입력받아 ‘적절한’ 숫자 만들기</h5>

<p>더 똑똑하게 할 수 있지만<br />
겨우 숫자 다섯개로 하는거니 5중 나생문을 쌓았다.<br />
중복 거르고 정렬.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">K5</span> <span class="o">=</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">()</span>

<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># 적절한 숫자 생성(중복제외)
</span><span class="n">all_num</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>

<span class="c1"># 몇개 안되고 귀찮으니 5중반복문
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">i</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="n">i</span> <span class="ow">or</span> <span class="n">l</span> <span class="o">==</span> <span class="n">j</span> <span class="ow">or</span> <span class="n">l</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">i</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">==</span> <span class="n">j</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">==</span> <span class="n">k</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">==</span> <span class="n">l</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">num_str</span> <span class="o">=</span> <span class="n">K5</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">K5</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">K5</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">K5</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">+</span> <span class="n">K5</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">num_str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sh">'</span><span class="s">0</span><span class="sh">'</span><span class="p">:</span>
                        <span class="n">all_num</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">num_str</span><span class="p">))</span>

<span class="n">all_num</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">all_num</span><span class="p">)</span>
<span class="n">all_num</span><span class="p">.</span><span class="nf">sort</span><span class="p">()</span>
</code></pre></div></div>

<h5 id="2-완다풀-포-구하기">2. 완다풀 포 구하기</h5>

<p>미리 중복 거르고 정렬해놔서 중복체크는 할 필요 없고<br />
리스트의 최대값보다 합이 커지면 더 탐색할 필요없이 break 한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">all_num</span><span class="p">)</span>
<span class="nb">max</span> <span class="o">=</span> <span class="n">all_num</span><span class="p">[</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># list 순회하며 s1 + s2 + s3 = s4 조건 확인
</span><span class="k">if</span> <span class="n">length</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
                <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">s3</span> <span class="o">=</span> <span class="n">all_num</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">all_num</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">all_num</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">s4</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span> <span class="o">+</span> <span class="n">s3</span>

                <span class="k">if</span> <span class="n">s4</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">:</span>
                    <span class="c1"># 최대 숫자보다 크면 탈출
</span>                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">s4</span> <span class="ow">in</span> <span class="n">all_num</span><span class="p">:</span>
                    <span class="n">r</span><span class="o">+=</span><span class="mi">1</span>

<span class="nf">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Python/2025-05-27-7106/img02.jpg" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>머리아파서 뇌비우고 하다가 그래도 더 잘할 수 있지 않나? 하는 마음에 탈출코드 추가해서 시간을 줄였다.<br />
이제 5중 나생문을 해체하려고 보는 순간 다시 머리가 아파서 관뒀다.<br />
휴식이 필요한 하루다…</p>

<p>얼마나 머리아프냐면 생각없이 파이썬 코드를 C++코드로 제출해서 컴파일 오류남</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/random-solve/Python/2025-05-27-7106.py">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="random-solve/Python/" /><summary type="html"><![CDATA[문제 7106번 Wonderful Fours - 백준 번역 브론즈 문제 하나, 텍스트 제출 문제 하나 거르고 나온 실버 문제. 내 그지같은 파이썬 실력에 알맞은 난이도다. 찬찬히 해석해보면… 십진수 숫자 5개를 K5라 부른다. 모두 사용하되 0으로 시작하지 않는 숫자를 만들면 그 숫자는 ‘적절히’ 만들어진 것이다. 그리고 아래 내용이 모두 참일 경우 완다풀 포가 된다. 4개의 5자리 자연수가 모두 적절하게 만들어짐 4개의 5자리 자연수는 모두 다른 숫자 s1 + s2 + s3 = s4 여기서 주어진 K5로 몇 개의 서로 다른 완다풀 포를 만들 수 있는지 계산하시오. 설계 뭐 방법이 있나? 숫자 크기도 작고 그냥 세개 뽑아서 합해서 찾아보면 되겠다. 중복 제거에만 신경쓰면 될 듯 구현 중복 제거를 고민해봤는데 처음부터 ‘적절한’ 숫자를 만들며 중복되는걸 날려버리면 끝이다. 1. 입력받아 ‘적절한’ 숫자 만들기 더 똑똑하게 할 수 있지만 겨우 숫자 다섯개로 하는거니 5중 나생문을 쌓았다. 중복 거르고 정렬. K5 = input().split() r = 0 # 적절한 숫자 생성(중복제외) all_num = set() # 몇개 안되고 귀찮으니 5중반복문 for i in range(5): for j in range(5): if j == i: continue for k in range(5): if k == i or k == j: continue for l in range(5): if l == i or l == j or l == k: continue for m in range(5): if m == i or m == j or m == k or m == l: continue num_str = K5[i] + K5[j] + K5[k] + K5[l] + K5[m] if num_str[0] != '0': all_num.add(int(num_str)) all_num = list(all_num) all_num.sort() 2. 완다풀 포 구하기 미리 중복 거르고 정렬해놔서 중복체크는 할 필요 없고 리스트의 최대값보다 합이 커지면 더 탐색할 필요없이 break 한다. length = len(all_num) max = all_num[length-1] # list 순회하며 s1 + s2 + s3 = s4 조건 확인 if length &gt;= 4: for i in range(length): for j in range(i + 1, length): for k in range(j + 1, length): s1, s2, s3 = all_num[i], all_num[j], all_num[k] s4 = s1 + s2 + s3 if s4 &gt; max: # 최대 숫자보다 크면 탈출 break if s4 in all_num: r+=1 print(r) 채점 반성 머리아파서 뇌비우고 하다가 그래도 더 잘할 수 있지 않나? 하는 마음에 탈출코드 추가해서 시간을 줄였다. 이제 5중 나생문을 해체하려고 보는 순간 다시 머리가 아파서 관뒀다. 휴식이 필요한 하루다… 얼마나 머리아프냐면 생각없이 파이썬 코드를 C++코드로 제출해서 컴파일 오류남 코드 확인 Link to GitHub]]></summary></entry><entry><title type="html">던전 생성기 01</title><link href="https://movingwoo.com/one-pan/javascript/2025/05/27/Dungeon-Generator-01.html" rel="alternate" type="text/html" title="던전 생성기 01" /><published>2025-05-27T02:00:00+00:00</published><updated>2025-05-27T02:00:00+00:00</updated><id>https://movingwoo.com/one-pan/javascript/2025/05/27/Dungeon%20Generator%2001</id><content type="html" xml:base="https://movingwoo.com/one-pan/javascript/2025/05/27/Dungeon-Generator-01.html"><![CDATA[<blockquote>
  <h4 id="개요">개요</h4>
  <hr />
</blockquote>

<p>신나는 던전 맵 생성기<br />
5종 알고리즘과 함께</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-설계">1. 설계</h5>

<p>던전 맵 생성 관련 대표 알고리즘에 대해 찾아보았다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">알고리즘</th>
      <th style="text-align: left">스타일</th>
      <th style="text-align: left">특징</th>
      <th style="text-align: left">용도</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">BSP (Binary Space Partitioning)</td>
      <td style="text-align: left">직사각형 방 + 복도</td>
      <td style="text-align: left">공간을 재귀적으로 분할, 각 방을 연결</td>
      <td style="text-align: left">방 중심의 던전, 구조적 배치</td>
    </tr>
    <tr>
      <td style="text-align: left">Random Walk (Drunkard’s Walk)</td>
      <td style="text-align: left">유기적 경로, 비정형</td>
      <td style="text-align: left">무작위 방향 이동, 비선형 구조</td>
      <td style="text-align: left">자연 동굴, 탐험 중심 던전</td>
    </tr>
    <tr>
      <td style="text-align: left">Cellular Automata</td>
      <td style="text-align: left">자연 동굴 형태, 굴곡 많음</td>
      <td style="text-align: left">셀 규칙 반복으로 패턴 정제</td>
      <td style="text-align: left">동굴 스타일 던전, 유기적 형태</td>
    </tr>
    <tr>
      <td style="text-align: left">Delaunay Triangulation + MST</td>
      <td style="text-align: left">방 중심 + 경로 연결</td>
      <td style="text-align: left">무작위 방 &gt; 삼각분할 &gt; 최소 연결</td>
      <td style="text-align: left">모든 방 연결 보장, 전략적 맵</td>
    </tr>
    <tr>
      <td style="text-align: left">Wave Function Collapse (WFC)</td>
      <td style="text-align: left">타일 기반, 정교한 제약</td>
      <td style="text-align: left">타일 제약 기반 패턴 구성</td>
      <td style="text-align: left">정교한 던전, 룰 기반 구조</td>
    </tr>
  </tbody>
</table>

<p>맵을 그릴 캔버스가 있는 html은 이전 미로 생성기의 것을 그대로 가져와서 사용한다.</p>

<h5 id="2-bsp-알고리즘">2. BSP 알고리즘</h5>

<p>BSP 알고리즘을 공간을 재귀적으로 분할한다.<br />
분할 과정이 이진트리 형태로 표현되며 방 설정을 통해 크기와 개수를 쉽게 조절 가능하다.<br />
통로는 각 방의 중심을 직선 또는 L자로 적당히 연결한다.</p>

<p>방이 완전히 랜덤한 위치에 생성되기 때문에 방의 중심을 연결하는 통로의 특성 상<br />
<span style="color: orange;"><strong>통로가 겹치기도 하고 두껍게 이어지기도 한다.</strong></span></p>

<p>또 현재 입구 생성을 [0, 0]에서 가장 가까운 셀로 해두었는데<br />
랜덤하게 생성되어 이어지는 구조 특성 상 통로가 가장 가까운 경우 통로에 입구가 생길 수도 있다.<br />
강제로 가까운 셀을 껴서 생성시키기에는 BSP의 취지에 맞지 않은 것 같고<br />
방과 통로를 구분할 수 있게 방 데이터를 가져오려면 공통함수로 쓰기 애매하다.<br />
그냥 복도에 입구가 생기면 운이 나쁜걸로…</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 방 클래스 정의</span>
<span class="kd">class</span> <span class="nc">Room</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">h</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">w</span> <span class="o">=</span> <span class="nx">w</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">h</span> <span class="o">=</span> <span class="nx">h</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 방의 중심 좌표</span>
  <span class="nf">center</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span>
      <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">w</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
      <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">h</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">// 다른 방과 겹치는지 판정</span>
  <span class="nf">intersects</span><span class="p">(</span><span class="nx">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return </span><span class="p">(</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">other</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">other</span><span class="p">.</span><span class="nx">w</span> <span class="o">&amp;&amp;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">w</span> <span class="o">&gt;</span> <span class="nx">other</span><span class="p">.</span><span class="nx">x</span> <span class="o">&amp;&amp;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">other</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">other</span><span class="p">.</span><span class="nx">h</span> <span class="o">&amp;&amp;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">h</span> <span class="o">&gt;</span> <span class="nx">other</span><span class="p">.</span><span class="nx">y</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
  
<span class="k">async</span> <span class="kd">function</span> <span class="nf">startBSP</span><span class="p">()</span> <span class="p">{</span>

  <span class="kd">const</span> <span class="nx">MIN_SIZE</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// 방 최소 크기</span>
  <span class="kd">const</span> <span class="nx">MAX_SIZE</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="c1">// 방 최대 크기</span>
  <span class="kd">const</span> <span class="nx">partitions</span> <span class="o">=</span> <span class="p">[{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">w</span><span class="p">:</span> <span class="nx">cols</span><span class="p">,</span> <span class="na">h</span><span class="p">:</span> <span class="nx">rows</span> <span class="p">}];</span>
  <span class="kd">const</span> <span class="nx">rooms</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// 생성된 방 목록</span>

  <span class="c1">// 공간을 재귀적으로 분할</span>
  <span class="k">async</span> <span class="kd">function</span> <span class="nf">splitSpace</span><span class="p">(</span><span class="nx">space</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">h</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">space</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">horizontal</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">;</span> <span class="c1">// 분할 방향 랜덤(수평/수직)</span>

    <span class="c1">// 더 이상 분할이 불가능할 때(최소 크기 이하)</span>
    <span class="k">if </span><span class="p">((</span><span class="nx">horizontal</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">MIN_SIZE</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="nx">horizontal</span> <span class="o">&amp;&amp;</span> <span class="nx">w</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">MIN_SIZE</span><span class="p">))</span> <span class="p">{</span>
      <span class="c1">// 방 생성 시도 (겹쳐서 실패할 경우 10회까지 재시도)</span>
      <span class="kd">let</span> <span class="nx">tryCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="kd">let</span> <span class="nx">room</span><span class="p">;</span>
      <span class="kd">let</span> <span class="nx">overlapped</span><span class="p">;</span>
      <span class="k">do</span> <span class="p">{</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">w</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">MIN_SIZE</span> <span class="o">||</span> <span class="nx">h</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">MIN_SIZE</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="c1">// 공간이 너무 작으면 중단</span>

        <span class="c1">// 방 크기 랜덤 (MIN_SIZE~MAX_SIZE), 위치도 랜덤(테두리와 1칸 이상 띄움)</span>
        <span class="kd">const</span> <span class="nx">rw</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span>
          <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">w</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="nx">MIN_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="nx">MIN_SIZE</span><span class="p">,</span>
          <span class="nx">MAX_SIZE</span>
        <span class="p">);</span>
        <span class="kd">const</span> <span class="nx">rh</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span>
          <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">h</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="nx">MIN_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="nx">MIN_SIZE</span><span class="p">,</span>
          <span class="nx">MAX_SIZE</span>
        <span class="p">);</span>
        <span class="kd">const</span> <span class="nx">rx</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">w</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="nx">rw</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">ry</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">h</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="nx">rh</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nx">room</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Room</span><span class="p">(</span><span class="nx">rx</span><span class="p">,</span> <span class="nx">ry</span><span class="p">,</span> <span class="nx">rw</span><span class="p">,</span> <span class="nx">rh</span><span class="p">);</span>
        <span class="nx">overlapped</span> <span class="o">=</span> <span class="nx">rooms</span><span class="p">.</span><span class="nf">some</span><span class="p">(</span><span class="nx">r</span> <span class="o">=&gt;</span> <span class="nx">room</span><span class="p">.</span><span class="nf">intersects</span><span class="p">(</span><span class="nx">r</span><span class="p">));</span>
        <span class="nx">tryCount</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">while </span><span class="p">(</span><span class="nx">overlapped</span> <span class="o">&amp;&amp;</span> <span class="nx">tryCount</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">);</span>

      <span class="c1">// 겹치지 않는 방만 생성</span>
      <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">overlapped</span> <span class="o">&amp;&amp;</span> <span class="nx">room</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">rooms</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">room</span><span class="p">);</span>
        <span class="c1">// 방 내부를 흰색칠</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">room</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">room</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">room</span><span class="p">.</span><span class="nx">h</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">room</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">room</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">room</span><span class="p">.</span><span class="nx">w</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">map</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="nf">drawCell</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
            <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 분할: 수평 또는 수직으로 영역을 나눔</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">horizontal</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 수평 분할</span>
      <span class="kd">const</span> <span class="nx">split</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">h</span> <span class="o">-</span> <span class="nx">MIN_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nx">MIN_SIZE</span><span class="p">);</span>
      <span class="kd">const</span> <span class="nx">top</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="na">h</span><span class="p">:</span> <span class="nx">split</span> <span class="p">};</span>
      <span class="kd">const</span> <span class="nx">bottom</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">split</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="na">h</span><span class="p">:</span> <span class="nx">h</span> <span class="o">-</span> <span class="nx">split</span> <span class="p">};</span>
      <span class="k">await</span> <span class="nf">splitSpace</span><span class="p">(</span><span class="nx">top</span><span class="p">);</span>
      <span class="k">await</span> <span class="nf">splitSpace</span><span class="p">(</span><span class="nx">bottom</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// 수직 분할</span>
      <span class="kd">const</span> <span class="nx">split</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">w</span> <span class="o">-</span> <span class="nx">MIN_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nx">MIN_SIZE</span><span class="p">);</span>
      <span class="kd">const</span> <span class="nx">left</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="na">w</span><span class="p">:</span> <span class="nx">split</span><span class="p">,</span> <span class="nx">h</span> <span class="p">};</span>
      <span class="kd">const</span> <span class="nx">right</span> <span class="o">=</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">split</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="na">w</span><span class="p">:</span> <span class="nx">w</span> <span class="o">-</span> <span class="nx">split</span><span class="p">,</span> <span class="nx">h</span> <span class="p">};</span>
      <span class="k">await</span> <span class="nf">splitSpace</span><span class="p">(</span><span class="nx">left</span><span class="p">);</span>
      <span class="k">await</span> <span class="nf">splitSpace</span><span class="p">(</span><span class="nx">right</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 터널 뚫는 함수</span>
  <span class="k">async</span> <span class="kd">function</span> <span class="nf">tunneling</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">dx</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sign</span><span class="p">(</span><span class="nx">x2</span> <span class="o">-</span> <span class="nx">x1</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">dy</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sign</span><span class="p">(</span><span class="nx">y2</span> <span class="o">-</span> <span class="nx">y1</span><span class="p">);</span>
    <span class="c1">// x축 방향으로 먼저 이동</span>
    <span class="k">while </span><span class="p">(</span><span class="nx">x1</span> <span class="o">!==</span> <span class="nx">x2</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">map</span><span class="p">[</span><span class="nx">y1</span><span class="p">][</span><span class="nx">x1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
      <span class="nx">x1</span> <span class="o">+=</span> <span class="nx">dx</span><span class="p">;</span>
      <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// y축 방향으로 이동</span>
    <span class="k">while </span><span class="p">(</span><span class="nx">y1</span> <span class="o">!==</span> <span class="nx">y2</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">map</span><span class="p">[</span><span class="nx">y1</span><span class="p">][</span><span class="nx">x1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
      <span class="nx">y1</span> <span class="o">+=</span> <span class="nx">dy</span><span class="p">;</span>
      <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">await</span> <span class="nf">splitSpace</span><span class="p">(</span><span class="nx">partitions</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

  <span class="c1">// 생성된 방들의 중심을 순서대로 복도로 연결</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">rooms</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">rooms</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="nf">center</span><span class="p">();</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">rooms</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nf">center</span><span class="p">();</span>

    <span class="k">if </span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">await</span> <span class="nf">tunneling</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y1</span><span class="p">);</span>
      <span class="k">await</span> <span class="nf">tunneling</span><span class="p">(</span><span class="nx">x2</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">await</span> <span class="nf">tunneling</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x1</span><span class="p">,</span> <span class="nx">y2</span><span class="p">);</span>
      <span class="k">await</span> <span class="nf">tunneling</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y2</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 입출구 생성</span>
  <span class="nf">generateEntrance</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="3-random-walk-알고리즘">3. Random Walk 알고리즘</h5>

<p>굉장히 간단한 알고리즘이다.<br />
이름에서 볼 수 있듯 방향을 랜덤으로 움직이며 길을 채우고<br />
정해둔 만큼 맵을 채우면 종료한다.</p>

<p>통로나 방이 곡선형으로 잘 생성되는데 랜덤으로 여기저기 쑤시다보니<br />
통로가 너무 좁을 수 있고 전체적인 구조를 제어하기 힙들다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nf">startRandomWalk</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">initMap</span><span class="p">();</span>
  
  <span class="c1">// 시작점 (중앙)</span>
  <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nx">cols</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nx">rows</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
  
  <span class="c1">// 방문한 셀 수를 추적</span>
  <span class="kd">let</span> <span class="nx">visitedCells</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">targetCells</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">((</span><span class="nx">cols</span> <span class="o">*</span> <span class="nx">rows</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.4</span><span class="p">);</span> <span class="c1">// 전체 셀의 40% 채우면 종료</span>
  
  <span class="c1">// 4방향 이동 </span>
  <span class="kd">const</span> <span class="nx">directions</span> <span class="o">=</span> <span class="p">[</span>
      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
      <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
      <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
  <span class="p">];</span>
  
  <span class="c1">// 현재 위치를 통로로 만들고 방문 표시</span>
  <span class="nx">map</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">visitedCells</span><span class="o">++</span><span class="p">;</span>
  
  <span class="k">while </span><span class="p">(</span><span class="nx">visitedCells</span> <span class="o">&lt;</span> <span class="nx">targetCells</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 랜덤한 방향 선택</span>
      <span class="kd">const</span> <span class="p">[</span><span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">]</span> <span class="o">=</span> <span class="nx">directions</span><span class="p">[</span><span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)];</span>
      <span class="kd">const</span> <span class="nx">newX</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">;</span>
      <span class="kd">const</span> <span class="nx">newY</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">;</span>
      
      <span class="c1">// 경계 체크</span>
      <span class="k">if </span><span class="p">(</span><span class="nx">newX</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">newX</span> <span class="o">&lt;</span> <span class="nx">cols</span> <span class="o">&amp;&amp;</span> <span class="nx">newY</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">newY</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// 새로운 위치가 벽이면 통로로 만들기</span>
          <span class="k">if </span><span class="p">(</span><span class="nx">map</span><span class="p">[</span><span class="nx">newY</span><span class="p">][</span><span class="nx">newX</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">map</span><span class="p">[</span><span class="nx">newY</span><span class="p">][</span><span class="nx">newX</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
              <span class="nf">drawCell</span><span class="p">(</span><span class="nx">newX</span><span class="p">,</span> <span class="nx">newY</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
              <span class="nx">visitedCells</span><span class="o">++</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="nx">x</span> <span class="o">=</span> <span class="nx">newX</span><span class="p">;</span>
          <span class="nx">y</span> <span class="o">=</span> <span class="nx">newY</span><span class="p">;</span>
      <span class="p">}</span>
      
      <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="nf">generateEntrance</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="4-cellular-automata-알고리즘">4. Cellular Automata 알고리즘</h5>

<p><span style="color: orange;"><strong>셀의 상태를 바탕으로 다음 상태를 결정해 갱신</strong></span>하는 알고리즘이다.</p>

<p>규칙은 어떻게 정하느냐에 따라 다르겠지마는<br />
초기에 랜덤하게 벽을 뚫어두고 4번에 거쳐 다듬어나간다.<br />
규칙은 아래와 같이 정했다.</p>
<ul>
  <li>현재 셀이 벽인데 주변 벽이 4개 이상이면 벽 유지, 그렇지 않으면 통로로 변경</li>
  <li>현재 셀이 통로인데 주변 벽이 5개 이상이변 벽으로 변경, 그렇지 않으면 통로 유지</li>
</ul>

<p>위 과정을 거쳐 자연스러운 동굴 형태의 맵이 완성된다.<br />
엄격한 규칙을 기반으로 다듬어나가기 때문에 뭔가 틀에 박힌 BSP와 자유롭게 칠렐레 팔렐레 뻗은 Random Walk보다 보기 좋다.</p>

<p>이 알고리즘도 고립된 공간이 생길 수 있는데 이는 추가적인 알고리즘을 통해 고립된 방과 통로로 연결하거나 제거하면 된다.<br />
하지만 이번 구현에서 그 부분은 패스.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nf">startCellularAutomata</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">initMap</span><span class="p">();</span>
  
  <span class="c1">// 초기 랜덤 상태 생성 (약 45%의 벽)</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// 테두리는 벽으로 설정</span>
          <span class="k">if </span><span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">x</span> <span class="o">===</span> <span class="nx">cols</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">===</span> <span class="nx">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">map</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
              <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span><span class="p">);</span>
          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
              <span class="nx">map</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.45</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
              <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">map</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
  
  <span class="c1">// Cellular Automata 규칙 적용 (4회 반복)</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">generation</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">generation</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="nx">generation</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">newMap</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">({</span> <span class="na">length</span><span class="p">:</span> <span class="nx">rows</span> <span class="p">},</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nc">Array</span><span class="p">(</span><span class="nx">cols</span><span class="p">).</span><span class="nf">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
      
      <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// 테두리는 벽 유지</span>
              <span class="k">if </span><span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">x</span> <span class="o">===</span> <span class="nx">cols</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">===</span> <span class="nx">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">newMap</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                  <span class="k">continue</span><span class="p">;</span>
              <span class="p">}</span>
              
              <span class="c1">// 주변 8칸의 벽 개수 세기</span>
              <span class="kd">let</span> <span class="nx">wallCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
              <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">dy</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">dy</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">dy</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">dx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">dx</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">dx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">if </span><span class="p">(</span><span class="nx">dx</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">dy</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
                      <span class="k">if </span><span class="p">(</span><span class="nx">map</span><span class="p">[</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">][</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="nx">wallCount</span><span class="o">++</span><span class="p">;</span>
                  <span class="p">}</span>
              <span class="p">}</span>
              
              <span class="c1">//현재 셀이 벽인데 주변 벽이 4개 이상이면 벽 유지, 그렇지 않으면 통로로 변경</span>
              <span class="c1">//현재 셀이 통로인데 주변 벽이 5개 이상이변 벽으로 변경, 그렇지 않으면 통로 유지</span>
              <span class="k">if </span><span class="p">(</span><span class="nx">map</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">newMap</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nx">wallCount</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
              <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                  <span class="nx">newMap</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nx">wallCount</span> <span class="o">&gt;=</span> <span class="mi">5</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
              <span class="p">}</span>
              
              <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">newMap</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
              <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">}</span>
      
      <span class="nx">map</span> <span class="o">=</span> <span class="nx">newMap</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="nf">generateEntrance</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="완성">완성</h4>
  <hr />
</blockquote>

<p>BSP<br />
<img src="/assets/images/posts/one-pan/JavaScript/2025-05-27-Dungeon Generator 01/img01.gif" alt="img01" /></p>

<p>Random Walk<br />
<img src="/assets/images/posts/one-pan/JavaScript/2025-05-27-Dungeon Generator 01/img02.gif" alt="img02" /></p>

<p>Cellular Automata<br />
<img src="/assets/images/posts/one-pan/JavaScript/2025-05-27-Dungeon Generator 01/img03.gif" alt="img03" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>Random Walk 알고리즘과 Cellular Automata 알고리즘을 구현하며 즐거워졌다.<br />
오래된 피쳐폰게임의 작은 미니맵을 보는 기분이다.<br />
아 마음이 충만해진다…</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="/play/Dungeon%20Generator.html" target="_blank" rel="noopener noreferrer">
  직접 해보기
</a></p>

<p>BSP<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-27-BSP.js">Link to GitHub</a></p>

<p>Random Walk<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-27-RandomWalk.js">Link to GitHub</a></p>

<p>Cellular Automata<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-27-CellularAutomata.js">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="one-pan/JavaScript/" /><summary type="html"><![CDATA[개요 신나는 던전 맵 생성기 5종 알고리즘과 함께 구현 1. 설계 던전 맵 생성 관련 대표 알고리즘에 대해 찾아보았다. 알고리즘 스타일 특징 용도 BSP (Binary Space Partitioning) 직사각형 방 + 복도 공간을 재귀적으로 분할, 각 방을 연결 방 중심의 던전, 구조적 배치 Random Walk (Drunkard’s Walk) 유기적 경로, 비정형 무작위 방향 이동, 비선형 구조 자연 동굴, 탐험 중심 던전 Cellular Automata 자연 동굴 형태, 굴곡 많음 셀 규칙 반복으로 패턴 정제 동굴 스타일 던전, 유기적 형태 Delaunay Triangulation + MST 방 중심 + 경로 연결 무작위 방 &gt; 삼각분할 &gt; 최소 연결 모든 방 연결 보장, 전략적 맵 Wave Function Collapse (WFC) 타일 기반, 정교한 제약 타일 제약 기반 패턴 구성 정교한 던전, 룰 기반 구조 맵을 그릴 캔버스가 있는 html은 이전 미로 생성기의 것을 그대로 가져와서 사용한다. 2. BSP 알고리즘 BSP 알고리즘을 공간을 재귀적으로 분할한다. 분할 과정이 이진트리 형태로 표현되며 방 설정을 통해 크기와 개수를 쉽게 조절 가능하다. 통로는 각 방의 중심을 직선 또는 L자로 적당히 연결한다. 방이 완전히 랜덤한 위치에 생성되기 때문에 방의 중심을 연결하는 통로의 특성 상 통로가 겹치기도 하고 두껍게 이어지기도 한다. 또 현재 입구 생성을 [0, 0]에서 가장 가까운 셀로 해두었는데 랜덤하게 생성되어 이어지는 구조 특성 상 통로가 가장 가까운 경우 통로에 입구가 생길 수도 있다. 강제로 가까운 셀을 껴서 생성시키기에는 BSP의 취지에 맞지 않은 것 같고 방과 통로를 구분할 수 있게 방 데이터를 가져오려면 공통함수로 쓰기 애매하다. 그냥 복도에 입구가 생기면 운이 나쁜걸로… // 방 클래스 정의 class Room { constructor(x, y, w, h) { this.x = x; this.y = y; this.w = w; this.h = h; } // 방의 중심 좌표 center() { return [ Math.floor(this.x + this.w / 2), Math.floor(this.y + this.h / 2) ]; } // 다른 방과 겹치는지 판정 intersects(other) { return ( this.x &lt; other.x + other.w &amp;&amp; this.x + this.w &gt; other.x &amp;&amp; this.y &lt; other.y + other.h &amp;&amp; this.y + this.h &gt; other.y ); } } async function startBSP() { const MIN_SIZE = 4; // 방 최소 크기 const MAX_SIZE = 6; // 방 최대 크기 const partitions = [{ x: 0, y: 0, w: cols, h: rows }]; const rooms = []; // 생성된 방 목록 // 공간을 재귀적으로 분할 async function splitSpace(space) { const { x, y, w, h } = space; const horizontal = Math.random() &lt; 0.5; // 분할 방향 랜덤(수평/수직) // 더 이상 분할이 불가능할 때(최소 크기 이하) if ((horizontal &amp;&amp; h &lt;= 2 * MIN_SIZE) || (!horizontal &amp;&amp; w &lt;= 2 * MIN_SIZE)) { // 방 생성 시도 (겹쳐서 실패할 경우 10회까지 재시도) let tryCount = 0; let room; let overlapped; do { if (w - 2 &lt; MIN_SIZE || h - 2 &lt; MIN_SIZE) break; // 공간이 너무 작으면 중단 // 방 크기 랜덤 (MIN_SIZE~MAX_SIZE), 위치도 랜덤(테두리와 1칸 이상 띄움) const rw = Math.min( Math.floor(Math.random() * (w - 2 - MIN_SIZE + 1)) + MIN_SIZE, MAX_SIZE ); const rh = Math.min( Math.floor(Math.random() * (h - 2 - MIN_SIZE + 1)) + MIN_SIZE, MAX_SIZE ); const rx = Math.floor(Math.random() * (w - 2 - rw + 1)) + x + 1; const ry = Math.floor(Math.random() * (h - 2 - rh + 1)) + y + 1; room = new Room(rx, ry, rw, rh); overlapped = rooms.some(r =&gt; room.intersects(r)); tryCount++; } while (overlapped &amp;&amp; tryCount &lt; 10); // 겹치지 않는 방만 생성 if (!overlapped &amp;&amp; room) { rooms.push(room); // 방 내부를 흰색칠 for (let i = room.y; i &lt; room.y + room.h; i++) { for (let j = room.x; j &lt; room.x + room.w; j++) { map[i][j] = 0; drawCell(j, i, 'white'); await sleep(1); } } } return; } // 분할: 수평 또는 수직으로 영역을 나눔 if (horizontal) { // 수평 분할 const split = Math.floor(Math.random() * (h - MIN_SIZE * 2) + MIN_SIZE); const top = { x, y, w, h: split }; const bottom = { x, y: y + split, w, h: h - split }; await splitSpace(top); await splitSpace(bottom); } else { // 수직 분할 const split = Math.floor(Math.random() * (w - MIN_SIZE * 2) + MIN_SIZE); const left = { x, y, w: split, h }; const right = { x: x + split, y, w: w - split, h }; await splitSpace(left); await splitSpace(right); } } // 터널 뚫는 함수 async function tunneling(x1, y1, x2, y2) { const dx = Math.sign(x2 - x1); const dy = Math.sign(y2 - y1); // x축 방향으로 먼저 이동 while (x1 !== x2) { map[y1][x1] = 0; drawCell(x1, y1, 'white'); x1 += dx; await sleep(1); } // y축 방향으로 이동 while (y1 !== y2) { map[y1][x1] = 0; drawCell(x1, y1, 'white'); y1 += dy; await sleep(1); } } await splitSpace(partitions[0]); // 생성된 방들의 중심을 순서대로 복도로 연결 for (let i = 1; i &lt; rooms.length; i++) { const [x1, y1] = rooms[i - 1].center(); const [x2, y2] = rooms[i].center(); if (Math.random() &lt; 0.5) { await tunneling(x1, y1, x2, y1); await tunneling(x2, y1, x2, y2); } else { await tunneling(x1, y1, x1, y2); await tunneling(x1, y2, x2, y2); } } // 입출구 생성 generateEntrance(); } 3. Random Walk 알고리즘 굉장히 간단한 알고리즘이다. 이름에서 볼 수 있듯 방향을 랜덤으로 움직이며 길을 채우고 정해둔 만큼 맵을 채우면 종료한다. 통로나 방이 곡선형으로 잘 생성되는데 랜덤으로 여기저기 쑤시다보니 통로가 너무 좁을 수 있고 전체적인 구조를 제어하기 힙들다. async function startRandomWalk() { initMap(); // 시작점 (중앙) let x = Math.floor(cols / 2); let y = Math.floor(rows / 2); // 방문한 셀 수를 추적 let visitedCells = 0; const targetCells = Math.floor((cols * rows) * 0.4); // 전체 셀의 40% 채우면 종료 // 4방향 이동 const directions = [ [0, -1], [1, 0], [0, 1], [-1, 0] ]; // 현재 위치를 통로로 만들고 방문 표시 map[y][x] = 0; drawCell(x, y, 'white'); visitedCells++; while (visitedCells &lt; targetCells) { // 랜덤한 방향 선택 const [dx, dy] = directions[Math.floor(Math.random() * 4)]; const newX = x + dx; const newY = y + dy; // 경계 체크 if (newX &gt;= 0 &amp;&amp; newX &lt; cols &amp;&amp; newY &gt;= 0 &amp;&amp; newY &lt; rows) { // 새로운 위치가 벽이면 통로로 만들기 if (map[newY][newX] === 1) { map[newY][newX] = 0; drawCell(newX, newY, 'white'); visitedCells++; } x = newX; y = newY; } await sleep(1); } generateEntrance(); } 4. Cellular Automata 알고리즘 셀의 상태를 바탕으로 다음 상태를 결정해 갱신하는 알고리즘이다. 규칙은 어떻게 정하느냐에 따라 다르겠지마는 초기에 랜덤하게 벽을 뚫어두고 4번에 거쳐 다듬어나간다. 규칙은 아래와 같이 정했다. 현재 셀이 벽인데 주변 벽이 4개 이상이면 벽 유지, 그렇지 않으면 통로로 변경 현재 셀이 통로인데 주변 벽이 5개 이상이변 벽으로 변경, 그렇지 않으면 통로 유지 위 과정을 거쳐 자연스러운 동굴 형태의 맵이 완성된다. 엄격한 규칙을 기반으로 다듬어나가기 때문에 뭔가 틀에 박힌 BSP와 자유롭게 칠렐레 팔렐레 뻗은 Random Walk보다 보기 좋다. 이 알고리즘도 고립된 공간이 생길 수 있는데 이는 추가적인 알고리즘을 통해 고립된 방과 통로로 연결하거나 제거하면 된다. 하지만 이번 구현에서 그 부분은 패스. async function startCellularAutomata() { initMap(); // 초기 랜덤 상태 생성 (약 45%의 벽) for (let y = 0; y &lt; rows; y++) { for (let x = 0; x &lt; cols; x++) { // 테두리는 벽으로 설정 if (x === 0 || x === cols - 1 || y === 0 || y === rows - 1) { map[y][x] = 1; drawCell(x, y, 'black'); } else { map[y][x] = Math.random() &lt; 0.45 ? 1 : 0; drawCell(x, y, map[y][x] === 1 ? 'black' : 'white'); } await sleep(1); } } // Cellular Automata 규칙 적용 (4회 반복) for (let generation = 0; generation &lt; 4; generation++) { const newMap = Array.from({ length: rows }, () =&gt; Array(cols).fill(0)); for (let y = 0; y &lt; rows; y++) { for (let x = 0; x &lt; cols; x++) { // 테두리는 벽 유지 if (x === 0 || x === cols - 1 || y === 0 || y === rows - 1) { newMap[y][x] = 1; continue; } // 주변 8칸의 벽 개수 세기 let wallCount = 0; for (let dy = -1; dy &lt;= 1; dy++) { for (let dx = -1; dx &lt;= 1; dx++) { if (dx === 0 &amp;&amp; dy === 0) continue; if (map[y + dy][x + dx] === 1) wallCount++; } } //현재 셀이 벽인데 주변 벽이 4개 이상이면 벽 유지, 그렇지 않으면 통로로 변경 //현재 셀이 통로인데 주변 벽이 5개 이상이변 벽으로 변경, 그렇지 않으면 통로 유지 if (map[y][x] === 1) { newMap[y][x] = wallCount &gt;= 4 ? 1 : 0; } else { newMap[y][x] = wallCount &gt;= 5 ? 1 : 0; } drawCell(x, y, newMap[y][x] === 1 ? 'black' : 'white'); await sleep(1); } } map = newMap; } generateEntrance(); } 완성 BSP Random Walk Cellular Automata 반성 Random Walk 알고리즘과 Cellular Automata 알고리즘을 구현하며 즐거워졌다. 오래된 피쳐폰게임의 작은 미니맵을 보는 기분이다. 아 마음이 충만해진다… 코드 확인 직접 해보기 BSP Link to GitHub Random Walk Link to GitHub Cellular Automata Link to GitHub]]></summary></entry><entry><title type="html">5101번 Sequences</title><link href="https://movingwoo.com/random-solve/python/2025/05/23/5101.html" rel="alternate" type="text/html" title="5101번 Sequences" /><published>2025-05-23T07:00:00+00:00</published><updated>2025-05-23T07:00:00+00:00</updated><id>https://movingwoo.com/random-solve/python/2025/05/23/5101</id><content type="html" xml:base="https://movingwoo.com/random-solve/python/2025/05/23/5101.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Python/2025-05-23-5101/img01.jpg" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/5101">5101번 Sequences - 백준</a></p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>음 쉬운 문제<br />
하루의 마무리로 딱이다.</p>

<p>시작 숫자와 차이가 주어지고 다음 숫자가 수열의 항인지 판단하는 문제이다.</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<p>단순 덧셈 반복해도 문제없지만 조금 더 스마트하게 해봐야지.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">());</span>

    <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">break</span>

    <span class="c1"># b가 0이면 예외처리
</span>    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">c</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">X</span><span class="sh">"</span><span class="p">)</span>
    <span class="c1"># 음수 고려
</span>    <span class="nf">elif </span><span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">%</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">//</span> <span class="n">b</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">((</span><span class="n">c</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">//</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">X</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Python/2025-05-23-5101/img02.jpg" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>아무래도 랜덤 돌려서 브론즈 문제 나오면 좀 거르는게 좋겠다.<br />
이것도 일종의 탄소 과잉배출로 볼 수 있지 않나?</p>

<p>앞으로 랜덤백준디펜스의 브론즈 문제가 걸리면 다 거르는 것으로 해야겠다.<br />
이건 뭐 깃에 코드 올리기도 뭐하고</p>]]></content><author><name>movingwoo</name></author><category term="random-solve/Python/" /><summary type="html"><![CDATA[문제 5101번 Sequences - 백준 설계 음 쉬운 문제 하루의 마무리로 딱이다. 시작 숫자와 차이가 주어지고 다음 숫자가 수열의 항인지 판단하는 문제이다. 구현 단순 덧셈 반복해도 문제없지만 조금 더 스마트하게 해봐야지. while True: a, b, c = map(int, input().split()); if a == 0 and b == 0 and c == 0: break # b가 0이면 예외처리 if b == 0: if a == c: print(1) else: print("X") # 음수 고려 elif (c - a) % b == 0 and (c - a) // b &gt;= 0: print((c - a) // b + 1) else: print("X") 채점 반성 아무래도 랜덤 돌려서 브론즈 문제 나오면 좀 거르는게 좋겠다. 이것도 일종의 탄소 과잉배출로 볼 수 있지 않나? 앞으로 랜덤백준디펜스의 브론즈 문제가 걸리면 다 거르는 것으로 해야겠다. 이건 뭐 깃에 코드 올리기도 뭐하고]]></summary></entry><entry><title type="html">27391번 Platform Placing</title><link href="https://movingwoo.com/random-solve/java/2025/05/23/27391.html" rel="alternate" type="text/html" title="27391번 Platform Placing" /><published>2025-05-23T06:00:00+00:00</published><updated>2025-05-23T06:00:00+00:00</updated><id>https://movingwoo.com/random-solve/java/2025/05/23/27391</id><content type="html" xml:base="https://movingwoo.com/random-solve/java/2025/05/23/27391.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Java/2025-05-23-27391/img01.jpg" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/27391">27391번 Platform Placing - 백준</a></p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>한글 문제 언제 나오나?</p>

<p>플랫폼을 설치하는데 x-l/2, x+l/2 크기를 차지한다.<br />
양쪽으로 펼쳐진다는 뜻.<br />
최소값과 최대값이 정해져 있고 플랫폼 사이의 공간이 있어도 되고 딱 붙어도 되지만 겹치는건 안된다.<br />
모든 고정지점마다 플랫폼 하나 설치가 가능하다.<br />
이때 플랫폼 길이의 총합이 최대가 되도록 하시오.</p>

<p>대충 그리디 알고리즘 ㄱㄱ</p>

<p>당연히 각 위치마다 최대 길이를 설치하는 것이 좋을 것이다.<br />
고정 지점들을 정렬해 순차적으로 길이를 할당하되<br />
이전 플랫폼과 겹치지 않는 한에서 가장 큰 값을 선택해 할당한다.</p>

<p>해결 불가능 시 -1 출력인데 두 지점 간격이 s보다 작을 경우 불가능 처리하면 되겠다.</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-입력-받기">1. 입력 받기</h5>

<p>제한시간은 항상 두려우니 버퍼로 입력받고<br />
플랫폼 배열은 오름차순 정렬, 길이 배열은 최대값으로 채워둔다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    	
    	<span class="k">try</span><span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
	        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
	        
	        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">(),</span> <span class="s">" "</span><span class="o">);</span>
	        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
	        <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
	        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
	        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	        
	        <span class="kt">int</span><span class="o">[]</span> <span class="n">platforms</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
	        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
	        	<span class="n">platforms</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
	        <span class="o">}</span>
	        <span class="c1">// 오름차순</span>
	        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">platforms</span><span class="o">);</span>
	        
	        <span class="kt">int</span><span class="o">[]</span> <span class="n">lengths</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
	        <span class="c1">// 최대길이로 일단 채우고 시작</span>
	        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">lengths</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
	        
	    <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
	        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
	    <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<h5 id="2-플랫폼-배열-탐색">2. 플랫폼 배열 탐색</h5>

<p>플랫폼은 양쪽으로 펼쳐지므로 최대 길이는 2를 곱해서 봐야한다.<br />
배치 불가능하면 -1을 즉시 출력하고<br />
가능하면 현재길이를 우선적으로 조정, 현재길이를 최대로 줄여도 안되면 이전 플랫폼 길이를 줄인다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">platforms</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">platforms</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
    <span class="c1">// 플랫폼이 양쪽으로 펼쳐짐</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dist</span><span class="o">;</span>

    <span class="c1">// 불가능한 경우</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">max</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"-1"</span><span class="o">);</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 이전 길이와 현재 길이의 합이 max를 넘지 않도록 조정</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">lengths</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">lengths</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">lengths</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">lengths</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">max</span> <span class="o">-</span> <span class="n">lengths</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]));</span>

        <span class="c1">// 여전히 안 되면 lengths[i]를 최대한 줄여서 해결 안되면 length[i-1] 조절을 해야함</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">lengths</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">lengths</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">lengths</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">max</span> <span class="o">-</span> <span class="n">lengths</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">length</span> <span class="o">:</span> <span class="n">lengths</span><span class="o">)</span> <span class="n">result</span> <span class="o">+=</span> <span class="n">length</span><span class="o">;</span>
<span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">result</span><span class="o">));</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Java/2025-05-23-27391/img02.jpg" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>기분좋게 잘 해결되었다.<br />
C++ 하다가 Java 하니 잘쳐지는 것도 있고 그리디 알고리즘도 재밌고</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/random-solve/Java/2025-05-23-27391.java">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="random-solve/Java/" /><summary type="html"><![CDATA[문제 27391번 Platform Placing - 백준 설계 한글 문제 언제 나오나? 플랫폼을 설치하는데 x-l/2, x+l/2 크기를 차지한다. 양쪽으로 펼쳐진다는 뜻. 최소값과 최대값이 정해져 있고 플랫폼 사이의 공간이 있어도 되고 딱 붙어도 되지만 겹치는건 안된다. 모든 고정지점마다 플랫폼 하나 설치가 가능하다. 이때 플랫폼 길이의 총합이 최대가 되도록 하시오. 대충 그리디 알고리즘 ㄱㄱ 당연히 각 위치마다 최대 길이를 설치하는 것이 좋을 것이다. 고정 지점들을 정렬해 순차적으로 길이를 할당하되 이전 플랫폼과 겹치지 않는 한에서 가장 큰 값을 선택해 할당한다. 해결 불가능 시 -1 출력인데 두 지점 간격이 s보다 작을 경우 불가능 처리하면 되겠다. 구현 1. 입력 받기 제한시간은 항상 두려우니 버퍼로 입력받고 플랫폼 배열은 오름차순 정렬, 길이 배열은 최대값으로 채워둔다. public static void main(String[] args) { try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out))) { StringTokenizer st = new StringTokenizer(br.readLine(), " "); int n = Integer.parseInt(st.nextToken()); int s = Integer.parseInt(st.nextToken()); int k = Integer.parseInt(st.nextToken()); int result = 0; int[] platforms = new int[n]; for(int i = 0 ; i &lt; n ; i++) { platforms[i] = Integer.parseInt(br.readLine()); } // 오름차순 Arrays.sort(platforms); int[] lengths = new int[n]; // 최대길이로 일단 채우고 시작 Arrays.fill(lengths, k); }catch(IOException e) { e.printStackTrace(); } } 2. 플랫폼 배열 탐색 플랫폼은 양쪽으로 펼쳐지므로 최대 길이는 2를 곱해서 봐야한다. 배치 불가능하면 -1을 즉시 출력하고 가능하면 현재길이를 우선적으로 조정, 현재길이를 최대로 줄여도 안되면 이전 플랫폼 길이를 줄인다. for (int i = 1 ; i &lt; n ; i++) { int dist = platforms[i] - platforms[i - 1]; // 플랫폼이 양쪽으로 펼쳐짐 int max = 2 * dist; // 불가능한 경우 if (max &lt; 2 * s) { bw.write("-1"); return; } // 이전 길이와 현재 길이의 합이 max를 넘지 않도록 조정 if (lengths[i - 1] + lengths[i] &gt; max) { lengths[i] = Math.max(s, Math.min(lengths[i], max - lengths[i - 1])); // 여전히 안 되면 lengths[i]를 최대한 줄여서 해결 안되면 length[i-1] 조절을 해야함 if (lengths[i - 1] + lengths[i] &gt; max) { lengths[i - 1] = Math.max(s, max - lengths[i]); } } } for (int length : lengths) result += length; bw.write(String.valueOf(result)); 채점 반성 기분좋게 잘 해결되었다. C++ 하다가 Java 하니 잘쳐지는 것도 있고 그리디 알고리즘도 재밌고 코드 확인 Link to GitHub]]></summary></entry><entry><title type="html">25245번 Amusement Arcade</title><link href="https://movingwoo.com/random-solve/c++/2025/05/23/25245.html" rel="alternate" type="text/html" title="25245번 Amusement Arcade" /><published>2025-05-23T05:00:00+00:00</published><updated>2025-05-23T05:00:00+00:00</updated><id>https://movingwoo.com/random-solve/c++/2025/05/23/25245</id><content type="html" xml:base="https://movingwoo.com/random-solve/c++/2025/05/23/25245.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/C++/2025-05-23-25245/img01.jpg" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/25245">25245번 Amusement Arcade - 백준</a></p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>n개의 오락기가 있다.(n은 홀수)<br />
사람이 앉아야하는데 반드시 오락기에 한 칸씩 비우고 앉아야한다.<br />
도착하는 사람은 사람이 있는 곳에서 가장 멀리 떨어진 자리를 고르며, 여러개라면 무작위로 선택한다.</p>

<p>이때 줄리아가 가장 먼저 앉을 적절한 위치를 고르시오.</p>

<p>n은 반드시 홀수고 한 칸씩 비우면 최대 인원은 (n + 1) / 2 이다.<br />
줄리아가 대충 n / 2 + 1 위치인 중앙에 앉으면 impossible이 나올 조건은 없어보이는데…<br />
예제에서는 15를 넣을 시 impossible이 나온다.</p>

<p><span style="color: orange;"><strong>사람에서 최대한 멀리 떨어진 곳에 앉으려는 좋지 않은 습성</strong></span> 때문인데…<br />
실제 15를 받아 줄리아를 8번에 앉힐 경우<br />
[1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1]
이 상황에서 정확히 한 칸 조건이 깨져버린다!</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-시뮬레이션">1. 시뮬레이션</h5>

<p>제한시간이 빡빡해서 단순 시뮬레이션은 아닌 것 같다.<br />
일단 대충 코드짜서 순열 규칙 확인 ㄱㄱ</p>

<p>줄리아의 자리는 모든 홀수 자리를 탐색해서 앉혀본다.<br />
단순히 n / 2 + 1 에만 앉을 경우 7을 넣으면 4에 앉아야 하는데 그러면 오답이 나온다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">simulate</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">where</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">;</span> <span class="n">k</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">seats</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
        <span class="c1">// 줄리아가 앉을 자리</span>
        <span class="n">seats</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">people</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">people</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 현재 가능한 자리들 중 가장 큰 최소 거리</span>
            <span class="kt">int</span> <span class="n">max_dist</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">candidates</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">seats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="kt">int</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>

                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">seats</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                        <span class="c1">// 가장 가까운 사람과의 거리</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">abs</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">));</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="c1">// 현재 자리가 이전보다 더 멀리 떨어져 있다면 새로운 후보, 같으면 추가</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&gt;</span> <span class="n">max_dist</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">max_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">;</span>
                    <span class="n">candidates</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
                    <span class="n">candidates</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">==</span> <span class="n">max_dist</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">candidates</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="c1">// 후보자리가 없으면 끝</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">candidates</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">candidates</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// 홀수 자리에 앉지 못하면 의미 없음</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
                    <span class="n">seats</span><span class="p">[</span><span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            
            <span class="n">people</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 최종 상태가 x . x . x ... 패턴인지 확인</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">seats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">seats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">where</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">where</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">31</span> <span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" : "</span> <span class="o">&lt;&lt;</span> <span class="n">simulate</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>시뮬레이션 결과는 아래와 같다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">n</th>
      <th style="text-align: center">줄리아</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">7</td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center">9</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">11</td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center">13</td>
      <td style="text-align: center">5</td>
    </tr>
    <tr>
      <td style="text-align: center">15</td>
      <td style="text-align: center">impossible</td>
    </tr>
    <tr>
      <td style="text-align: center">17</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">19</td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center">21</td>
      <td style="text-align: center">5</td>
    </tr>
    <tr>
      <td style="text-align: center">23</td>
      <td style="text-align: center">impossible</td>
    </tr>
    <tr>
      <td style="text-align: center">25</td>
      <td style="text-align: center">9</td>
    </tr>
    <tr>
      <td style="text-align: center">27</td>
      <td style="text-align: center">impossible</td>
    </tr>
    <tr>
      <td style="text-align: center">29</td>
      <td style="text-align: center">impossible</td>
    </tr>
    <tr>
      <td style="text-align: center">31</td>
      <td style="text-align: center">impossible</td>
    </tr>
  </tbody>
</table>

<p>예제는 다 맞는다.</p>

<h5 id="2-규칙-찾기">2. 규칙 찾기</h5>

<p>가설 1: <span style="color: orange;"><strong>n = 2^k + 1 (k &gt; 0)</strong></span> 인 경우 답은 반드시 1이다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">n</th>
      <th style="text-align: center">줄리아</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">9</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">17</td>
      <td style="text-align: center">1</td>
    </tr>
  </tbody>
</table>

<p>가설 2: <span style="color: orange;"><strong>n != 2^a + 2^b + 1</strong></span> 인 경우 배치가 불가능하다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">n</th>
      <th style="text-align: center">줄리아</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">15</td>
      <td style="text-align: center">impossible</td>
    </tr>
    <tr>
      <td style="text-align: center">23</td>
      <td style="text-align: center">impossible</td>
    </tr>
    <tr>
      <td style="text-align: center">27</td>
      <td style="text-align: center">impossible</td>
    </tr>
    <tr>
      <td style="text-align: center">29</td>
      <td style="text-align: center">impossible</td>
    </tr>
    <tr>
      <td style="text-align: center">31</td>
      <td style="text-align: center">impossible</td>
    </tr>
  </tbody>
</table>

<p>이부분은 <span style="color: orange;"><strong>n + 1의 이진수 1의 개수가 3 이상이면 불가능</strong></span>으로 처리할 수 있다.</p>

<p>가설 3: 그 외의 경우는 시뮬레이션을 하되, 2^k + 1 인 자리만 대상으로 한다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">n</th>
      <th style="text-align: center">줄리아</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">7</td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center">11</td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center">13</td>
      <td style="text-align: center">5</td>
    </tr>
    <tr>
      <td style="text-align: center">19</td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center">21</td>
      <td style="text-align: center">5</td>
    </tr>
    <tr>
      <td style="text-align: center">25</td>
      <td style="text-align: center">9</td>
    </tr>
  </tbody>
</table>

<h5 id="2-구현">2. 구현</h5>

<p>가설 1, 2를 넘었을 경우 시뮬레이션을 해야하는데<br />
n이 10^18까지 있으므로 평범하게 하면 바로 시간초과다.<br />
어차피 꽉 채워 앉으면 완전 이진트리 구조가 되므로 줄리아 배치 기준 양쪽을 반으로 계속 나눌 수 있는지만 확인하면 된다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 가설 1: n == 2^k + 1 이면 반드시 줄리아는 1번 자리에 앉으면 됨</span>
<span class="kt">bool</span> <span class="nf">hypothesis_1</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 가설 2: n == 2^a + 2^b + 1 형태인지 확인</span>
<span class="c1">// n - 1 == 2^a + 2^b 라면 가능성 있음</span>
<span class="kt">bool</span> <span class="nf">hypothesis_2</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int64_t</span> <span class="n">x</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// 균등분할이 가능할지</span>
<span class="kt">bool</span> <span class="nf">can_seat</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">can_seat</span><span class="p">((</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int64_t</span> <span class="nf">solve</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 짝수일 경우 패스</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 가설 1</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hypothesis_1</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 가설 2</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hypothesis_2</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 가설 3</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">64</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="kt">int64_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1LL</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">can_seat</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">can_seat</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/C++/2025-05-23-25245/img02.jpg" alt="img02" /></p>

<p>허허 정답비율 나 혼자 다깎아먹었넹</p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>반복문 조건도 잘 못잡고 균등분할 조건도 잘 못잡고<br />
제대로 했으면 덜 틀렸을걸 실컷 틀렸다.<br />
아주 고봉밥이다 어우 배불러</p>

<p>근데 분명 더 멋진 풀이가 있을거란 말이지<br />
맞힌 사람 보면 코드 길이가 심상치가 않다.</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/random-solve/C%2B%2B/2025-05-23-25245.cpp">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="random-solve/C++/" /><summary type="html"><![CDATA[문제 25245번 Amusement Arcade - 백준 설계 n개의 오락기가 있다.(n은 홀수) 사람이 앉아야하는데 반드시 오락기에 한 칸씩 비우고 앉아야한다. 도착하는 사람은 사람이 있는 곳에서 가장 멀리 떨어진 자리를 고르며, 여러개라면 무작위로 선택한다. 이때 줄리아가 가장 먼저 앉을 적절한 위치를 고르시오. n은 반드시 홀수고 한 칸씩 비우면 최대 인원은 (n + 1) / 2 이다. 줄리아가 대충 n / 2 + 1 위치인 중앙에 앉으면 impossible이 나올 조건은 없어보이는데… 예제에서는 15를 넣을 시 impossible이 나온다. 사람에서 최대한 멀리 떨어진 곳에 앉으려는 좋지 않은 습성 때문인데… 실제 15를 받아 줄리아를 8번에 앉힐 경우 [1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1] 이 상황에서 정확히 한 칸 조건이 깨져버린다! 구현 1. 시뮬레이션 제한시간이 빡빡해서 단순 시뮬레이션은 아닌 것 같다. 일단 대충 코드짜서 순열 규칙 확인 ㄱㄱ 줄리아의 자리는 모든 홀수 자리를 탐색해서 앉혀본다. 단순히 n / 2 + 1 에만 앉을 경우 7을 넣으면 4에 앉아야 하는데 그러면 오답이 나온다. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;limits&gt; using namespace std; int simulate(int n) { int max = (n + 1) / 2; int where = -1; for (int k = 0 ; k &lt; n ; k+=2) { bool result = true; vector&lt;int&gt; seats(n, 0); // 줄리아가 앉을 자리 seats[k] = 1; int people = 1; while (people &lt; max) { // 현재 가능한 자리들 중 가장 큰 최소 거리 int max_dist = -1; vector&lt;int&gt; candidates; for (int i = 0 ; i &lt; n ; i++) { if (seats[i] == 1) { continue; } int dist = numeric_limits&lt;int&gt;::max(); for (int j = 0 ; j &lt; n ; j++) { if (seats[j] == 1) { // 가장 가까운 사람과의 거리 dist = min(dist, abs(i - j)); } } // 현재 자리가 이전보다 더 멀리 떨어져 있다면 새로운 후보, 같으면 추가 if (dist &gt; max_dist) { max_dist = dist; candidates.clear(); candidates.push_back(i); } else if (dist == max_dist) { candidates.push_back(i); } } // 후보자리가 없으면 끝 if (candidates.empty()) { break; } for (int i = 0 ; i &lt; candidates.size() ; i++) { if (candidates[i] % 2 != 0) { // 홀수 자리에 앉지 못하면 의미 없음 continue; }else { seats[candidates[i]] = 1; break; } } people++; } // 최종 상태가 x . x . x ... 패턴인지 확인 for (int i = 0 ; i &lt; n ; i++) { if (i % 2 == 0) { if (seats[i] != 1) { result = false; break; } } else { if (seats[i] != 0) { result = false; break; } } } if (result) { where = k + 1; break; } } return where; } int main() { bool result = false; for (int i = 1 ; i &lt;= 31 ; i+=2) { cout &lt;&lt; i &lt;&lt; " : " &lt;&lt; simulate(i) &lt;&lt; endl; } return 0; } 시뮬레이션 결과는 아래와 같다. n 줄리아 1 1 3 1 5 1 7 3 9 1 11 3 13 5 15 impossible 17 1 19 3 21 5 23 impossible 25 9 27 impossible 29 impossible 31 impossible 예제는 다 맞는다. 2. 규칙 찾기 가설 1: n = 2^k + 1 (k &gt; 0) 인 경우 답은 반드시 1이다. n 줄리아 3 1 5 1 9 1 17 1 가설 2: n != 2^a + 2^b + 1 인 경우 배치가 불가능하다. n 줄리아 15 impossible 23 impossible 27 impossible 29 impossible 31 impossible 이부분은 n + 1의 이진수 1의 개수가 3 이상이면 불가능으로 처리할 수 있다. 가설 3: 그 외의 경우는 시뮬레이션을 하되, 2^k + 1 인 자리만 대상으로 한다. n 줄리아 7 3 11 3 13 5 19 3 21 5 25 9 2. 구현 가설 1, 2를 넘었을 경우 시뮬레이션을 해야하는데 n이 10^18까지 있으므로 평범하게 하면 바로 시간초과다. 어차피 꽉 채워 앉으면 완전 이진트리 구조가 되므로 줄리아 배치 기준 양쪽을 반으로 계속 나눌 수 있는지만 확인하면 된다. // 가설 1: n == 2^k + 1 이면 반드시 줄리아는 1번 자리에 앉으면 됨 bool hypothesis_1(int64_t n) { return (n &gt; 1) &amp;&amp; ((n - 1) &amp; (n - 2)) == 0; } // 가설 2: n == 2^a + 2^b + 1 형태인지 확인 // n - 1 == 2^a + 2^b 라면 가능성 있음 bool hypothesis_2(int64_t n) { int64_t x = n - 1; int count = 0; while (x &gt; 0) { if (x &amp; 1) count++; if (count &gt; 2) return false; x &gt;&gt;= 1; } return count == 2; } // 균등분할이 가능할지 bool can_seat(int64_t len) { if (len &lt; 2) return true; if (len % 2 == 0) return false; return can_seat((len - 1) / 2); } int64_t solve(int64_t n) { // 짝수일 경우 패스 if (n % 2 == 0) { return -1; } // 가설 1 if (hypothesis_1(n)) { return 1; } // 가설 2 if (!hypothesis_2(n)) { return -1; } // 가설 3 for (int i = 0 ; i &lt; 64 ; i++){ int64_t pos = (1LL &lt;&lt; i) + 1; if (pos &gt; n) { break; } if (can_seat(pos - 2) &amp;&amp; can_seat(n - pos - 1)) { return pos; } } return -1; } 채점 허허 정답비율 나 혼자 다깎아먹었넹 반성 반복문 조건도 잘 못잡고 균등분할 조건도 잘 못잡고 제대로 했으면 덜 틀렸을걸 실컷 틀렸다. 아주 고봉밥이다 어우 배불러 근데 분명 더 멋진 풀이가 있을거란 말이지 맞힌 사람 보면 코드 길이가 심상치가 않다. 코드 확인 Link to GitHub]]></summary></entry><entry><title type="html">미로 생성기 03</title><link href="https://movingwoo.com/one-pan/javascript/2025/05/23/Maze-Generator-03.html" rel="alternate" type="text/html" title="미로 생성기 03" /><published>2025-05-23T01:00:00+00:00</published><updated>2025-05-23T01:00:00+00:00</updated><id>https://movingwoo.com/one-pan/javascript/2025/05/23/Maze%20Generator%2003</id><content type="html" xml:base="https://movingwoo.com/one-pan/javascript/2025/05/23/Maze-Generator-03.html"><![CDATA[<blockquote>
  <h4 id="개요">개요</h4>
  <hr />
</blockquote>

<p>남은 알고리즘 미로 추가하여 미로 생성기 완성하기.</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<p>시작 전에 길찾고 그리는 부분이 중복되기 때문에 공통 함수로 옮겨줬다.</p>

<h5 id="1-binary-tree-알고리즘과-sidewinder-알고리즘">1. Binary Tree 알고리즘과 Sidewinder 알고리즘</h5>

<p>두 알고리즘의 미로 생성 과정이나 결과물은 상당히 유사해보인다.<br />
셀에서 방향을 무작위로 선택해 벽을 제거하고 나아가는 방식이다.</p>

<p>차이점을 정리해보면</p>
<ul>
  <li>Binary Tree
    <ul>
      <li>각 셀마다 독립적으로 결정을 내림</li>
      <li>대각선 방향의 경향</li>
    </ul>
  </li>
  <li>Sidewinder
    <ul>
      <li>연속된 동쪽 경로인 run이라는 개념을 활용, 동쪽으로 진행</li>
      <li>현재 run에서 무작위 셀을 남쪽으로 연결하며 run 종료</li>
      <li>이전 셀들의 선택이 다음 셀 선택에 영향을 줌</li>
      <li>수평 방향의 경향</li>
    </ul>
  </li>
</ul>

<p>실제 입구 출구를 이어보면 이는 더 명확하게 드러난다.<br />
전통적인 Sidewinder 알고리즘 사용시 동쪽과 북쪽을 선택하는데<br />
시작 좌표를 [0, 0] 으로 잡기 때문에 동쪽과 남쪽으로 진행하게 방향을 잡았다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Binary Tree 알고리즘</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">generateBinaryTree</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 모든 셀을 벽으로 초기화</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 각 셀에 대해</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 현재 셀을 통로로 만들기</span>
            <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>

            <span class="c1">// 동쪽과 남쪽 중 하나를 무작위로 선택</span>
            <span class="kd">const</span> <span class="nx">canGoEast</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span>
            <span class="kd">const</span> <span class="nx">canGoSouth</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span>

            <span class="k">if </span><span class="p">(</span><span class="nx">canGoEast</span> <span class="o">&amp;&amp;</span> <span class="nx">canGoSouth</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 둘 다 가능하면 무작위로 선택</span>
                <span class="k">if </span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// 동쪽으로</span>
                    <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="c1">// 남쪽으로</span>
                    <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">canGoEast</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 동쪽만 가능</span>
                <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">canGoSouth</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 남쪽만 가능</span>
                <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Sidewinder 알고리즘</span>
<span class="c1">// 전통적인 Sidewinder 알고리즘은 북쪽으로 길을 파는데 입구가 0,0이라 남쪽으로 파는 것으로 변경</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">generateSidewinder</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 모든 셀을 벽으로 초기화</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 각 행을 처리</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">run</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// 현재 실행 중인 경로 (연속된 동쪽 경로)</span>

        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 현재 셀을 통로로 만들기</span>
            <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
            <span class="nx">run</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">]);</span> <span class="c1">// 현재 셀을 run에 추가</span>

            <span class="c1">// 동쪽으로 갈 수 있는지 확인</span>
            <span class="kd">const</span> <span class="nx">canGoEast</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span>
            <span class="c1">// 남쪽으로 갈 수 있는지 확인</span>
            <span class="kd">const</span> <span class="nx">canGoSouth</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span>

            <span class="c1">// 동쪽으로 계속 진행할지, 남쪽으로 연결할지 결정</span>
            <span class="c1">// 1. 동쪽으로 갈 수 없거나</span>
            <span class="c1">// 2. 남쪽으로 갈 수 있고 50% 확률로 run을 종료</span>
            <span class="kd">const</span> <span class="nx">shouldCloseOut</span> <span class="o">=</span> <span class="o">!</span><span class="nx">canGoEast</span> <span class="o">||</span> <span class="p">(</span><span class="nx">canGoSouth</span> <span class="o">&amp;&amp;</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">);</span>

            <span class="k">if </span><span class="p">(</span><span class="nx">shouldCloseOut</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 현재 run에서 무작위로 선택된 셀을 남쪽과 연결</span>
                <span class="kd">const</span> <span class="p">[</span><span class="nx">rx</span><span class="p">,</span> <span class="nx">ry</span><span class="p">]</span> <span class="o">=</span> <span class="nx">run</span><span class="p">[</span><span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">run</span><span class="p">.</span><span class="nx">length</span><span class="p">)];</span>
                <span class="k">if </span><span class="p">(</span><span class="nx">canGoSouth</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">maze</span><span class="p">[</span><span class="nx">ry</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="nx">rx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">rx</span><span class="p">,</span> <span class="nx">ry</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="nx">run</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// run 초기화</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// 동쪽으로 계속 진행 (run 확장)</span>
                <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="2-recursive-division-알고리즘">2. Recursive Division 알고리즘</h5>

<p>Resursive Division 알고리즘으로 생성된 미로를 보면 다른 미로들과 비교해 상당히 이질적이다.<br />
마치 던전 맵 같은 방 구조로 되어있으며 <span style="color: orange;"><strong>접근할 수 없는 갇힌 방</strong></span>도 만들어진다.</p>

<p>공간을 분할하며 한 줄짜리 벽을 만들고 벽에 단 하나의 통로만 뚫는다.<br />
이 과정이 반복되며 어떤 영역은 한 통로만 생기고 나머지는 벽으로 막혀버릴 수 있다.</p>

<p>모든 칸이 연결된 완전 미로를 만들기 위해 코드를 약간 수정했다.<br />
벽을 만들 때 이미 통로가 있는지 확인하고 막히게 된다면 추가로 통로를 더 뚫어주는 로직을 넣어주었다.<br />
그래도 막힌 방이 생성됨… 좀 벽을 더 뚫어줘야할 것 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Recursive Division 알고리즘</span>
<span class="c1">// 완전 미로를 만들기 위한 커스텀</span>
<span class="c1">// 분할선 크기 조정 시 방 크기 조정</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">generateRecursiveDivision</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">,</span> <span class="nx">orientation</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 방이 너무 작으면 중단</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">x2</span> <span class="o">-</span> <span class="nx">x1</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">||</span> <span class="nx">y2</span> <span class="o">-</span> <span class="nx">y1</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 수평</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">orientation</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">horizontal</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 분할선 후보(짝수)</span>
        <span class="kd">const</span> <span class="nx">possibleYs</span> <span class="o">=</span> <span class="p">[];</span>
        
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">y1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">y2</span><span class="p">;</span> <span class="nx">y</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">possibleYs</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if </span><span class="p">(</span><span class="nx">possibleYs</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 분할선 후보가 없으면 중단</span>
            <span class="k">return</span><span class="p">;</span> 
        <span class="p">}</span>
        <span class="kd">const</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">possibleYs</span><span class="p">[</span><span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">possibleYs</span><span class="p">.</span><span class="nx">length</span><span class="p">)];</span>

        <span class="c1">// 통로 후보(홀수)</span>
        <span class="kd">const</span> <span class="nx">possiblePassages</span> <span class="o">=</span> <span class="p">[];</span>
        
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">x1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">x2</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">possiblePassages</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="k">if </span><span class="p">(</span><span class="nx">possiblePassages</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 통로 후보가 없으면 중단</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 반드시 하나는 통로로 만들고, 추가로 통로를 더 만들 확률도 부여</span>
        <span class="kd">const</span> <span class="nx">passageCount</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">possiblePassages</span><span class="p">.</span><span class="nx">length</span> <span class="o">/</span> <span class="mi">3</span><span class="p">));</span>
        <span class="kd">const</span> <span class="nx">passages</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="kd">const</span> <span class="nx">passageCandidates</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">possiblePassages</span><span class="p">];</span>
        <span class="k">while </span><span class="p">(</span><span class="nx">passages</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="nx">passageCount</span> <span class="o">&amp;&amp;</span> <span class="nx">passageCandidates</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">idx</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">passageCandidates</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
            <span class="kd">const</span> <span class="nx">px</span> <span class="o">=</span> <span class="nx">passageCandidates</span><span class="p">.</span><span class="nf">splice</span><span class="p">(</span><span class="nx">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
            <span class="nx">passages</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">px</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// 벽 생성 (통로 제외)</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">x1</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;=</span> <span class="nx">x2</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">passages</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span> <span class="p">{</span>
                <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

        <span class="c1">// 위/아래 영역 재귀 호출</span>
        <span class="k">await</span> <span class="nf">generateRecursiveDivision</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">vertical</span><span class="dl">'</span><span class="p">);</span>
        <span class="k">await</span> <span class="nf">generateRecursiveDivision</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">,</span> <span class="dl">'</span><span class="s1">vertical</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// 수직</span>
        <span class="c1">// 분할선 후보(짝수)</span>
        <span class="kd">const</span> <span class="nx">possibleXs</span> <span class="o">=</span> <span class="p">[];</span>
        
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">x1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">x2</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">possibleXs</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if </span><span class="p">(</span><span class="nx">possibleXs</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 분할선 후보가 없으면 중단</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">possibleXs</span><span class="p">[</span><span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">possibleXs</span><span class="p">.</span><span class="nx">length</span><span class="p">)];</span>

        <span class="c1">// 통로 후보(홀수)</span>
        <span class="kd">const</span> <span class="nx">possiblePassages</span> <span class="o">=</span> <span class="p">[];</span>

        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">y1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">y2</span><span class="p">;</span> <span class="nx">y</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">possiblePassages</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if </span><span class="p">(</span><span class="nx">possiblePassages</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 통로 후보가 없으면 중단</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 반드시 하나는 통로로 만들고, 추가로 통로를 더 만들 확률도 부여</span>
        <span class="kd">const</span> <span class="nx">passageCount</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">possiblePassages</span><span class="p">.</span><span class="nx">length</span> <span class="o">/</span> <span class="mi">3</span><span class="p">));</span>
        <span class="kd">const</span> <span class="nx">passages</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="kd">const</span> <span class="nx">passageCandidates</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">possiblePassages</span><span class="p">];</span>
        <span class="k">while </span><span class="p">(</span><span class="nx">passages</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="nx">passageCount</span> <span class="o">&amp;&amp;</span> <span class="nx">passageCandidates</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">idx</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">passageCandidates</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
            <span class="kd">const</span> <span class="nx">py</span> <span class="o">=</span> <span class="nx">passageCandidates</span><span class="p">.</span><span class="nf">splice</span><span class="p">(</span><span class="nx">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
            <span class="nx">passages</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">py</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// 벽 생성 (통로 제외)</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">y1</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;=</span> <span class="nx">y2</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">passages</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="nx">y</span><span class="p">))</span> <span class="p">{</span>
                <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

        <span class="c1">// 좌/우 영역 재귀 호출</span>
        <span class="k">await</span> <span class="nf">generateRecursiveDivision</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y2</span><span class="p">,</span> <span class="dl">'</span><span class="s1">horizontal</span><span class="dl">'</span><span class="p">);</span>
        <span class="k">await</span> <span class="nf">generateRecursiveDivision</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">,</span> <span class="dl">'</span><span class="s1">horizontal</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="3-ellers-알고리즘">3. Eller’s 알고리즘</h5>

<p>Eller’s 알고리즘은 각 행마다 집합을 관리하며 벽을 뚫을 때 집합을 병합하거나 새로 부여한다.<br />
한 줄씩 처리하며 집합 연산과 벽 뚫기만 하고 복잡한 경로 탐색이 없어서 <span style="color: orange;"><strong>메모리 접근이 효율적이고 엄청나게 빠르다.</strong></span></p>

<p>실제로 시뮬레이션 돌리면 혼자서 미로를 호다닥 생성해버린다.</p>

<p>엄청나게 빠른게 장점이라면 단점으로는 무작위성이 떨어지며 수평으로 편향되어 있다는 점 정도? 
좀 숭숭 뚫려있는 느낌도 받는다.<br />
수직으로 한 칸 짜리 벽 생성을 지양해야하는데 수평으로 한 줄씩 처리하기 때문에 수직 처리하기 곤란하다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Eller's Algorithm 미로 생성</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">generateEller</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 모든 셀을 벽으로 초기화</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 각 셀의 집합 번호를 저장할 배열</span>
    <span class="kd">let</span> <span class="nx">sets</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">let</span> <span class="nx">nextSet</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// 첫 번째 행 초기화</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">sets</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nextSet</span><span class="o">++</span><span class="p">;</span>
        <span class="nx">maze</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 각 행을 처리</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 1. 오른쪽으로 벽을 뚫을지 결정</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 같은 집합이 아니고, 랜덤하게 벽을 뚫기로 결정하면</span>
            <span class="k">if </span><span class="p">(</span><span class="nx">sets</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">!==</span> <span class="nx">sets</span><span class="p">[</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 벽 뚫기</span>
                <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
                <span class="c1">// 집합 병합</span>
                <span class="kd">const</span> <span class="nx">oldSet</span> <span class="o">=</span> <span class="nx">sets</span><span class="p">[</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
                <span class="kd">const</span> <span class="nx">newSet</span> <span class="o">=</span> <span class="nx">sets</span><span class="p">[</span><span class="nx">x</span><span class="p">];</span>
                <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">if </span><span class="p">(</span><span class="nx">sets</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="nx">oldSet</span><span class="p">)</span> <span class="nx">sets</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">newSet</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 마지막 행이 아니면 아래로 벽을 뚫기</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 각 집합별로 아래로 연결할 셀을 최소 1개 이상 선택</span>
            <span class="kd">const</span> <span class="nx">setCells</span> <span class="o">=</span> <span class="p">{};</span>
            <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">setCells</span><span class="p">[</span><span class="nx">sets</span><span class="p">[</span><span class="nx">x</span><span class="p">]])</span> <span class="nx">setCells</span><span class="p">[</span><span class="nx">sets</span><span class="p">[</span><span class="nx">x</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[];</span>
                <span class="nx">setCells</span><span class="p">[</span><span class="nx">sets</span><span class="p">[</span><span class="nx">x</span><span class="p">]].</span><span class="nf">push</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="c1">// 아래로 연결</span>
            <span class="kd">let</span> <span class="nx">newSets</span> <span class="o">=</span> <span class="p">[];</span>
            <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="kd">set</span> <span class="k">in</span> <span class="nx">setCells</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 반드시 하나는 아래로 연결</span>
                <span class="kd">const</span> <span class="nx">cells</span> <span class="o">=</span> <span class="nx">setCells</span><span class="p">[</span><span class="kd">set</span><span class="p">];</span>
                <span class="kd">const</span> <span class="nx">shuffled</span> <span class="o">=</span> <span class="nx">cells</span><span class="p">.</span><span class="nf">slice</span><span class="p">().</span><span class="nf">sort</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">);</span>
                <span class="kd">const</span> <span class="nx">downCount</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">cells</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
                <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">downCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">shuffled</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
                    <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
                    <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
                    <span class="nx">newSets</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nextSet</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="c1">// 나머지 셀은 새로운 집합 번호 부여</span>
            <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">newSets</span><span class="p">[</span><span class="nx">x</span><span class="p">])</span> <span class="p">{</span>
                    <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
                    <span class="nx">newSets</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nextSet</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nx">sets</span> <span class="o">=</span> <span class="nx">newSets</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="완성">완성</h4>
  <hr />
</blockquote>

<p>Binary Tree 알고리즘 미로</p>

<p><img src="/assets/images/posts/one-pan/JavaScript/2025-05-23-Maze Generator 03/img01.gif" alt="img01" /></p>

<p>Sidewinder 알고리즘 미로</p>

<p><img src="/assets/images/posts/one-pan/JavaScript/2025-05-23-Maze Generator 03/img02.gif" alt="img02" /></p>

<p>Recursive Division 알고리즘 미로</p>

<p><img src="/assets/images/posts/one-pan/JavaScript/2025-05-23-Maze Generator 03/img03.gif" alt="img03" /></p>

<p>Eller’s 알고리즘 미로</p>

<p><img src="/assets/images/posts/one-pan/JavaScript/2025-05-23-Maze Generator 03/img04.gif" alt="img04" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>7종 알고리즘 미로를 완성했다.<br />
그 외 몇가지 알고리즘이 더 있긴한데, 대표적으로 이 7종이면 더 맛 볼 필요는 없다고 한다.</p>

<p>그리고 미로 알고리즘 짜다가 알게 되었는데 던전 맵 만드는 알고리즘과 미로 알고리즘은 또 다르다고 한다…<br />
정리 되면 던전 맵 시뮬레이터도 만들어봐야겠다.</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="/play/Maze%20Generator.html" target="_blank" rel="noopener noreferrer">
  직접 해보기
</a></p>

<p>Binary Tree<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-23-BinaryTree.js">Link to GitHub</a></p>

<p>Sidewinder<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-23-Sidewinder.js">Link to GitHub</a></p>

<p>Recursive Division<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-23-RecursiveDivision.js">Link to GitHub</a></p>

<p>Eller’s<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-23-Eller.js">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="one-pan/JavaScript/" /><summary type="html"><![CDATA[개요 남은 알고리즘 미로 추가하여 미로 생성기 완성하기. 구현 시작 전에 길찾고 그리는 부분이 중복되기 때문에 공통 함수로 옮겨줬다. 1. Binary Tree 알고리즘과 Sidewinder 알고리즘 두 알고리즘의 미로 생성 과정이나 결과물은 상당히 유사해보인다. 셀에서 방향을 무작위로 선택해 벽을 제거하고 나아가는 방식이다. 차이점을 정리해보면 Binary Tree 각 셀마다 독립적으로 결정을 내림 대각선 방향의 경향 Sidewinder 연속된 동쪽 경로인 run이라는 개념을 활용, 동쪽으로 진행 현재 run에서 무작위 셀을 남쪽으로 연결하며 run 종료 이전 셀들의 선택이 다음 셀 선택에 영향을 줌 수평 방향의 경향 실제 입구 출구를 이어보면 이는 더 명확하게 드러난다. 전통적인 Sidewinder 알고리즘 사용시 동쪽과 북쪽을 선택하는데 시작 좌표를 [0, 0] 으로 잡기 때문에 동쪽과 남쪽으로 진행하게 방향을 잡았다. // Binary Tree 알고리즘 async function generateBinaryTree() { // 모든 셀을 벽으로 초기화 for (let y = 0; y &lt; rows; y++) { for (let x = 0; x &lt; cols; x++) { maze[y][x] = 1; drawCell(x, y, 'black'); } } // 각 셀에 대해 for (let y = 0; y &lt; rows; y += 2) { for (let x = 0; x &lt; cols; x += 2) { // 현재 셀을 통로로 만들기 maze[y][x] = 0; drawCell(x, y, 'white'); // 동쪽과 남쪽 중 하나를 무작위로 선택 const canGoEast = x + 2 &lt; cols; const canGoSouth = y + 2 &lt; rows; if (canGoEast &amp;&amp; canGoSouth) { // 둘 다 가능하면 무작위로 선택 if (Math.random() &lt; 0.5) { // 동쪽으로 maze[y][x + 1] = 0; drawCell(x + 1, y, 'white'); } else { // 남쪽으로 maze[y + 1][x] = 0; drawCell(x, y + 1, 'white'); } } else if (canGoEast) { // 동쪽만 가능 maze[y][x + 1] = 0; drawCell(x + 1, y, 'white'); } else if (canGoSouth) { // 남쪽만 가능 maze[y + 1][x] = 0; drawCell(x, y + 1, 'white'); } await sleep(5); } } } // Sidewinder 알고리즘 // 전통적인 Sidewinder 알고리즘은 북쪽으로 길을 파는데 입구가 0,0이라 남쪽으로 파는 것으로 변경 async function generateSidewinder() { // 모든 셀을 벽으로 초기화 for (let y = 0; y &lt; rows; y++) { for (let x = 0; x &lt; cols; x++) { maze[y][x] = 1; drawCell(x, y, 'black'); } } // 각 행을 처리 for (let y = 0; y &lt; rows; y += 2) { let run = []; // 현재 실행 중인 경로 (연속된 동쪽 경로) for (let x = 0; x &lt; cols; x += 2) { // 현재 셀을 통로로 만들기 maze[y][x] = 0; drawCell(x, y, 'white'); run.push([x, y]); // 현재 셀을 run에 추가 // 동쪽으로 갈 수 있는지 확인 const canGoEast = x + 2 &lt; cols; // 남쪽으로 갈 수 있는지 확인 const canGoSouth = y + 2 &lt; rows; // 동쪽으로 계속 진행할지, 남쪽으로 연결할지 결정 // 1. 동쪽으로 갈 수 없거나 // 2. 남쪽으로 갈 수 있고 50% 확률로 run을 종료 const shouldCloseOut = !canGoEast || (canGoSouth &amp;&amp; Math.random() &lt; 0.5); if (shouldCloseOut) { // 현재 run에서 무작위로 선택된 셀을 남쪽과 연결 const [rx, ry] = run[Math.floor(Math.random() * run.length)]; if (canGoSouth) { maze[ry + 1][rx] = 0; drawCell(rx, ry + 1, 'white'); } run = []; // run 초기화 } else { // 동쪽으로 계속 진행 (run 확장) maze[y][x + 1] = 0; drawCell(x + 1, y, 'white'); } await sleep(5); } } } 2. Recursive Division 알고리즘 Resursive Division 알고리즘으로 생성된 미로를 보면 다른 미로들과 비교해 상당히 이질적이다. 마치 던전 맵 같은 방 구조로 되어있으며 접근할 수 없는 갇힌 방도 만들어진다. 공간을 분할하며 한 줄짜리 벽을 만들고 벽에 단 하나의 통로만 뚫는다. 이 과정이 반복되며 어떤 영역은 한 통로만 생기고 나머지는 벽으로 막혀버릴 수 있다. 모든 칸이 연결된 완전 미로를 만들기 위해 코드를 약간 수정했다. 벽을 만들 때 이미 통로가 있는지 확인하고 막히게 된다면 추가로 통로를 더 뚫어주는 로직을 넣어주었다. 그래도 막힌 방이 생성됨… 좀 벽을 더 뚫어줘야할 것 같다. // Recursive Division 알고리즘 // 완전 미로를 만들기 위한 커스텀 // 분할선 크기 조정 시 방 크기 조정 async function generateRecursiveDivision(x1, y1, x2, y2, orientation) { // 방이 너무 작으면 중단 if (x2 - x1 &lt; 2 || y2 - y1 &lt; 2) { return; } // 수평 if (orientation === 'horizontal') { // 분할선 후보(짝수) const possibleYs = []; for (let y = y1 + 2; y &lt; y2; y += 2) { possibleYs.push(y); } if (possibleYs.length === 0) { // 분할선 후보가 없으면 중단 return; } const y = possibleYs[Math.floor(Math.random() * possibleYs.length)]; // 통로 후보(홀수) const possiblePassages = []; for (let x = x1 + 1; x &lt; x2; x += 2) { possiblePassages.push(x); } if (possiblePassages.length === 0) { // 통로 후보가 없으면 중단 return; } // 반드시 하나는 통로로 만들고, 추가로 통로를 더 만들 확률도 부여 const passageCount = 1 + Math.floor(Math.random() * Math.max(1, possiblePassages.length / 3)); const passages = []; const passageCandidates = [...possiblePassages]; while (passages.length &lt; passageCount &amp;&amp; passageCandidates.length &gt; 0) { const idx = Math.floor(Math.random() * passageCandidates.length); const px = passageCandidates.splice(idx, 1)[0]; passages.push(px); } // 벽 생성 (통로 제외) for (let x = x1; x &lt;= x2; x++) { if (!passages.includes(x)) { maze[y][x] = 1; drawCell(x, y, 'black'); } } await sleep(5); // 위/아래 영역 재귀 호출 await generateRecursiveDivision(x1, y1, x2, y - 1, 'vertical'); await generateRecursiveDivision(x1, y + 1, x2, y2, 'vertical'); } else { // 수직 // 분할선 후보(짝수) const possibleXs = []; for (let x = x1 + 2; x &lt; x2; x += 2) { possibleXs.push(x); } if (possibleXs.length === 0) { // 분할선 후보가 없으면 중단 return; } const x = possibleXs[Math.floor(Math.random() * possibleXs.length)]; // 통로 후보(홀수) const possiblePassages = []; for (let y = y1 + 1; y &lt; y2; y += 2) { possiblePassages.push(y); } if (possiblePassages.length === 0) { // 통로 후보가 없으면 중단 return; } // 반드시 하나는 통로로 만들고, 추가로 통로를 더 만들 확률도 부여 const passageCount = 1 + Math.floor(Math.random() * Math.max(1, possiblePassages.length / 3)); const passages = []; const passageCandidates = [...possiblePassages]; while (passages.length &lt; passageCount &amp;&amp; passageCandidates.length &gt; 0) { const idx = Math.floor(Math.random() * passageCandidates.length); const py = passageCandidates.splice(idx, 1)[0]; passages.push(py); } // 벽 생성 (통로 제외) for (let y = y1; y &lt;= y2; y++) { if (!passages.includes(y)) { maze[y][x] = 1; drawCell(x, y, 'black'); } } await sleep(5); // 좌/우 영역 재귀 호출 await generateRecursiveDivision(x1, y1, x - 1, y2, 'horizontal'); await generateRecursiveDivision(x + 1, y1, x2, y2, 'horizontal'); } } 3. Eller’s 알고리즘 Eller’s 알고리즘은 각 행마다 집합을 관리하며 벽을 뚫을 때 집합을 병합하거나 새로 부여한다. 한 줄씩 처리하며 집합 연산과 벽 뚫기만 하고 복잡한 경로 탐색이 없어서 메모리 접근이 효율적이고 엄청나게 빠르다. 실제로 시뮬레이션 돌리면 혼자서 미로를 호다닥 생성해버린다. 엄청나게 빠른게 장점이라면 단점으로는 무작위성이 떨어지며 수평으로 편향되어 있다는 점 정도? 좀 숭숭 뚫려있는 느낌도 받는다. 수직으로 한 칸 짜리 벽 생성을 지양해야하는데 수평으로 한 줄씩 처리하기 때문에 수직 처리하기 곤란하다. // Eller's Algorithm 미로 생성 async function generateEller() { // 모든 셀을 벽으로 초기화 for (let y = 0; y &lt; rows; y++) { for (let x = 0; x &lt; cols; x++) { maze[y][x] = 1; drawCell(x, y, 'black'); } } // 각 셀의 집합 번호를 저장할 배열 let sets = []; let nextSet = 1; // 첫 번째 행 초기화 for (let x = 0; x &lt; cols; x += 2) { sets[x] = nextSet++; maze[0][x] = 0; drawCell(x, 0, 'white'); } // 각 행을 처리 for (let y = 0; y &lt; rows; y += 2) { // 1. 오른쪽으로 벽을 뚫을지 결정 for (let x = 0; x &lt; cols - 2; x += 2) { // 같은 집합이 아니고, 랜덤하게 벽을 뚫기로 결정하면 if (sets[x] !== sets[x + 2] &amp;&amp; Math.random() &lt; 0.5) { // 벽 뚫기 maze[y][x + 1] = 0; drawCell(x + 1, y, 'white'); // 집합 병합 const oldSet = sets[x + 2]; const newSet = sets[x]; for (let i = 0; i &lt; cols; i += 2) { if (sets[i] === oldSet) sets[i] = newSet; } } } // 마지막 행이 아니면 아래로 벽을 뚫기 if (y + 2 &lt; rows) { // 각 집합별로 아래로 연결할 셀을 최소 1개 이상 선택 const setCells = {}; for (let x = 0; x &lt; cols; x += 2) { if (!setCells[sets[x]]) setCells[sets[x]] = []; setCells[sets[x]].push(x); } // 아래로 연결 let newSets = []; for (const set in setCells) { // 반드시 하나는 아래로 연결 const cells = setCells[set]; const shuffled = cells.slice().sort(() =&gt; Math.random() - 0.5); const downCount = 1 + Math.floor(Math.random() * cells.length); for (let i = 0; i &lt; downCount; i++) { const x = shuffled[i]; maze[y + 1][x] = 0; drawCell(x, y + 1, 'white'); maze[y + 2][x] = 0; drawCell(x, y + 2, 'white'); newSets[x] = nextSet++; } } // 나머지 셀은 새로운 집합 번호 부여 for (let x = 0; x &lt; cols; x += 2) { if (!newSets[x]) { maze[y + 2][x] = 0; drawCell(x, y + 2, 'white'); newSets[x] = nextSet++; } } sets = newSets; } await sleep(10); } } 완성 Binary Tree 알고리즘 미로 Sidewinder 알고리즘 미로 Recursive Division 알고리즘 미로 Eller’s 알고리즘 미로 반성 7종 알고리즘 미로를 완성했다. 그 외 몇가지 알고리즘이 더 있긴한데, 대표적으로 이 7종이면 더 맛 볼 필요는 없다고 한다. 그리고 미로 알고리즘 짜다가 알게 되었는데 던전 맵 만드는 알고리즘과 미로 알고리즘은 또 다르다고 한다… 정리 되면 던전 맵 시뮬레이터도 만들어봐야겠다. 코드 확인 직접 해보기 Binary Tree Link to GitHub Sidewinder Link to GitHub Recursive Division Link to GitHub Eller’s Link to GitHub]]></summary></entry></feed>