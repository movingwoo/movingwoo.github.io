<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://movingwoo.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://movingwoo.com/" rel="alternate" type="text/html" hreflang="ko-KR" /><updated>2025-05-21T01:51:23+00:00</updated><id>https://movingwoo.com/feed.xml</id><title type="html">뭐라도 하겠지</title><subtitle>나도 사람인데 뭐라도 하겠지</subtitle><entry><title type="html">미로 생성기 01</title><link href="https://movingwoo.com/one-pan/javascript/2025/05/20/Maze-Generator-01.html" rel="alternate" type="text/html" title="미로 생성기 01" /><published>2025-05-20T23:00:00+00:00</published><updated>2025-05-20T23:00:00+00:00</updated><id>https://movingwoo.com/one-pan/javascript/2025/05/20/Maze%20Generator%2001</id><content type="html" xml:base="https://movingwoo.com/one-pan/javascript/2025/05/20/Maze-Generator-01.html"><![CDATA[<blockquote>
  <h4 id="개요">개요</h4>
  <hr />
</blockquote>

<p>이전에 DFS 공부한걸 찾아서 미로 만드는데 써봄.<br />
캔버스로 미로를 자동으로 그리고 추가로 미로를 만들 수 있는 다른 알고리즘도 써보기로 함.</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-설계">1. 설계</h5>

<p>미로 생성할 수 있는 대표 알고리즘 7종에 대하여 찾아보았다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">알고리즘</th>
      <th style="text-align: left">스타일</th>
      <th style="text-align: left">특징</th>
      <th style="text-align: left">용도</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">DFS</td>
      <td style="text-align: left">꼬불꼬불한 한 줄기 통로, 가지치기 많음</td>
      <td style="text-align: left">재귀 기반, 한 방향으로 깊게 파고들며 되돌아오며 생성</td>
      <td style="text-align: left">일반적인 퍼즐형 미로</td>
    </tr>
    <tr>
      <td style="text-align: left">Prim’s</td>
      <td style="text-align: left">불규칙한 가지 형태, 길이 자연스럽게 분산</td>
      <td style="text-align: left">Queue 또는 set을 이용, 인접 벽 중 하나씩 랜덤 제거</td>
      <td style="text-align: left">일반적인 퍼즐형 미로</td>
    </tr>
    <tr>
      <td style="text-align: left">Kruskal’s</td>
      <td style="text-align: left">큰 방, 높은 통로 복잡도</td>
      <td style="text-align: left">Union find 기반, 모든 칸을 연결하되 사이클 제거</td>
      <td style="text-align: left">랜덤하고 복잡한 퍼즐 미로</td>
    </tr>
    <tr>
      <td style="text-align: left">Binary Tree</td>
      <td style="text-align: left">매우 단순하며 위 또는 오른쪽만 뚫음</td>
      <td style="text-align: left">단순하기에 성능이 좋지만 구조가 예측 가능</td>
      <td style="text-align: left">빠른 생성, 규칙적 패턴</td>
    </tr>
    <tr>
      <td style="text-align: left">Sidewinder</td>
      <td style="text-align: left">줄 단위, 수평 위주 통로</td>
      <td style="text-align: left">행 단위로 생성, 각 줄마다 위로 하나 연결하며 수평으로 길어짐</td>
      <td style="text-align: left">빠른 렌더링, 제한된 방향성</td>
    </tr>
    <tr>
      <td style="text-align: left">Recursive Division</td>
      <td style="text-align: left">벽 많은 구조, 사각형 영역</td>
      <td style="text-align: left">전체를 벽으로 채우고 구멍을 뚫어 나눔, 방처럼 보이는 구조</td>
      <td style="text-align: left">방 구성, 던전 형태</td>
    </tr>
    <tr>
      <td style="text-align: left">Eller’s</td>
      <td style="text-align: left">일정한 패턴, 세로로 잘 연결됨</td>
      <td style="text-align: left">행 단위로 생성하며 집합 유지, 메모리 효율적</td>
      <td style="text-align: left">모바일, 웹에서 실시간 생성</td>
    </tr>
  </tbody>
</table>

<p>목표는 7종 알고리즘을 전부 시뮬레이션해보는 것인데 우선은 DFS만 시뮬레이션 해본다.<br />
한 html 파일에 몰아넣으면 보기 힘들어지므로, html 파일에는 뼈대와 공통함수만 몰아두고 DFS는 js로 별도 생성한다.<br />
이후 알고리즘 추가 시 js만 추가해서 바로 사용할 수 있도록 한다.</p>

<h5 id="2-뼈대-작성">2. 뼈대 작성</h5>

<p>Generate 버튼 클릭 시 미로를 생성하는 과정을 애니메이션으로 보여준다.<br />
그리고 입구부터 출구까지의 경로를 빨간색으로 표시한다.<br />
그러기 위한 공통변수와 함수를 이곳에 작성.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"ko"</span><span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;</span>
  <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"UTF-8"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;title&gt;</span>Maze Generator<span class="nt">&lt;/title&gt;</span>
  <span class="nt">&lt;style&gt;</span>
    <span class="nt">body</span> <span class="p">{</span>
      <span class="nl">font-family</span><span class="p">:</span> <span class="nb">sans-serif</span><span class="p">;</span>
      <span class="nl">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">;</span>
      <span class="nl">flex-direction</span><span class="p">:</span> <span class="n">column</span><span class="p">;</span>
      <span class="nl">align-items</span><span class="p">:</span> <span class="nb">center</span><span class="p">;</span>
      <span class="nl">background</span><span class="p">:</span> <span class="m">#f2f2f2</span><span class="p">;</span>
      <span class="nl">margin</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
      <span class="nl">padding</span><span class="p">:</span> <span class="m">20px</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nt">button</span> <span class="p">{</span>
      <span class="nl">padding</span><span class="p">:</span> <span class="m">8px</span> <span class="m">16px</span><span class="p">;</span>
      <span class="nl">margin-bottom</span><span class="p">:</span> <span class="m">10px</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nf">#canvas</span> <span class="p">{</span>
      <span class="nl">border</span><span class="p">:</span> <span class="m">2px</span> <span class="nb">solid</span> <span class="m">#333</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="nt">&lt;/style&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>

  <span class="c">&lt;!-- DFS 기반 미로 버튼 --&gt;</span>
  <span class="nt">&lt;button</span> <span class="na">onclick=</span><span class="s">"startDFS()"</span><span class="nt">&gt;</span>DFS Generate<span class="nt">&lt;/button&gt;</span>
  <span class="c">&lt;!-- 이후 버튼 추가 --&gt;</span>

  <span class="c">&lt;!-- 미로 캔버스 --&gt;</span>
  <span class="nt">&lt;canvas</span> <span class="na">id=</span><span class="s">"canvas"</span> <span class="na">width=</span><span class="s">"1020"</span> <span class="na">height=</span><span class="s">"620"</span><span class="nt">&gt;&lt;/canvas&gt;</span>

  <span class="nt">&lt;script&gt;</span>
    <span class="c1">// 공통 변수와 함수</span>
    <span class="kd">const</span> <span class="nx">canvas</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">#canvas</span><span class="dl">'</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nf">getContext</span><span class="p">(</span><span class="dl">'</span><span class="s1">2d</span><span class="dl">'</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">size</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">cols</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span> <span class="o">/</span> <span class="nx">size</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">rows</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span> <span class="o">/</span> <span class="nx">size</span><span class="p">;</span>

    <span class="c1">// 미로 상태</span>
    <span class="kd">let</span> <span class="nx">maze</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">let</span> <span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">();</span> <span class="c1">// 방문한 셀 저장용</span>
    <span class="kd">let</span> <span class="nx">entrance</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">];</span> <span class="c1">// 입구</span>
    <span class="kd">let</span> <span class="nx">exit</span> <span class="o">=</span> <span class="p">[</span><span class="nx">cols</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">rows</span> <span class="o">-</span> <span class="mi">2</span><span class="p">];</span> <span class="c1">// 출구(정의만 해두고 실제 출구는 나중에)</span>

    <span class="c1">// 시간 지연 함수 (애니메이션용)</span>
    <span class="kd">function</span> <span class="nf">sleep</span><span class="p">(</span><span class="nx">ms</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="o">=&gt;</span> <span class="nf">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">ms</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="c1">// 셀 색칠</span>
    <span class="kd">function</span> <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">color</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">ctx</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="nx">color</span><span class="p">;</span>
      <span class="nx">ctx</span><span class="p">.</span><span class="nf">fillRect</span><span class="p">(</span><span class="nx">x</span> <span class="o">*</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">y</span> <span class="o">*</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">size</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 미로 초기화</span>
    <span class="kd">function</span> <span class="nf">initMaze</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">maze</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">({</span> <span class="na">length</span><span class="p">:</span> <span class="nx">rows</span> <span class="p">},</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nc">Array</span><span class="p">(</span><span class="nx">cols</span><span class="p">).</span><span class="nf">fill</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span> <span class="c1">// 전부 벽</span>
      <span class="nx">visited</span><span class="p">.</span><span class="nf">clear</span><span class="p">();</span>
      <span class="nx">ctx</span><span class="p">.</span><span class="nf">clearRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="p">);</span>

      <span class="c1">// 캔버스 전체를 벽으로 색칠</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">initMaze</span><span class="p">();</span>
  <span class="nt">&lt;/script&gt;</span>

  <span class="c">&lt;!-- DFS 미로 스크립트 --&gt;</span>
  <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"./js/DFS.js"</span><span class="nt">&gt;&lt;/script&gt;</span>

<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<h5 id="3-dfs-스크립트-작성">3. DFS 스크립트 작성</h5>

<p>DFS 미로 생성하고 길 찾는 부분은 BFS로 구현.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 배열 섞기</span>
<span class="kd">function</span> <span class="nf">shuffle</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">j</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]];</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
<span class="p">}</span>
  
<span class="c1">// 미로 생성(DFS)</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">generateDFS</span><span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">entrance</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">entrance</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">x</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">y</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
  <span class="nx">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
  <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 흰색 길</span>

  <span class="c1">// 이동 방향 무작위</span>
  <span class="kd">const</span> <span class="nx">dirs</span> <span class="o">=</span> <span class="nf">shuffle</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]);</span>

  <span class="c1">// forEach 사용시 동기화 문제있어서 for of 사용</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">]</span> <span class="k">of</span> <span class="nx">dirs</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">nx</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">ny</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">betweenX</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">betweenY</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">neighborKey</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">nx</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">ny</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>

    <span class="c1">// 방문하지 않은 셀을 통로로 만들기</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">nx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nx</span> <span class="o">&lt;</span> <span class="nx">cols</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&lt;</span> <span class="nx">rows</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">visited</span><span class="p">.</span><span class="nf">has</span><span class="p">(</span><span class="nx">neighborKey</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">maze</span><span class="p">[</span><span class="nx">ny</span><span class="p">][</span><span class="nx">nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 다음 셀도 통로</span>
      <span class="nx">maze</span><span class="p">[</span><span class="nx">betweenY</span><span class="p">][</span><span class="nx">betweenX</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 중간 벽 없애기</span>
      <span class="nf">drawCell</span><span class="p">(</span><span class="nx">betweenX</span><span class="p">,</span> <span class="nx">betweenY</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>

      <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
      <span class="k">await</span> <span class="nf">generateDFS</span><span class="p">(</span><span class="nx">nx</span><span class="p">,</span> <span class="nx">ny</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
  
<span class="c1">// 가장 멀리 떨어진 셀을 출구로 지정(BFS)</span>
<span class="kd">function</span> <span class="nf">findFurthestCell</span><span class="p">(</span><span class="nx">sx</span><span class="p">,</span> <span class="nx">sy</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">que</span> <span class="o">=</span> <span class="p">[[</span><span class="nx">sx</span><span class="p">,</span> <span class="nx">sy</span><span class="p">,</span> <span class="mi">0</span><span class="p">]];</span>
  <span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">();</span>
  <span class="kd">let</span> <span class="nx">maxDist</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">furthest</span> <span class="o">=</span> <span class="p">[</span><span class="nx">sx</span><span class="p">,</span> <span class="nx">sy</span><span class="p">];</span>

  <span class="k">while </span><span class="p">(</span><span class="nx">que</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">dist</span><span class="p">]</span> <span class="o">=</span> <span class="nx">que</span><span class="p">.</span><span class="nf">shift</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">x</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">y</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>

    <span class="k">if </span><span class="p">(</span><span class="nx">visited</span><span class="p">.</span><span class="nf">has</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>

    <span class="k">if </span><span class="p">(</span><span class="nx">dist</span> <span class="o">&gt;</span> <span class="nx">maxDist</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">maxDist</span> <span class="o">=</span> <span class="nx">dist</span><span class="p">;</span>
      <span class="nx">furthest</span> <span class="o">=</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">]</span> <span class="k">of</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">nx</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">,</span> <span class="nx">ny</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">;</span>
      <span class="k">if </span><span class="p">(</span><span class="nx">nx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nx</span> <span class="o">&lt;</span> <span class="nx">cols</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&lt;</span> <span class="nx">rows</span> <span class="o">&amp;&amp;</span> <span class="nx">maze</span><span class="p">[</span><span class="nx">ny</span><span class="p">][</span><span class="nx">nx</span><span class="p">]</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">que</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">nx</span><span class="p">,</span> <span class="nx">ny</span><span class="p">,</span> <span class="nx">dist</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">furthest</span><span class="p">;</span>
<span class="p">}</span>
  
  <span class="c1">// 탈출 경로 찾기(BFS)</span>
<span class="kd">function</span> <span class="nf">findPathBFS</span><span class="p">(</span><span class="nx">sx</span><span class="p">,</span> <span class="nx">sy</span><span class="p">,</span> <span class="nx">ex</span><span class="p">,</span> <span class="nx">ey</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">que</span> <span class="o">=</span> <span class="p">[[</span><span class="nx">sx</span><span class="p">,</span> <span class="nx">sy</span><span class="p">]];</span>
  <span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">();</span>
  <span class="kd">const</span> <span class="nx">parent</span> <span class="o">=</span> <span class="p">{};</span>

  <span class="k">while </span><span class="p">(</span><span class="nx">que</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">]</span> <span class="o">=</span> <span class="nx">que</span><span class="p">.</span><span class="nf">shift</span><span class="p">();</span>

    <span class="k">if </span><span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="nx">ex</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="o">===</span> <span class="nx">ey</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">x</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">y</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>

    <span class="nx">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>

    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">]</span> <span class="k">of</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">nx</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">,</span> <span class="nx">ny</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">;</span>
      <span class="kd">const</span> <span class="nx">nextKey</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">nx</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">ny</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>

      <span class="c1">// 벽이 아니고 방문하지 않은 길</span>
      <span class="k">if </span><span class="p">(</span><span class="nx">nx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nx</span> <span class="o">&lt;</span> <span class="nx">cols</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&lt;</span> <span class="nx">rows</span> <span class="o">&amp;&amp;</span> <span class="nx">maze</span><span class="p">[</span><span class="nx">ny</span><span class="p">][</span><span class="nx">nx</span><span class="p">]</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">visited</span><span class="p">.</span><span class="nf">has</span><span class="p">(</span><span class="nx">nextKey</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">que</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">nx</span><span class="p">,</span> <span class="nx">ny</span><span class="p">]);</span>
        <span class="nx">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">nextKey</span><span class="p">);</span>
        <span class="nx">parent</span><span class="p">[</span><span class="nx">nextKey</span><span class="p">]</span> <span class="o">=</span> <span class="nx">key</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 출구에서 역으로 경로 추적</span>
  <span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">let</span> <span class="nx">curr</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">ex</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">ey</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>

  <span class="k">while </span><span class="p">(</span><span class="nx">curr</span> <span class="o">!==</span> <span class="s2">`</span><span class="p">${</span><span class="nx">sx</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">sy</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">]</span> <span class="o">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">,</span><span class="dl">'</span><span class="p">).</span><span class="nf">map</span><span class="p">(</span><span class="nb">Number</span><span class="p">);</span>
    <span class="nx">path</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">]);</span>
    <span class="nx">curr</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">[</span><span class="nx">curr</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="nx">path</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">sx</span><span class="p">,</span> <span class="nx">sy</span><span class="p">]);</span>

  <span class="k">return</span> <span class="nx">path</span><span class="p">.</span><span class="nf">reverse</span><span class="p">();</span>
<span class="p">}</span>
  
<span class="c1">// 미로 탈출 경로 그리기</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">drawPathAnimated</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">]</span> <span class="k">of</span> <span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">((</span><span class="nx">x</span> <span class="o">===</span> <span class="nx">entrance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="o">===</span> <span class="nx">entrance</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">||</span> <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="nx">exit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="o">===</span> <span class="nx">exit</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="p">{</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 빨강으로 색칠</span>
    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">red</span><span class="dl">'</span><span class="p">);</span>
    <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
  
<span class="c1">// 전체 실행 </span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">startDFS</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">initMaze</span><span class="p">();</span> 
  <span class="k">await</span> <span class="nf">generateDFS</span><span class="p">();</span>

  <span class="c1">// 입구 표시</span>
  <span class="nf">drawCell</span><span class="p">(</span><span class="nx">entrance</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">entrance</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="dl">'</span><span class="s1">lime</span><span class="dl">'</span><span class="p">);</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">ex</span><span class="p">,</span> <span class="nx">ey</span><span class="p">]</span> <span class="o">=</span> <span class="nf">findFurthestCell</span><span class="p">(</span><span class="nx">entrance</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">entrance</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
  <span class="nx">exit</span> <span class="o">=</span> <span class="p">[</span><span class="nx">ex</span><span class="p">,</span> <span class="nx">ey</span><span class="p">];</span>
  <span class="c1">// 출구 표시</span>
  <span class="nf">drawCell</span><span class="p">(</span><span class="nx">exit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">exit</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="dl">'</span><span class="s1">blue</span><span class="dl">'</span><span class="p">)</span>
  
  <span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nf">findPathBFS</span><span class="p">(</span><span class="nx">entrance</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">entrance</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">exit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">exit</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="k">await</span> <span class="nf">drawPathAnimated</span><span class="p">(</span><span class="nx">path</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="완성">완성</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/one-pan/JavaScript/2025-05-21-Maze Generator 01/img01.gif" alt="img01" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>async와 await에 대해 새롭게 배웠다.<br />
Promise 체인보다 코드가 엄청나게 깔끔해진다.<br />
좋아좋아 오늘도 하나 배웠어 일일신우일신</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="/play/Maze%20Generator.html" target="_blank" rel="noopener noreferrer">
  직접 해보기
</a></p>

<p>HTML<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-21-Maze%20Generator%2001.html">Link to GitHub</a></p>

<p>JavaScript<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-21-DFS.js">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="one-pan/JavaScript/" /><summary type="html"><![CDATA[개요 이전에 DFS 공부한걸 찾아서 미로 만드는데 써봄. 캔버스로 미로를 자동으로 그리고 추가로 미로를 만들 수 있는 다른 알고리즘도 써보기로 함. 구현 1. 설계 미로 생성할 수 있는 대표 알고리즘 7종에 대하여 찾아보았다. 알고리즘 스타일 특징 용도 DFS 꼬불꼬불한 한 줄기 통로, 가지치기 많음 재귀 기반, 한 방향으로 깊게 파고들며 되돌아오며 생성 일반적인 퍼즐형 미로 Prim’s 불규칙한 가지 형태, 길이 자연스럽게 분산 Queue 또는 set을 이용, 인접 벽 중 하나씩 랜덤 제거 일반적인 퍼즐형 미로 Kruskal’s 큰 방, 높은 통로 복잡도 Union find 기반, 모든 칸을 연결하되 사이클 제거 랜덤하고 복잡한 퍼즐 미로 Binary Tree 매우 단순하며 위 또는 오른쪽만 뚫음 단순하기에 성능이 좋지만 구조가 예측 가능 빠른 생성, 규칙적 패턴 Sidewinder 줄 단위, 수평 위주 통로 행 단위로 생성, 각 줄마다 위로 하나 연결하며 수평으로 길어짐 빠른 렌더링, 제한된 방향성 Recursive Division 벽 많은 구조, 사각형 영역 전체를 벽으로 채우고 구멍을 뚫어 나눔, 방처럼 보이는 구조 방 구성, 던전 형태 Eller’s 일정한 패턴, 세로로 잘 연결됨 행 단위로 생성하며 집합 유지, 메모리 효율적 모바일, 웹에서 실시간 생성 목표는 7종 알고리즘을 전부 시뮬레이션해보는 것인데 우선은 DFS만 시뮬레이션 해본다. 한 html 파일에 몰아넣으면 보기 힘들어지므로, html 파일에는 뼈대와 공통함수만 몰아두고 DFS는 js로 별도 생성한다. 이후 알고리즘 추가 시 js만 추가해서 바로 사용할 수 있도록 한다. 2. 뼈대 작성 Generate 버튼 클릭 시 미로를 생성하는 과정을 애니메이션으로 보여준다. 그리고 입구부터 출구까지의 경로를 빨간색으로 표시한다. 그러기 위한 공통변수와 함수를 이곳에 작성. &lt;!DOCTYPE html&gt; &lt;html lang="ko"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Maze Generator&lt;/title&gt; &lt;style&gt; body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background: #f2f2f2; margin: 0; padding: 20px; } button { padding: 8px 16px; margin-bottom: 10px; } #canvas { border: 2px solid #333; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- DFS 기반 미로 버튼 --&gt; &lt;button onclick="startDFS()"&gt;DFS Generate&lt;/button&gt; &lt;!-- 이후 버튼 추가 --&gt; &lt;!-- 미로 캔버스 --&gt; &lt;canvas id="canvas" width="1020" height="620"&gt;&lt;/canvas&gt; &lt;script&gt; // 공통 변수와 함수 const canvas = document.querySelector('#canvas'); const ctx = canvas.getContext('2d'); const size = 20; const cols = canvas.width / size; const rows = canvas.height / size; // 미로 상태 let maze = []; let visited = new Set(); // 방문한 셀 저장용 let entrance = [0, 0]; // 입구 let exit = [cols - 2, rows - 2]; // 출구(정의만 해두고 실제 출구는 나중에) // 시간 지연 함수 (애니메이션용) function sleep(ms) { return new Promise(resolve =&gt; setTimeout(resolve, ms)); } // 셀 색칠 function drawCell(x, y, color) { ctx.fillStyle = color; ctx.fillRect(x * size, y * size, size, size); } // 미로 초기화 function initMaze() { maze = Array.from({ length: rows }, () =&gt; Array(cols).fill(1)); // 전부 벽 visited.clear(); ctx.clearRect(0, 0, canvas.width, canvas.height); // 캔버스 전체를 벽으로 색칠 for (let y = 0; y &lt; rows; y++) { for (let x = 0; x &lt; cols; x++) { drawCell(x, y, 'black'); } } } initMaze(); &lt;/script&gt; &lt;!-- DFS 미로 스크립트 --&gt; &lt;script src="./js/DFS.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 3. DFS 스크립트 작성 DFS 미로 생성하고 길 찾는 부분은 BFS로 구현. // 배열 섞기 function shuffle(arr) { for (let i = arr.length - 1; i &gt; 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } return arr; } // 미로 생성(DFS) async function generateDFS(x = entrance[0], y = entrance[1]) { const key = `${x},${y}`; visited.add(key); maze[y][x] = 0; drawCell(x, y, 'white'); // 흰색 길 // 이동 방향 무작위 const dirs = shuffle([[0, -2], [2, 0], [0, 2], [-2, 0]]); // forEach 사용시 동기화 문제있어서 for of 사용 for (let [dx, dy] of dirs) { const nx = x + dx; const ny = y + dy; const betweenX = x + dx / 2; const betweenY = y + dy / 2; const neighborKey = `${nx},${ny}`; // 방문하지 않은 셀을 통로로 만들기 if (nx &gt;= 0 &amp;&amp; nx &lt; cols &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; rows &amp;&amp; !visited.has(neighborKey)) { maze[ny][nx] = 0; // 다음 셀도 통로 maze[betweenY][betweenX] = 0; // 중간 벽 없애기 drawCell(betweenX, betweenY, 'white'); await sleep(5); await generateDFS(nx, ny); } } } // 가장 멀리 떨어진 셀을 출구로 지정(BFS) function findFurthestCell(sx, sy) { const que = [[sx, sy, 0]]; const visited = new Set(); let maxDist = -1; let furthest = [sx, sy]; while (que.length) { const [x, y, dist] = que.shift(); const key = `${x},${y}`; if (visited.has(key)) { continue; } visited.add(key); if (dist &gt; maxDist) { maxDist = dist; furthest = [x, y]; } for (let [dx, dy] of [[0,1],[1,0],[0,-1],[-1,0]]) { const nx = x + dx, ny = y + dy; if (nx &gt;= 0 &amp;&amp; nx &lt; cols &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; rows &amp;&amp; maze[ny][nx] === 0) { que.push([nx, ny, dist + 1]); } } } return furthest; } // 탈출 경로 찾기(BFS) function findPathBFS(sx, sy, ex, ey) { const que = [[sx, sy]]; const visited = new Set(); const parent = {}; while (que.length) { const [x, y] = que.shift(); if (x === ex &amp;&amp; y === ey) { break; } const key = `${x},${y}`; visited.add(key); for (let [dx, dy] of [[0,1],[1,0],[0,-1],[-1,0]]) { const nx = x + dx, ny = y + dy; const nextKey = `${nx},${ny}`; // 벽이 아니고 방문하지 않은 길 if (nx &gt;= 0 &amp;&amp; nx &lt; cols &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; rows &amp;&amp; maze[ny][nx] === 0 &amp;&amp; !visited.has(nextKey)) { que.push([nx, ny]); visited.add(nextKey); parent[nextKey] = key; } } } // 출구에서 역으로 경로 추적 const path = []; let curr = `${ex},${ey}`; while (curr !== `${sx},${sy}`) { const [x, y] = curr.split(',').map(Number); path.push([x, y]); curr = parent[curr]; } path.push([sx, sy]); return path.reverse(); } // 미로 탈출 경로 그리기 async function drawPathAnimated(path) { for (let [x, y] of path) { if ((x === entrance[0] &amp;&amp; y === entrance[1]) || (x === exit[0] &amp;&amp; y === exit[1])) { continue; } // 빨강으로 색칠 drawCell(x, y, 'red'); await sleep(10); } } // 전체 실행 async function startDFS() { initMaze(); await generateDFS(); // 입구 표시 drawCell(entrance[0], entrance[1], 'lime'); const [ex, ey] = findFurthestCell(entrance[0], entrance[1]) exit = [ex, ey]; // 출구 표시 drawCell(exit[0], exit[1], 'blue') const path = findPathBFS(entrance[0], entrance[1], exit[0], exit[1]); await drawPathAnimated(path); } 완성 반성 async와 await에 대해 새롭게 배웠다. Promise 체인보다 코드가 엄청나게 깔끔해진다. 좋아좋아 오늘도 하나 배웠어 일일신우일신 코드 확인 직접 해보기 HTML Link to GitHub JavaScript Link to GitHub]]></summary></entry><entry><title type="html">15936번 Hypercube</title><link href="https://movingwoo.com/random-solve/java/2025/05/20/15936.html" rel="alternate" type="text/html" title="15936번 Hypercube" /><published>2025-05-20T00:00:00+00:00</published><updated>2025-05-20T00:00:00+00:00</updated><id>https://movingwoo.com/random-solve/java/2025/05/20/15936</id><content type="html" xml:base="https://movingwoo.com/random-solve/java/2025/05/20/15936.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Java/2025-05-20-15936/img01.jpg" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/15936">15936번 Hypercube - 백준</a></p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>앗 영어문제<br />
아니 진짜 뭔 이딴문제만 걸리냐?</p>

<p>시간제한이 0.2초인데 이거 자바로 되나 싶었는데 푼 사람 목록보니 파이썬도 있다.<br />
알고리즘 잘 짜면 자바도 되겠지 뭐…</p>

<p>입력으로 N, M, K를 준다.</p>
<ul>
  <li>N: N차원 하이퍼 큐브</li>
  <li>M: 노드 번호</li>
  <li>K: 경로 길이</li>
</ul>

<p>하이퍼 큐브가 머에여???<br />
<a href="https://namu.wiki/w/%EC%B4%88%EC%9E%85%EB%B0%A9%EC%B2%B4">초입방체 - 나무위키</a></p>

<p>2^N개의 노드를 가지며 x에서 y로 가려면 x &lt; y 이고 xor 연산 시 2^p가 되어야 한다.(비트가 하나 다르다.)<br />
라고 문제에서 말해줌.</p>

<p>문제가 요구하는 건 3가지인데<br />
a. M 번 노드로 향하는 간선이 시작하는 노드 번호의 최댓값<br />
b. M 번 노드에서 시작하는 간선이 향하는 노드 번호의 최소값<br />
c. 찾을 수 있는 K-길이의(K개의 간선을 포함하는) 경로의 개수. 100003 나머지 연산.</p>

<p>허허 이게 국어가 맞나</p>

<p>딱 봐도 하이퍼 큐브를 구현하면 제한 시간에 걸려 터진다.<br />
더 좋은 수학실력이 필요하다는 뜻임…</p>

<p>구글링으로 수학 고수들을 통해 문제 해결 공식을 얻은 다음 구현은 내가 하는 쪽으로 한다.<br />
나 혼자서는 풀 수 없음…</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-입력-받기">1. 입력 받기</h5>

<p>Scanner 사용하면 터질 것 같으니 버퍼로 입력 받는다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span><span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
        
        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">(),</span> <span class="s">" "</span><span class="o">);</span>
        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="kt">int</span> <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="kt">int</span> <span class="no">K</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        
    <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h5 id="2-a번-문제">2. a번 문제</h5>

<p>a. M 번 노드로 향하는 간선이 시작하는 노드 번호의 최댓값</p>

<p>일단 M번 노드로 향하는 거니 M보다 작은 노드가 범인이다.<br />
어차피 모든 노드는 작은 수에서 큰 수로 이어지니 M번 노드보다 하나 작은, xor 연산에서 비트 하나 다른 놈을 찾아야한다.<br />
반복문으로 1인 비트를 반전시켜서 비교한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// a번: 이진수 M의 1을 반전시킨 수 중 최대값</span>
<span class="c1">// 최대값 저장용</span>
<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
<span class="c1">// 0번째 비트부터 올라감, 100,000,000는 27비트</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">27</span> <span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="c1">// M의 i번째 비트가 1인 경우</span>
    <span class="c1">// == 1 할 경우 0번째 비트만 체크해서 오류 발생</span>
    <span class="c1">//if ((M &amp; (1 &lt;&lt; i)) == 1) {</span>
    <span class="k">if</span> <span class="o">((</span><span class="no">M</span> <span class="o">&amp;</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="no">M</span> <span class="o">^</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">);</span> <span class="c1">// 반전</span>
        
        <span class="k">if</span> <span class="o">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="no">M</span> <span class="o">&amp;&amp;</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">m</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h5 id="3-b번-문제">3. b번 문제</h5>

<p>a번이랑 비슷한데, 각 비트를 반전시켜서 최소값을 찾으면 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// b번: M의 비트 하나를 반전시킨 수 중 M보다 큰 최소값 찾기</span>
<span class="c1">// 최소값 저장용</span>
<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">27</span> <span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="c1">// i번째 비트를 반전시킨 숫자</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="no">M</span> <span class="o">^</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="no">M</span> <span class="o">&amp;&amp;</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">m</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h5 id="4-c번-문제">4. c번 문제</h5>

<p>해밍 무게 변화에 따른 경로 수를 구하는 것.<br />
전이 관계를 행렬 형태로 표현한 뒤, 행렬 거듭제곱을 통해 빠르게 K 단계를 계산한다.<br />
즉, 전체 시스템을 크기 N+1의 전이 행렬로 보고, dpK = T^K * dp₀ 형태로 계산하는 것이다!</p>

<p>엄….</p>

<p><span style="color: orange;"><strong>좋아 완벽하게 이해했어!!</strong></span></p>

<p>일단 시간복잡도가 O(NK)면 절대 통과하지 못한다.<br />
O(N log K)로 바꾸면 통과가 가능하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// c번: 공식계산</span>
<span class="n">doFactorials</span><span class="o">(</span><span class="no">N</span><span class="o">);</span>

<span class="c1">// 초기 상태 dp0: 해밍 무게 w를 가진 노드 수 = C(N, w)</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">w</span> <span class="o">&lt;=</span> <span class="no">N</span><span class="o">;</span> <span class="n">w</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">dp</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="no">C</span><span class="o">(</span><span class="no">N</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 전이 행렬 생성 (희소 형태로)</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&gt;&gt;</span> <span class="no">T</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="no">T</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
<span class="o">}</span>

<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="n">w</span><span class="o">++)</span> <span class="o">{</span>
    <span class="c1">// 해밍 무게가 w인 노드에서 w+1로 갈 수 있는 경우만 존재</span>
    <span class="no">T</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="no">N</span> <span class="o">-</span> <span class="n">w</span><span class="o">));</span>
<span class="o">}</span>

<span class="c1">// 희소 행렬 거듭제곱을 dp에 적용</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">dpK</span> <span class="o">=</span> <span class="n">sparseMatPowApply</span><span class="o">(</span><span class="no">T</span><span class="o">,</span> <span class="n">dp</span><span class="o">,</span> <span class="no">K</span><span class="o">,</span> <span class="no">N</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

<span class="c1">// 모든 해밍 무게에서 끝나는 경로 수 합</span>
<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">w</span> <span class="o">&lt;=</span> <span class="no">N</span><span class="o">;</span> <span class="n">w</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="n">c</span> <span class="o">+</span> <span class="n">dpK</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">%</span> <span class="mi">100003</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// ... 중략 ...</span>

<span class="c1">// 거듭제곱 계산</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">P</span><span class="o">(</span><span class="kt">int</span> <span class="n">b</span><span class="o">,</span> <span class="kt">int</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">e</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 거듭제곱 계산</span>
            <span class="n">r</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)((</span><span class="mi">1L</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">b</span><span class="o">)</span> <span class="o">%</span> <span class="mi">100003</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">b</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)((</span><span class="mi">1L</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="o">)</span> <span class="o">%</span> <span class="mi">100003</span><span class="o">);</span>
        <span class="n">e</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">r</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 팩토리얼 및 역팩토리얼 계산 (페르마 소정리 활용)</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">doFactorials</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">factorial</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
    <span class="n">invFactorial</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
    <span class="n">factorial</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="c1">// 팩토리얼 계산</span>
        <span class="n">factorial</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)((</span><span class="mi">1L</span> <span class="o">*</span> <span class="n">factorial</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="n">i</span><span class="o">)</span> <span class="o">%</span> <span class="mi">100003</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 역팩토리얼 (페르마의 소정리)</span>
    <span class="n">invFactorial</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">=</span> <span class="no">P</span><span class="o">(</span><span class="n">factorial</span><span class="o">[</span><span class="no">N</span><span class="o">],</span> <span class="mi">100003</span> <span class="o">-</span> <span class="mi">2</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="no">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
        <span class="c1">// 역팩토리얼 누적 계산</span>
        <span class="n">invFactorial</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)((</span><span class="mi">1L</span> <span class="o">*</span> <span class="n">invFactorial</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">%</span> <span class="mi">100003</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 이항계수 계산</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">C</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">w</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// C(n, r) 계산</span>
    <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="mi">1L</span> <span class="o">*</span> <span class="n">factorial</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">*</span> <span class="n">invFactorial</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">%</span> <span class="mi">100003</span> <span class="o">*</span> <span class="n">invFactorial</span><span class="o">[</span><span class="no">N</span> <span class="o">-</span> <span class="n">w</span><span class="o">]</span> <span class="o">%</span> <span class="mi">100003</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 희소행렬 형태: 각 행마다 (열, 값) 쌍 저장</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Pair</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">col</span><span class="o">,</span> <span class="n">val</span><span class="o">;</span>
    <span class="nc">Pair</span><span class="o">(</span><span class="kt">int</span> <span class="n">col</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 희소 행렬 곱셈</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sparseMatVecMul</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&gt;&gt;</span> <span class="n">mat</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">vec</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Pair</span> <span class="n">p</span> <span class="o">:</span> <span class="n">mat</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)((</span><span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1L</span> <span class="o">*</span> <span class="n">p</span><span class="o">.</span><span class="na">val</span> <span class="o">*</span> <span class="n">vec</span><span class="o">[</span><span class="n">p</span><span class="o">.</span><span class="na">col</span><span class="o">])</span> <span class="o">%</span> <span class="mi">100003</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 희소 행렬 거듭제곱과 곱셈</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sparseMatPowApply</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&gt;&gt;</span> <span class="no">T</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">vec</span><span class="o">,</span> <span class="kt">int</span> <span class="n">exp</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 초기 단위 행렬 적용: vec는 dp로 시작</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">exp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">exp</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">sparseMatVecMul</span><span class="o">(</span><span class="no">T</span><span class="o">,</span> <span class="n">vec</span><span class="o">,</span> <span class="n">size</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// T = T * T (희소 곱)</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&gt;&gt;</span> <span class="n">newT</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">newT</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
        <span class="o">}</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Pair</span> <span class="n">kv1</span> <span class="o">:</span> <span class="no">T</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">Pair</span> <span class="n">kv2</span> <span class="o">:</span> <span class="no">T</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">kv1</span><span class="o">.</span><span class="na">col</span><span class="o">))</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)((</span><span class="mi">1L</span> <span class="o">*</span> <span class="n">kv1</span><span class="o">.</span><span class="na">val</span> <span class="o">*</span> <span class="n">kv2</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">%</span> <span class="mi">100003</span><span class="o">);</span>
                    <span class="n">newT</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">(</span><span class="n">kv2</span><span class="o">.</span><span class="na">col</span><span class="o">,</span> <span class="n">val</span><span class="o">));</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 중복 열 통합</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">newT</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">continue</span><span class="o">;</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&gt;</span> <span class="n">row</span> <span class="o">=</span> <span class="n">newT</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">row</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="nc">Comparator</span><span class="o">.</span><span class="na">comparingInt</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="na">col</span><span class="o">));</span>

            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&gt;</span> <span class="n">compressed</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="kt">int</span> <span class="n">lastCol</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Pair</span> <span class="n">p</span> <span class="o">:</span> <span class="n">row</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">col</span> <span class="o">==</span> <span class="n">lastCol</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">sum</span> <span class="o">=</span> <span class="o">(</span><span class="n">sum</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">%</span> <span class="mi">100003</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">lastCol</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="n">compressed</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">(</span><span class="n">lastCol</span><span class="o">,</span> <span class="n">sum</span><span class="o">));</span>
                    <span class="n">lastCol</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">col</span><span class="o">;</span>
                    <span class="n">sum</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">lastCol</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="n">compressed</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">(</span><span class="n">lastCol</span><span class="o">,</span> <span class="n">sum</span><span class="o">));</span>
            <span class="n">newT</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">compressed</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="no">T</span> <span class="o">=</span> <span class="n">newT</span><span class="o">;</span>
        <span class="n">exp</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">vec</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Java/2025-05-20-15936/img02.jpg" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>c번에서 계속 시간초과 나길래 C++로 돌려보고 로직 문제란걸 깨닫고 구글링했다.<br />
내 힘으로 풀 수 있는 문제가 아니었다.<br />
수학공부한 셈 쳐야지 뭐.</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/random-solve/Java/2025-05-20-15936.java">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="random-solve/Java/" /><summary type="html"><![CDATA[문제 15936번 Hypercube - 백준 설계 앗 영어문제 아니 진짜 뭔 이딴문제만 걸리냐? 시간제한이 0.2초인데 이거 자바로 되나 싶었는데 푼 사람 목록보니 파이썬도 있다. 알고리즘 잘 짜면 자바도 되겠지 뭐… 입력으로 N, M, K를 준다. N: N차원 하이퍼 큐브 M: 노드 번호 K: 경로 길이 하이퍼 큐브가 머에여??? 초입방체 - 나무위키 2^N개의 노드를 가지며 x에서 y로 가려면 x &lt; y 이고 xor 연산 시 2^p가 되어야 한다.(비트가 하나 다르다.) 라고 문제에서 말해줌. 문제가 요구하는 건 3가지인데 a. M 번 노드로 향하는 간선이 시작하는 노드 번호의 최댓값 b. M 번 노드에서 시작하는 간선이 향하는 노드 번호의 최소값 c. 찾을 수 있는 K-길이의(K개의 간선을 포함하는) 경로의 개수. 100003 나머지 연산. 허허 이게 국어가 맞나 딱 봐도 하이퍼 큐브를 구현하면 제한 시간에 걸려 터진다. 더 좋은 수학실력이 필요하다는 뜻임… 구글링으로 수학 고수들을 통해 문제 해결 공식을 얻은 다음 구현은 내가 하는 쪽으로 한다. 나 혼자서는 풀 수 없음… 구현 1. 입력 받기 Scanner 사용하면 터질 것 같으니 버퍼로 입력 받는다. public static void main(String[] args) { try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out))) { StringTokenizer st = new StringTokenizer(br.readLine(), " "); int N = Integer.parseInt(st.nextToken()); int M = Integer.parseInt(st.nextToken()); int K = Integer.parseInt(st.nextToken()); }catch(IOException e) { e.printStackTrace(); } } 2. a번 문제 a. M 번 노드로 향하는 간선이 시작하는 노드 번호의 최댓값 일단 M번 노드로 향하는 거니 M보다 작은 노드가 범인이다. 어차피 모든 노드는 작은 수에서 큰 수로 이어지니 M번 노드보다 하나 작은, xor 연산에서 비트 하나 다른 놈을 찾아야한다. 반복문으로 1인 비트를 반전시켜서 비교한다. // a번: 이진수 M의 1을 반전시킨 수 중 최대값 // 최대값 저장용 int a = Integer.MIN_VALUE; // 0번째 비트부터 올라감, 100,000,000는 27비트 for (int i = 0 ; i &lt; 27 ; i++){ // M의 i번째 비트가 1인 경우 // == 1 할 경우 0번째 비트만 체크해서 오류 발생 //if ((M &amp; (1 &lt;&lt; i)) == 1) { if ((M &amp; (1 &lt;&lt; i)) != 0) { int m = M ^ (1 &lt;&lt; i); // 반전 if (m &lt; M &amp;&amp; m &gt; a) { a = m; } } } 3. b번 문제 a번이랑 비슷한데, 각 비트를 반전시켜서 최소값을 찾으면 된다. // b번: M의 비트 하나를 반전시킨 수 중 M보다 큰 최소값 찾기 // 최소값 저장용 int b = Integer.MAX_VALUE; for (int i = 0 ; i &lt; 27 ; i++){ // i번째 비트를 반전시킨 숫자 int m = M ^ (1 &lt;&lt; i); if (m &gt; M &amp;&amp; b &gt; m) { b = m; } } 4. c번 문제 해밍 무게 변화에 따른 경로 수를 구하는 것. 전이 관계를 행렬 형태로 표현한 뒤, 행렬 거듭제곱을 통해 빠르게 K 단계를 계산한다. 즉, 전체 시스템을 크기 N+1의 전이 행렬로 보고, dpK = T^K * dp₀ 형태로 계산하는 것이다! 엄…. 좋아 완벽하게 이해했어!! 일단 시간복잡도가 O(NK)면 절대 통과하지 못한다. O(N log K)로 바꾸면 통과가 가능하다. // c번: 공식계산 doFactorials(N); // 초기 상태 dp0: 해밍 무게 w를 가진 노드 수 = C(N, w) int[] dp = new int[N + 1]; for (int w = 0; w &lt;= N; w++) { dp[w] = C(N, w); } // 전이 행렬 생성 (희소 형태로) List&lt;List&lt;Pair&gt;&gt; T = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;= N; i++) { T.add(new ArrayList&lt;&gt;()); } for (int w = 0; w &lt; N; w++) { // 해밍 무게가 w인 노드에서 w+1로 갈 수 있는 경우만 존재 T.get(w + 1).add(new Pair(w, N - w)); } // 희소 행렬 거듭제곱을 dp에 적용 int[] dpK = sparseMatPowApply(T, dp, K, N + 1); // 모든 해밍 무게에서 끝나는 경로 수 합 int c = 0; for (int w = 0; w &lt;= N; w++) { c = (c + dpK[w]) % 100003; } // ... 중략 ... // 거듭제곱 계산 public static int P(int b, int e) { int r = 1; while (e &gt; 0) { if ((e &amp; 1) == 1) { // 거듭제곱 계산 r = (int)((1L * r * b) % 100003); } b = (int)((1L * b * b) % 100003); e &gt;&gt;= 1; } return r; } // 팩토리얼 및 역팩토리얼 계산 (페르마 소정리 활용) public static void doFactorials(int N) { factorial = new int[N + 1]; invFactorial = new int[N + 1]; factorial[0] = 1; for (int i = 1; i &lt;= N; i++) { // 팩토리얼 계산 factorial[i] = (int)((1L * factorial[i - 1] * i) % 100003); } // 역팩토리얼 (페르마의 소정리) invFactorial[N] = P(factorial[N], 100003 - 2); for (int i = N - 1; i &gt;= 0; i--) { // 역팩토리얼 누적 계산 invFactorial[i] = (int)((1L * invFactorial[i + 1] * (i + 1)) % 100003); } } // 이항계수 계산 public static int C(int N, int w) { if (w &lt; 0 || w &gt; N) { return 0; } // C(n, r) 계산 return (int)(1L * factorial[N] * invFactorial[w] % 100003 * invFactorial[N - w] % 100003); } // 희소행렬 형태: 각 행마다 (열, 값) 쌍 저장 public static class Pair { int col, val; Pair(int col, int val) { this.col = col; this.val = val; } } // 희소 행렬 곱셈 public static int[] sparseMatVecMul(List&lt;List&lt;Pair&gt;&gt; mat, int[] vec, int size) { int[] res = new int[size]; for (int i = 0; i &lt; size; i++) { for (Pair p : mat.get(i)) { res[i] = (int)((res[i] + 1L * p.val * vec[p.col]) % 100003); } } return res; } // 희소 행렬 거듭제곱과 곱셈 public static int[] sparseMatPowApply(List&lt;List&lt;Pair&gt;&gt; T, int[] vec, int exp, int size) { // 초기 단위 행렬 적용: vec는 dp로 시작 while (exp &gt; 0) { if ((exp &amp; 1) == 1) { vec = sparseMatVecMul(T, vec, size); } // T = T * T (희소 곱) List&lt;List&lt;Pair&gt;&gt; newT = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; size; i++) { newT.add(new ArrayList&lt;&gt;()); } for (int i = 0; i &lt; size; i++) { for (Pair kv1 : T.get(i)) { for (Pair kv2 : T.get(kv1.col)) { int val = (int)((1L * kv1.val * kv2.val) % 100003); newT.get(i).add(new Pair(kv2.col, val)); } } } // 중복 열 통합 for (int i = 0; i &lt; size; i++) { if (newT.get(i).isEmpty()) continue; List&lt;Pair&gt; row = newT.get(i); row.sort(Comparator.comparingInt(p -&gt; p.col)); List&lt;Pair&gt; compressed = new ArrayList&lt;&gt;(); int lastCol = -1, sum = 0; for (Pair p : row) { if (p.col == lastCol) { sum = (sum + p.val) % 100003; } else { if (lastCol != -1) compressed.add(new Pair(lastCol, sum)); lastCol = p.col; sum = p.val; } } if (lastCol != -1) compressed.add(new Pair(lastCol, sum)); newT.set(i, compressed); } T = newT; exp &gt;&gt;= 1; } return vec; } 채점 반성 c번에서 계속 시간초과 나길래 C++로 돌려보고 로직 문제란걸 깨닫고 구글링했다. 내 힘으로 풀 수 있는 문제가 아니었다. 수학공부한 셈 쳐야지 뭐. 코드 확인 Link to GitHub]]></summary></entry><entry><title type="html">29348번 Скользкий путь</title><link href="https://movingwoo.com/random-solve/c++/2025/05/16/29348.html" rel="alternate" type="text/html" title="29348번 Скользкий путь" /><published>2025-05-16T06:00:00+00:00</published><updated>2025-05-16T06:00:00+00:00</updated><id>https://movingwoo.com/random-solve/c++/2025/05/16/29348</id><content type="html" xml:base="https://movingwoo.com/random-solve/c++/2025/05/16/29348.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/C++/2025-05-16-29348/img01.jpg" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/29348">29348번 Скользкий путь - 백준</a></p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>앗 러시아어 문제<br />
번역기의 힘을 빌리자…</p>

<p>루크 스카이워커가 어쩌고 하는데 집어치우고 문제의 요지를 파악해야한다.<br />
정사각형으로 이루어진 맵에서 최단 경로를 찾아야하는 문제이다.</p>

<p>이동 조건은 아래와 같다.</p>
<ul>
  <li>지형은 건물, 눈, 얼음 3가지로 이루어져 있으며 칸마다 높이가 존재함</li>
  <li>일반 이동 조건은 아래와 같음
    <ul>
      <li>건물과 건물은 자유롭게 이동 가능</li>
      <li>건물과 눈은 자유롭게 이동 가능</li>
      <li>눈과 눈은 고도가 같거나 낮아야 이동 가능</li>
      <li>눈과 얼음은 고도가 같거나 낮아야 이동 가능</li>
      <li>얼음과 얼음 고도가 같거나 낮아야 이동 가능</li>
    </ul>
  </li>
  <li>특수 이동조건으로 미끄러짐이 존재함
    <ul>
      <li>얼음에서 고도가 낮은 얼음으로 가면 미끄러지기 시작</li>
      <li>다음 칸이 눈이거나 고도가 높은 얼음, 맵 끝이라면 멈춤</li>
      <li>만약 건물을 만나면 충돌해서 실패하는 경로</li>
    </ul>
  </li>
</ul>

<p>출발점에서 도착점까지 최단 경로(칸 수)를 찾아야하며 경로가 존재하지 않으면 Impossible을 출력해야한다.</p>

<p>문제가 좀 머리아픈데…<br />
잘못 걸린 것 같다.</p>

<p>단순히 생각하면 BFS 전략을 통해 최단거리를 찾으면 될 것 같긴 한데<br />
미끄러지는 특수 이동이 문제다.<br />
이거 미끄러지는게 미끄러지는 동안 1칸으로 취급되는건지, 미끄러지는 동안 그 칸을 모두 세어야하는건지…</p>

<p>이 망할 문제 푼 사람도 없어서 모르겠다.<br />
만약 미끄러지는 구간 전체가 1칸으로 취급하는 것 보다 미끄러지는 모든 칸을 세는게 더 코드 짜기 쉬울 것 같아서 그렇게 짜보자.<br />
틀리면 수정해야지.</p>

<p>BFS로 짜보자.</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-입력-받기">1. 입력 받기</h5>

<p>입력 받아서 큐는 초기화 진행한다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">ar</span><span class="p">,</span> <span class="n">ac</span><span class="p">,</span> <span class="n">br</span><span class="p">,</span> <span class="n">bc</span><span class="p">;</span> <span class="c1">// 시작점과 도착점 좌표</span>
<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">ar</span> <span class="o">&gt;&gt;</span> <span class="n">ac</span> <span class="o">&gt;&gt;</span> <span class="n">br</span> <span class="o">&gt;&gt;</span> <span class="n">bc</span><span class="p">;</span>
<span class="n">ar</span><span class="o">--</span><span class="p">;</span> <span class="n">ac</span><span class="o">--</span><span class="p">;</span> <span class="n">br</span><span class="o">--</span><span class="p">;</span> <span class="n">bc</span><span class="o">--</span><span class="p">;</span>

<span class="c1">// 맵에 지형 정보 입력</span>
<span class="n">map</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> 
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// 높이 정보 입력</span>
<span class="n">height</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">));</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">height</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 방문 거리 정보 초기화 (-1은 미방문, 방문 시 거리 저장)</span>
<span class="n">visited</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span> 

<span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="n">ar</span><span class="p">,</span> <span class="n">ac</span><span class="p">});</span> <span class="c1">// 시작점 삽입</span>
<span class="n">visited</span><span class="p">[</span><span class="n">ar</span><span class="p">][</span><span class="n">ac</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 시작점 거리: 0</span>
</code></pre></div></div>

<h5 id="2-bfs-루프">2. BFS 루프</h5>

<p>미끄러지는 특수이동 때문에 경로를 전체 탐색해야한다.<br />
도착점 도달 결과가 없으면 Impossible, 있다면 저장된 거리 수를 출력한다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>

    <span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span> <span class="c1">// 현재 위치</span>

    <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">visited</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">];</span> <span class="c1">// 현재까지 거리</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dir</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">dir</span><span class="p">)</span> <span class="p">{</span> 
        <span class="c1">// 탐색 로직</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 도착점까지 도달했는지 확인</span>
<span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">br</span><span class="p">][</span><span class="n">bc</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Impossible"</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span><span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">visited</span><span class="p">[</span><span class="n">br</span><span class="p">][</span><span class="n">bc</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="3-이동-조건-분기">3. 이동 조건 분기</h5>

<p>루프 내부에 이동조건 분기를 만들어야한다.</p>

<ul>
  <li>건물
    <ul>
      <li>건물 &lt;-&gt; 건물: 자유롭게 이동</li>
      <li>건물 -&gt; 눈: 이동 가능</li>
      <li>건물 &lt;- 눈: 이동 가능</li>
    </ul>
  </li>
  <li>눈
    <ul>
      <li>눈 -&gt; 눈: 높이가 작거나 같을 경우만 가능</li>
      <li>눈 -&gt; 얼음: 높이가 작거나 같을 경우만 가능</li>
      <li>눈 &lt;- 얼음: 높이가 작거나 같을 경우만 가능</li>
    </ul>
  </li>
  <li>얼음
    <ul>
      <li>얼음 -&gt; 눈: 높이가 작거나 같을 경우만 가능</li>
      <li>얼음 -&gt; 얼음 (동일한 높이): 이동 가능</li>
      <li>얼음 -&gt; 얼음 (낮은 높이): 미끄러짐 시작
        <ul>
          <li>정지 조건
            <ul>
              <li>눈 만남</li>
              <li>더 높은 얼음 만남</li>
              <li>지도 경계</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>얼음 -&gt; 건물: 충돌로 무조건 실패 (Impossible)</li>
    </ul>
  </li>
</ul>

<p>헷갈려서 계속 틀린 상황</p>
<ul>
  <li>눈에서 얼음갈때 높이 조건이 =&lt; 인지 &lt; 인지 체크</li>
  <li>눈과 눈 이동도 높이 체크 필요</li>
  <li>얼음에서 이동할때 높이 제대로 체크</li>
  <li>얼음에서 얼음 갈때 높이 같으면 미끄러지는거 아님</li>
  <li>미끄러질때 개박살 조건인 건물 반드시 체크</li>
  <li>건물에서 얼음으로 가는 경우는 조건에 주어져 있지 않음</li>
  <li>어떤 상황에서든 지도 경계 고려</li>
</ul>

<p>얼음에서 미끄러지는 건 제외하고 나머지를 구현한다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="p">[</span><span class="n">dir</span><span class="p">],</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span><span class="p">[</span><span class="n">dir</span><span class="p">];</span> <span class="c1">// 다음 위치</span>

<span class="c1">// 맵 범위 벗어나면 continue</span>
<span class="k">if</span> <span class="p">(</span><span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nx</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">ny</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

<span class="kt">char</span> <span class="n">now</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">],</span> <span class="n">next</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">nowHeight</span> <span class="o">=</span> <span class="n">height</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">],</span> <span class="n">nextHeight</span> <span class="o">=</span> <span class="n">height</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">];</span>

<span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">==</span> <span class="sc">'B'</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="sc">'B'</span> <span class="o">||</span> <span class="n">next</span> <span class="o">==</span> <span class="sc">'S'</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// 건물에서 건물 또는 눈으로 이동</span>
    <span class="n">update</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">==</span> <span class="sc">'S'</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 눈에서 이동</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="sc">'B'</span> <span class="o">||</span> <span class="p">((</span><span class="n">next</span> <span class="o">==</span> <span class="sc">'S'</span> <span class="o">||</span> <span class="n">next</span> <span class="o">==</span> <span class="sc">'I'</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">nextHeight</span> <span class="o">&lt;=</span> <span class="n">nowHeight</span><span class="p">))</span>
        <span class="c1">// 건물이거나 높이 확인</span>
        <span class="n">update</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">==</span> <span class="sc">'I'</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 얼음에서 이동 (건물은 박살나니까 고려 안함)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="sc">'S'</span> <span class="o">&amp;&amp;</span> <span class="n">nextHeight</span> <span class="o">&lt;=</span> <span class="n">nowHeight</span><span class="p">){</span>
        <span class="c1">// 눈으로 이동</span>
        <span class="n">update</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="sc">'I'</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 얼음이면</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nextHeight</span> <span class="o">==</span> <span class="n">nowHeight</span><span class="p">){</span>
            <span class="c1">// 높이 같으면 이동</span>
            <span class="n">update</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">nextHeight</span> <span class="o">&lt;</span> <span class="n">nowHeight</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 미끄러지는 로직</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="4-미끄러짐">4. 미끄러짐</h5>

<p>미끄러질 경우 이동 방향으로 멈출때까지 전진한다.<br />
멈추는 조건까지 전진하며 거리를 채우고 건물에 박는 경로는 폐기한다.<br />
미끄러지는 동안은 while문으로 끝날 때까지 반복한다.</p>

<p>예제를 테스트 해보면 미끄러질 경우 지나간 칸 만큼 거리로 쳐주기 때문에 칸 수를 정확하게 체크해야한다.<br />
건물에 부딪히면 박살나기 때문에 경로 폐기를 위한 불 값을 마련해준다.</p>

<p>정지 조건에 맞춰 정지했을 경우에 도착지점과 미끄러진 거리를 업데이트한다.<br />
미끄러지는 도중은 정상적인 착지가 아니라 의미 없으므로 visited 갱신을 하지 않는다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 미끄러지기 시작</span>
<span class="kt">int</span> <span class="n">slide</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 이동 거리</span>
<span class="kt">bool</span> <span class="n">isBuilding</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 건물 충돌 박살 여부</span>
<span class="kt">int</span> <span class="n">ox</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">oy</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>

<span class="c1">// 계속 미끄러지기</span>
<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nx</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">ny</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 맵 벗어나면 멈춤</span>
        <span class="k">break</span><span class="p">;</span> 
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'B'</span><span class="p">)</span> <span class="p">{</span> 
        <span class="c1">// 건물 부딪히면 상태 업데이트하고 break</span>
        <span class="n">isBuilding</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> 
        <span class="k">break</span><span class="p">;</span> 
    <span class="p">}</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'I'</span> <span class="o">||</span> <span class="n">height</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">height</span><span class="p">[</span><span class="n">ox</span><span class="p">][</span><span class="n">oy</span><span class="p">]){</span>
        <span class="c1">// 얼음이 아니고 높이가 높으면 정지</span>
        <span class="k">break</span><span class="p">;</span> 
    <span class="p">}</span> 

    <span class="n">ox</span> <span class="o">=</span> <span class="n">nx</span><span class="p">;</span> 
    <span class="n">oy</span> <span class="o">=</span> <span class="n">ny</span><span class="p">;</span> 
    <span class="n">nx</span> <span class="o">+=</span> <span class="n">dx</span><span class="p">[</span><span class="n">dir</span><span class="p">];</span> 
    <span class="n">ny</span> <span class="o">+=</span> <span class="n">dy</span><span class="p">[</span><span class="n">dir</span><span class="p">];</span>

    <span class="n">slide</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 멈췄으면 실제 멈춘 위치로 보정</span>
<span class="n">nx</span> <span class="o">-=</span> <span class="n">dx</span><span class="p">[</span><span class="n">dir</span><span class="p">];</span> 
<span class="n">ny</span> <span class="o">-=</span> <span class="n">dy</span><span class="p">[</span><span class="n">dir</span><span class="p">];</span> 
<span class="n">slide</span><span class="o">--</span><span class="p">;</span>

<span class="c1">// 맵 범위, 건물 체크</span>
<span class="k">if</span> <span class="p">((</span><span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nx</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">ny</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'B'</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 정상적으로 멈추면 업데이트</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isBuilding</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'B'</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">update</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">slide</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/C++/2025-05-16-29348/img02.jpg" alt="img02" /></p>

<p><span style="color: red;"><strong>거지같은 문제 내가 해냈어 해냈다구</strong></span></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>계속 틀려서 BFS가 아니라 다익스트라에 가까워졌다.<br />
미끄러지는 부분 고려하는게 너무 어려웠다.</p>

<p>아무래도 컨텐츠 잘못 만든 것 같다.<br />
너무 지독한 문제에 걸려 오래 고생했다.<br />
좀 쉬어야겠다.</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/random-solve/C%2B%2B/2025-05-16-29348.cpp">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="random-solve/C++/" /><summary type="html"><![CDATA[문제 29348번 Скользкий путь - 백준 설계 앗 러시아어 문제 번역기의 힘을 빌리자… 루크 스카이워커가 어쩌고 하는데 집어치우고 문제의 요지를 파악해야한다. 정사각형으로 이루어진 맵에서 최단 경로를 찾아야하는 문제이다. 이동 조건은 아래와 같다. 지형은 건물, 눈, 얼음 3가지로 이루어져 있으며 칸마다 높이가 존재함 일반 이동 조건은 아래와 같음 건물과 건물은 자유롭게 이동 가능 건물과 눈은 자유롭게 이동 가능 눈과 눈은 고도가 같거나 낮아야 이동 가능 눈과 얼음은 고도가 같거나 낮아야 이동 가능 얼음과 얼음 고도가 같거나 낮아야 이동 가능 특수 이동조건으로 미끄러짐이 존재함 얼음에서 고도가 낮은 얼음으로 가면 미끄러지기 시작 다음 칸이 눈이거나 고도가 높은 얼음, 맵 끝이라면 멈춤 만약 건물을 만나면 충돌해서 실패하는 경로 출발점에서 도착점까지 최단 경로(칸 수)를 찾아야하며 경로가 존재하지 않으면 Impossible을 출력해야한다. 문제가 좀 머리아픈데… 잘못 걸린 것 같다. 단순히 생각하면 BFS 전략을 통해 최단거리를 찾으면 될 것 같긴 한데 미끄러지는 특수 이동이 문제다. 이거 미끄러지는게 미끄러지는 동안 1칸으로 취급되는건지, 미끄러지는 동안 그 칸을 모두 세어야하는건지… 이 망할 문제 푼 사람도 없어서 모르겠다. 만약 미끄러지는 구간 전체가 1칸으로 취급하는 것 보다 미끄러지는 모든 칸을 세는게 더 코드 짜기 쉬울 것 같아서 그렇게 짜보자. 틀리면 수정해야지. BFS로 짜보자. 구현 1. 입력 받기 입력 받아서 큐는 초기화 진행한다. int ar, ac, br, bc; // 시작점과 도착점 좌표 cin &gt;&gt; n &gt;&gt; m; cin &gt;&gt; ar &gt;&gt; ac &gt;&gt; br &gt;&gt; bc; ar--; ac--; br--; bc--; // 맵에 지형 정보 입력 map.resize(n); for (int i = 0 ; i &lt; n ; i++) { cin &gt;&gt; map[i]; } // 높이 정보 입력 height.assign(n, vector&lt;int&gt;(m)); for (int i = 0 ; i &lt; n ; i++) { for (int j = 0 ; j &lt; m ; j++) { cin &gt;&gt; height[i][j]; } } // 방문 거리 정보 초기화 (-1은 미방문, 방문 시 거리 저장) visited.assign(n, vector&lt;int&gt;(m, -1)); que.push({ar, ac}); // 시작점 삽입 visited[ar][ac] = 0; // 시작점 거리: 0 2. BFS 루프 미끄러지는 특수이동 때문에 경로를 전체 탐색해야한다. 도착점 도달 결과가 없으면 Impossible, 있다면 저장된 거리 수를 출력한다. while (!que.empty()) { int x, y; x = get&lt;0&gt;(que.front()); y = get&lt;1&gt;(que.front()); que.pop(); // 현재 위치 int d = visited[x][y]; // 현재까지 거리 for (int dir = 0; dir &lt; 4; ++dir) { // 탐색 로직 } } // 도착점까지 도달했는지 확인 if (visited[br][bc] &lt; 0){ cout &lt;&lt; "Impossible"; } else{ cout &lt;&lt; visited[br][bc]; } 3. 이동 조건 분기 루프 내부에 이동조건 분기를 만들어야한다. 건물 건물 &lt;-&gt; 건물: 자유롭게 이동 건물 -&gt; 눈: 이동 가능 건물 &lt;- 눈: 이동 가능 눈 눈 -&gt; 눈: 높이가 작거나 같을 경우만 가능 눈 -&gt; 얼음: 높이가 작거나 같을 경우만 가능 눈 &lt;- 얼음: 높이가 작거나 같을 경우만 가능 얼음 얼음 -&gt; 눈: 높이가 작거나 같을 경우만 가능 얼음 -&gt; 얼음 (동일한 높이): 이동 가능 얼음 -&gt; 얼음 (낮은 높이): 미끄러짐 시작 정지 조건 눈 만남 더 높은 얼음 만남 지도 경계 얼음 -&gt; 건물: 충돌로 무조건 실패 (Impossible) 헷갈려서 계속 틀린 상황 눈에서 얼음갈때 높이 조건이 =&lt; 인지 &lt; 인지 체크 눈과 눈 이동도 높이 체크 필요 얼음에서 이동할때 높이 제대로 체크 얼음에서 얼음 갈때 높이 같으면 미끄러지는거 아님 미끄러질때 개박살 조건인 건물 반드시 체크 건물에서 얼음으로 가는 경우는 조건에 주어져 있지 않음 어떤 상황에서든 지도 경계 고려 얼음에서 미끄러지는 건 제외하고 나머지를 구현한다. int nx = x + dx[dir], ny = y + dy[dir]; // 다음 위치 // 맵 범위 벗어나면 continue if (nx &lt; 0 || ny &lt; 0 || nx &gt;= n || ny &gt;= m) continue; char now = map[x][y], next = map[nx][ny]; int nowHeight = height[x][y], nextHeight = height[nx][ny]; if (now == 'B' &amp;&amp; (next == 'B' || next == 'S')) { // 건물에서 건물 또는 눈으로 이동 update(nx, ny, 1, d); } else if (now == 'S') { // 눈에서 이동 if (next == 'B' || ((next == 'S' || next == 'I') &amp;&amp; nextHeight &lt;= nowHeight)) // 건물이거나 높이 확인 update(nx, ny, 1, d); } else if (now == 'I') { // 얼음에서 이동 (건물은 박살나니까 고려 안함) if (next == 'S' &amp;&amp; nextHeight &lt;= nowHeight){ // 눈으로 이동 update(nx, ny, 1, d); } else if (next == 'I') { // 얼음이면 if (nextHeight == nowHeight){ // 높이 같으면 이동 update(nx, ny, 1, d); } else if (nextHeight &lt; nowHeight) { // 미끄러지는 로직 } } } 4. 미끄러짐 미끄러질 경우 이동 방향으로 멈출때까지 전진한다. 멈추는 조건까지 전진하며 거리를 채우고 건물에 박는 경로는 폐기한다. 미끄러지는 동안은 while문으로 끝날 때까지 반복한다. 예제를 테스트 해보면 미끄러질 경우 지나간 칸 만큼 거리로 쳐주기 때문에 칸 수를 정확하게 체크해야한다. 건물에 부딪히면 박살나기 때문에 경로 폐기를 위한 불 값을 마련해준다. 정지 조건에 맞춰 정지했을 경우에 도착지점과 미끄러진 거리를 업데이트한다. 미끄러지는 도중은 정상적인 착지가 아니라 의미 없으므로 visited 갱신을 하지 않는다. // 미끄러지기 시작 int slide = 1; // 이동 거리 bool isBuilding = false; // 건물 충돌 박살 여부 int ox = x, oy = y; // 계속 미끄러지기 while (true) { if (nx &lt; 0 || ny &lt; 0 || nx &gt;= n || ny &gt;= m) { // 맵 벗어나면 멈춤 break; } if (map[nx][ny] == 'B') { // 건물 부딪히면 상태 업데이트하고 break isBuilding = true; break; } if (map[nx][ny] != 'I' || height[nx][ny] &gt; height[ox][oy]){ // 얼음이 아니고 높이가 높으면 정지 break; } ox = nx; oy = ny; nx += dx[dir]; ny += dy[dir]; slide++; } // 멈췄으면 실제 멈춘 위치로 보정 nx -= dx[dir]; ny -= dy[dir]; slide--; // 맵 범위, 건물 체크 if ((nx &lt; 0 || ny &lt; 0 || nx &gt;= n || ny &gt;= m) || (map[nx][ny] == 'B')) { continue; } // 정상적으로 멈추면 업데이트 if (!isBuilding &amp;&amp; map[nx][ny] != 'B') { update(nx, ny, slide, d); } 채점 거지같은 문제 내가 해냈어 해냈다구 반성 계속 틀려서 BFS가 아니라 다익스트라에 가까워졌다. 미끄러지는 부분 고려하는게 너무 어려웠다. 아무래도 컨텐츠 잘못 만든 것 같다. 너무 지독한 문제에 걸려 오래 고생했다. 좀 쉬어야겠다. 코드 확인 Link to GitHub]]></summary></entry><entry><title type="html">18382번 2048</title><link href="https://movingwoo.com/random-solve/python/2025/05/15/18382.html" rel="alternate" type="text/html" title="18382번 2048" /><published>2025-05-15T02:00:00+00:00</published><updated>2025-05-15T02:00:00+00:00</updated><id>https://movingwoo.com/random-solve/python/2025/05/15/18382</id><content type="html" xml:base="https://movingwoo.com/random-solve/python/2025/05/15/18382.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Python/2025-05-15-18382/img01.jpg" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/18382">18382번 2048 - 백준</a></p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>앗 영어문제</p>

<p>2048 게임의 최종 점수를 출력하는 문제이다.<br />
입력으로 앞으로의 움직임과 나타날 블럭이 주어지므로 시뮬레이션만 잘하면 되는 문제다.<br />
4x4 배열을 만들고 움직임에 따라 타일을 조작하며 합쳐지면 점수에 그만큼 더해준다.</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-입력-받기">1. 입력 받기</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">score</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>

<span class="c1"># 무빙
</span><span class="n">moving_input</span> <span class="o">=</span> <span class="nf">input</span><span class="p">()</span>
<span class="n">moving</span> <span class="o">=</span> <span class="p">[</span><span class="n">moving_input</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">moving_input</span><span class="p">),</span> <span class="mi">4</span><span class="p">)]</span>

<span class="c1"># 현재 판
</span><span class="n">board_input</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">()))</span>
<span class="n">board</span> <span class="o">=</span> <span class="p">[</span><span class="n">board_input</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
</code></pre></div></div>

<h5 id="2-입력-파싱">2. 입력 파싱</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 무빙만큼 반복
</span><span class="k">for</span> <span class="n">move</span> <span class="ow">in</span> <span class="n">moving</span><span class="p">:</span>
    <span class="nb">dir</span> <span class="o">=</span> <span class="n">move</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">value</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">move</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">x</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">move</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">move</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

    <span class="n">board</span><span class="p">,</span> <span class="n">gained</span> <span class="o">=</span> <span class="nf">move_board</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="nb">dir</span><span class="p">)</span>
    <span class="n">score</span> <span class="o">+=</span> <span class="n">gained</span>

    <span class="n">board</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

<span class="nf">print</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
</code></pre></div></div>

<h5 id="3-실제-무빙-로직">3. 실제 무빙 로직</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">move_board</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="nb">dir</span><span class="p">):</span>
    <span class="n">gained</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># 방향에 따라 움직일 방향 설정
</span>    <span class="n">dir_delta</span> <span class="o">=</span> <span class="p">{</span>
        <span class="sh">'</span><span class="s">U</span><span class="sh">'</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
        <span class="sh">'</span><span class="s">D</span><span class="sh">'</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="sh">'</span><span class="s">L</span><span class="sh">'</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="sh">'</span><span class="s">R</span><span class="sh">'</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">dir_delta</span><span class="p">[</span><span class="nb">dir</span><span class="p">]</span>

    <span class="c1"># 병합 여부 확인
</span>    <span class="n">merged</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">False</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>

    <span class="c1"># 벽은 무시하고 탐색해야해서 이동 순서 조정
</span>    <span class="n">range_x</span> <span class="o">=</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">range_y</span> <span class="o">=</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">dir</span> <span class="o">==</span> <span class="sh">'</span><span class="s">R</span><span class="sh">'</span><span class="p">:</span>
        <span class="n">range_x</span> <span class="o">=</span> <span class="nf">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">dir</span> <span class="o">==</span> <span class="sh">'</span><span class="s">D</span><span class="sh">'</span><span class="p">:</span>
        <span class="n">range_y</span> <span class="o">=</span> <span class="nf">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">dir</span> <span class="o">==</span> <span class="sh">'</span><span class="s">L</span><span class="sh">'</span><span class="p">:</span>
        <span class="n">range_x</span> <span class="o">=</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">dir</span> <span class="o">==</span> <span class="sh">'</span><span class="s">U</span><span class="sh">'</span><span class="p">:</span>
        <span class="n">range_y</span> <span class="o">=</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

    <span class="c1"># 설정 범위내 무빙
</span>    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">range_y</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">range_x</span><span class="p">:</span>
            <span class="c1"># 0이면 무시
</span>            <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># 현재 좌표
</span>            <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="c1"># 목표 좌표
</span>                <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">cx</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">+</span> <span class="n">dy</span>

                <span class="c1"># 벽 만나면 중단
</span>                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">):</span>
                    <span class="k">break</span>

                <span class="c1"># 빈 칸이면 이동
</span>                <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">board</span><span class="p">[</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]</span> <span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="n">cy</span><span class="p">][</span><span class="n">cx</span><span class="p">]</span>
                    <span class="n">board</span><span class="p">[</span><span class="n">cy</span><span class="p">][</span><span class="n">cx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span>

                <span class="c1"># 같은 숫자 + 병합 안 됐으면 합치기
</span>                <span class="k">elif</span> <span class="n">board</span><span class="p">[</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]</span> <span class="o">==</span> <span class="n">board</span><span class="p">[</span><span class="n">cy</span><span class="p">][</span><span class="n">cx</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">merged</span><span class="p">[</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]:</span>
                    <span class="n">board</span><span class="p">[</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span>
                    <span class="n">board</span><span class="p">[</span><span class="n">cy</span><span class="p">][</span><span class="n">cx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">merged</span><span class="p">[</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">gained</span> <span class="o">+=</span> <span class="n">board</span><span class="p">[</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]</span>
                    <span class="k">break</span>
                <span class="c1"># 다른 숫자면 무시
</span>                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
    
    <span class="k">return</span> <span class="n">board</span><span class="p">,</span> <span class="n">gained</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Python/2025-05-15-18382/img02.jpg" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>4X4 보드에 좌표계산하며 시뮬레이션 하는 식으로 해결했는데 파이썬에서는 좌표계산보다 줄단위 처리가 낫다고 한다.<br />
<span style="color: orange;"><strong>파이썬의 자료구조와 문법은 좌표 반복보단 리스트 전체 조작에 강력하게 최적화돼 있기 때문</strong></span>이라고<br />
리스트가 가변 배열이고 병합, 필터링 등 기능이 내장되어 있다고 한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">slide_left</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
    <span class="n">new_row</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">row</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
    <span class="c1"># 병합 처리
</span>    <span class="bp">...</span>
    <span class="k">return</span> <span class="n">new_row</span>
</code></pre></div></div>

<p>이런 식으로 해결할 수 있다고…</p>

<p>2중 반복문을 안써도 되고 코드가 단순해지며 보드 회전을 통해 슬라이드 함수 하나로 처리도 가능하다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">transpose</span> <span class="o">=</span> <span class="p">[</span><span class="nf">list</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="o">*</span><span class="n">board</span><span class="p">)]</span>  <span class="c1"># 전치 행렬
</span><span class="n">reversed_board</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">board</span><span class="p">]</span>   <span class="c1"># 행 반전
</span></code></pre></div></div>

<p>c나 java와는 좀 다르다.<br />
파이썬 고수가 되려면 한참 멀었다.</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/random-solve/Python/2025-05-15-18382.py">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="random-solve/Python/" /><summary type="html"><![CDATA[문제 18382번 2048 - 백준 설계 앗 영어문제 2048 게임의 최종 점수를 출력하는 문제이다. 입력으로 앞으로의 움직임과 나타날 블럭이 주어지므로 시뮬레이션만 잘하면 되는 문제다. 4x4 배열을 만들고 움직임에 따라 타일을 조작하며 합쳐지면 점수에 그만큼 더해준다. 구현 1. 입력 받기 score = int(input()) # 무빙 moving_input = input() moving = [moving_input[i:i+4] for i in range(0, len(moving_input), 4)] # 현재 판 board_input = list(map(int, input().split())) board = [board_input[i*4:(i+1)*4] for i in range(4)] 2. 입력 파싱 # 무빙만큼 반복 for move in moving: dir = move[0] value = int(move[1]) x = int(move[2]) y = int(move[3]) board, gained = move_board(board, dir) score += gained board[x][y] = value print(score) 3. 실제 무빙 로직 def move_board(board, dir): gained = 0 # 방향에 따라 움직일 방향 설정 dir_delta = { 'U': (0, -1), 'D': (0, 1), 'L': (-1, 0), 'R': (1, 0), } dx, dy = dir_delta[dir] # 병합 여부 확인 merged = [[False]*4 for _ in range(4)] # 벽은 무시하고 탐색해야해서 이동 순서 조정 range_x = range(4) range_y = range(4) if dir == 'R': range_x = range(2, -1, -1) if dir == 'D': range_y = range(2, -1, -1) if dir == 'L': range_x = range(1, 4) if dir == 'U': range_y = range(1, 4) # 설정 범위내 무빙 for y in range_y: for x in range_x: # 0이면 무시 if board[y][x] == 0: continue # 현재 좌표 cx, cy = x, y while True: # 목표 좌표 nx, ny = cx + dx, cy + dy # 벽 만나면 중단 if not (0 &lt;= nx &lt; 4 and 0 &lt;= ny &lt; 4): break # 빈 칸이면 이동 if board[ny][nx] == 0: board[ny][nx] = board[cy][cx] board[cy][cx] = 0 cx, cy = nx, ny # 같은 숫자 + 병합 안 됐으면 합치기 elif board[ny][nx] == board[cy][cx] and not merged[ny][nx]: board[ny][nx] *= 2 board[cy][cx] = 0 merged[ny][nx] = True gained += board[ny][nx] break # 다른 숫자면 무시 else: break return board, gained 채점 반성 4X4 보드에 좌표계산하며 시뮬레이션 하는 식으로 해결했는데 파이썬에서는 좌표계산보다 줄단위 처리가 낫다고 한다. 파이썬의 자료구조와 문법은 좌표 반복보단 리스트 전체 조작에 강력하게 최적화돼 있기 때문이라고 리스트가 가변 배열이고 병합, 필터링 등 기능이 내장되어 있다고 한다. def slide_left(row): new_row = [x for x in row if x != 0] # 병합 처리 ... return new_row 이런 식으로 해결할 수 있다고… 2중 반복문을 안써도 되고 코드가 단순해지며 보드 회전을 통해 슬라이드 함수 하나로 처리도 가능하다. transpose = [list(row) for row in zip(*board)] # 전치 행렬 reversed_board = [row[::-1] for row in board] # 행 반전 c나 java와는 좀 다르다. 파이썬 고수가 되려면 한참 멀었다. 코드 확인 Link to GitHub]]></summary></entry><entry><title type="html">랜덤 출력기</title><link href="https://movingwoo.com/one-pan/javascript/2025/05/14/Random-Printer.html" rel="alternate" type="text/html" title="랜덤 출력기" /><published>2025-05-14T23:00:00+00:00</published><updated>2025-05-14T23:00:00+00:00</updated><id>https://movingwoo.com/one-pan/javascript/2025/05/14/Random%20Printer</id><content type="html" xml:base="https://movingwoo.com/one-pan/javascript/2025/05/14/Random-Printer.html"><![CDATA[<blockquote>
  <h4 id="개요">개요</h4>
  <hr />
</blockquote>

<p>백준 랜덤 문제를 랜덤 언어로 푸는 포스팅을 작성하려는데<br />
랜덤 뽑아내는 기능이 필요해서 자급자족함</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-설계">1. 설계</h5>

<p>백준에 문제가 몇개나 되지?
현시점 전체 문제는 3만개 이상으로 나온다.<br />
웹 크롤링을 통해 최대 숫자를 정할 수 있겠으나 굳이 이딴데 크롤링까지?<br />
최소 1000부터 최대 숫자 지정해서 랜덤 문제 번호를 뽑아내면 되겠다.</p>

<p>언어는 72종 지원한다는데 내가 할 수 있는 언어만 나와야한다.<br />
대충 java, c++, python 3종으로만 하자.</p>

<h5 id="2-html-세팅">2. HTML 세팅</h5>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"ko"</span><span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;</span>
  <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"UTF-8"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;title&gt;</span>랜덤 출력기<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
  <span class="nt">&lt;h1&gt;</span>랜덤 출력기<span class="nt">&lt;/h1&gt;</span>

  <span class="nt">&lt;label</span> <span class="na">for=</span><span class="s">"maxNumber"</span><span class="nt">&gt;</span>최대 숫자 입력 (최소는 1000 고정): <span class="nt">&lt;/label&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"number"</span> <span class="na">id=</span><span class="s">"maxNumber"</span> <span class="na">min=</span><span class="s">"1000"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;button</span> <span class="na">onclick=</span><span class="s">"generateRandomNumbers()"</span><span class="nt">&gt;</span>생성하기<span class="nt">&lt;/button&gt;</span>

  <span class="nt">&lt;h3&gt;</span>결과<span class="nt">&lt;/h3&gt;</span>
  <span class="nt">&lt;p&gt;</span>문제 번호: <span class="nt">&lt;span</span> <span class="na">id=</span><span class="s">"randomNumber"</span><span class="nt">&gt;&lt;/span&gt;&lt;/p&gt;</span>
  <span class="nt">&lt;p&gt;</span>언어: <span class="nt">&lt;span</span> <span class="na">id=</span><span class="s">"randomLanguage"</span><span class="nt">&gt;&lt;/span&gt;&lt;/p&gt;</span>

  <span class="nt">&lt;script&gt;</span>
    <span class="c1">// 스크립트</span>
    <span class="c1">// 언어는 1부터 3까지 랜덤 뽑고 각 숫자에 할당</span>
  <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<h5 id="3-스크립트-작성">3. 스크립트 작성</h5>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">generateRandomNumbers</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">min</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">max</span> <span class="o">=</span> <span class="nf">parseInt</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">#maxNumber</span><span class="dl">'</span><span class="p">).</span><span class="nx">value</span><span class="p">);</span>

  <span class="c1">// 최대 숫자 예외처리</span>
  <span class="k">if </span><span class="p">(</span><span class="nf">isNaN</span><span class="p">(</span><span class="nx">max</span><span class="p">)</span> <span class="o">||</span> <span class="nx">max</span> <span class="o">&lt;</span> <span class="nx">min</span><span class="p">)</span> <span class="p">{</span>
      <span class="nf">alert</span><span class="p">(</span><span class="dl">"</span><span class="s2">최소 1000 이상 숫자 입력</span><span class="dl">"</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 랜덤 숫자 추출</span>
  <span class="kd">const</span> <span class="nx">randomNum</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">max</span> <span class="o">-</span> <span class="nx">min</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="nx">min</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">randomLang</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

  <span class="c1">// 결과란에 배치</span>
  <span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">#randomNumber</span><span class="dl">'</span><span class="p">).</span><span class="nx">textContent</span> <span class="o">=</span> <span class="nx">randomNum</span><span class="p">;</span>
  <span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">#randomLanguage</span><span class="dl">'</span><span class="p">).</span><span class="nx">textContent</span> <span class="o">=</span> <span class="nx">randomLang</span> <span class="o">===</span> <span class="mi">1</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">java</span><span class="dl">'</span> <span class="p">:</span> <span class="nx">randomLang</span> <span class="o">===</span> <span class="mi">2</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">c++</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">python</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="완성">완성</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/one-pan/JavaScript/2025-05-15-Random Printer/img01.jpg" alt="img01" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>딱히?</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="/play/Random%20Printer.html" target="_blank" rel="noopener noreferrer">
  직접 해보기
</a></p>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-15-Random%20Printer.html">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="one-pan/JavaScript/" /><summary type="html"><![CDATA[개요 백준 랜덤 문제를 랜덤 언어로 푸는 포스팅을 작성하려는데 랜덤 뽑아내는 기능이 필요해서 자급자족함 구현 1. 설계 백준에 문제가 몇개나 되지? 현시점 전체 문제는 3만개 이상으로 나온다. 웹 크롤링을 통해 최대 숫자를 정할 수 있겠으나 굳이 이딴데 크롤링까지? 최소 1000부터 최대 숫자 지정해서 랜덤 문제 번호를 뽑아내면 되겠다. 언어는 72종 지원한다는데 내가 할 수 있는 언어만 나와야한다. 대충 java, c++, python 3종으로만 하자. 2. HTML 세팅 &lt;!DOCTYPE html&gt; &lt;html lang="ko"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;랜덤 출력기&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;랜덤 출력기&lt;/h1&gt; &lt;label for="maxNumber"&gt;최대 숫자 입력 (최소는 1000 고정): &lt;/label&gt; &lt;input type="number" id="maxNumber" min="1000"&gt; &lt;button onclick="generateRandomNumbers()"&gt;생성하기&lt;/button&gt; &lt;h3&gt;결과&lt;/h3&gt; &lt;p&gt;문제 번호: &lt;span id="randomNumber"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;언어: &lt;span id="randomLanguage"&gt;&lt;/span&gt;&lt;/p&gt; &lt;script&gt; // 스크립트 // 언어는 1부터 3까지 랜덤 뽑고 각 숫자에 할당 &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 3. 스크립트 작성 function generateRandomNumbers() { const min = 1000; const max = parseInt(document.querySelector('#maxNumber').value); // 최대 숫자 예외처리 if (isNaN(max) || max &lt; min) { alert("최소 1000 이상 숫자 입력"); return; } // 랜덤 숫자 추출 const randomNum = Math.floor(Math.random() * (max - min + 1)) + min; const randomLang = Math.floor(Math.random() * 3) + 1; // 결과란에 배치 document.querySelector('#randomNumber').textContent = randomNum; document.querySelector('#randomLanguage').textContent = randomLang === 1 ? 'java' : randomLang === 2 ? 'c++' : 'python'; } 완성 반성 딱히? 코드 확인 직접 해보기 Link to GitHub]]></summary></entry><entry><title type="html">파이썬으로 CLI TODO 리스트 만들어보기</title><link href="https://movingwoo.com/ai-playground/gpt/2025/05/14/GPT.html" rel="alternate" type="text/html" title="파이썬으로 CLI TODO 리스트 만들어보기" /><published>2025-05-14T05:00:00+00:00</published><updated>2025-05-14T05:00:00+00:00</updated><id>https://movingwoo.com/ai-playground/gpt/2025/05/14/GPT</id><content type="html" xml:base="https://movingwoo.com/ai-playground/gpt/2025/05/14/GPT.html"><![CDATA[<p><span style="color: red;"><strong>본 포스트는 AI가 제작한 포스트입니다.</strong></span><br />
<span style="color: orange;">명령: (지금까지 작성한 포스트를 학습 시킨 후) 유사한 양식과 주제로 포스트를 한 번 써봐.</span></p>

<hr />

<h1 id="파이썬으로-cli-todo-리스트-만들어보기">파이썬으로 CLI TODO 리스트 만들어보기</h1>

<p>요즘도 종이에 할 일 적고 잊는 사람?<br />
나는 그랬다. 매일 “뭐 하지?” 하면서 검색창에 TODO 쳐보다가,<br />
아니 그냥 내가 하나 만들자 싶어서 만든, <strong>CLI 기반 TODO 리스트</strong>.</p>

<hr />

<h2 id="만들게-된-이유">만들게 된 이유</h2>

<p>회사에서 쓸 일은 없는데,<br />
일정 관리 앱이 너무 무겁기도 하고…<br />
매일 아침에 <code class="language-plaintext highlighter-rouge">python todo.py</code> 딱 치면 오늘 할 일 쭉 나오면 좋겠더라구.</p>

<hr />

<h2 id="주요-기능">주요 기능</h2>

<ul>
  <li>할 일 추가 / 삭제</li>
  <li>완료 체크</li>
  <li>날짜 기준 정렬</li>
  <li>json 파일에 저장</li>
</ul>

<hr />

<h2 id="코드-요약">코드 요약</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">json</span>
<span class="kn">from</span> <span class="n">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>

<span class="n">FILE</span> <span class="o">=</span> <span class="sh">"</span><span class="s">todo.json</span><span class="sh">"</span>

<span class="k">def</span> <span class="nf">load_tasks</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="n">FILE</span><span class="p">,</span> <span class="sh">"</span><span class="s">r</span><span class="sh">"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">json</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">FileNotFoundError</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">save_tasks</span><span class="p">(</span><span class="n">tasks</span><span class="p">):</span>
    <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="n">FILE</span><span class="p">,</span> <span class="sh">"</span><span class="s">w</span><span class="sh">"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">json</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="n">tasks</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">add_task</span><span class="p">(</span><span class="n">title</span><span class="p">):</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="nf">load_tasks</span><span class="p">()</span>
    <span class="n">task</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">title</span><span class="sh">"</span><span class="p">:</span> <span class="n">title</span><span class="p">,</span> <span class="sh">"</span><span class="s">done</span><span class="sh">"</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span> <span class="sh">"</span><span class="s">created_at</span><span class="sh">"</span><span class="p">:</span> <span class="n">datetime</span><span class="p">.</span><span class="nf">now</span><span class="p">().</span><span class="nf">isoformat</span><span class="p">()}</span>
    <span class="n">tasks</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
    <span class="nf">save_tasks</span><span class="p">(</span><span class="n">tasks</span><span class="p">)</span>
</code></pre></div></div>

<p>전체 코드는 GitHub에 올려둠:<br />
→ <span style="color: red;"><strong>– AI가 생성한 가짜 링크라 제거함 –</strong></span></p>

<hr />

<h2 id="사용법">사용법</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python todo.py add <span class="s2">"블로그 글쓰기"</span>
<span class="nv">$ </span>python todo.py list
</code></pre></div></div>

<hr />

<h2 id="만들면서-느낀-점">만들면서 느낀 점</h2>

<ul>
  <li>생각보다 CLI 만들 때도 UX 고려할 게 많다.</li>
  <li>파일 저장하는 방식도 JSON 외에 sqlite 도 고민했는데 너무 무거워서 패스.</li>
  <li>argparse 안 쓰고 직접 파싱한 거 약간 후회.</li>
</ul>

<hr />

<h2 id="다음에-해보고-싶은-것">다음에 해보고 싶은 것</h2>

<ul>
  <li>GUI 버전도 PyQt나 tkinter로?</li>
  <li>정기 알림 기능 추가</li>
  <li>Windows에서도 동작 잘 되게 exe 빌드</li>
</ul>

<blockquote>
  <h4 id="내-생각">내 생각</h4>
  <hr />
</blockquote>

<p>말투 흉내내려고 애쓴건 장한데<br />
애초에 저 코드 돌아가지도 않을거다.<br />
진입점도 없는걸?</p>

<p>해당 부분의 코드를 실제 사용할 수 있게 다시 GPT에게 요청했다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">json</span>
<span class="kn">import</span> <span class="n">sys</span>
<span class="kn">from</span> <span class="n">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>

<span class="n">FILE</span> <span class="o">=</span> <span class="sh">"</span><span class="s">todo.json</span><span class="sh">"</span>

<span class="k">def</span> <span class="nf">load_tasks</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="n">FILE</span><span class="p">,</span> <span class="sh">"</span><span class="s">r</span><span class="sh">"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">json</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">FileNotFoundError</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">save_tasks</span><span class="p">(</span><span class="n">tasks</span><span class="p">):</span>
    <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="n">FILE</span><span class="p">,</span> <span class="sh">"</span><span class="s">w</span><span class="sh">"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">json</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="n">tasks</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">add_task</span><span class="p">(</span><span class="n">title</span><span class="p">):</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="nf">load_tasks</span><span class="p">()</span>
    <span class="n">task</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">title</span><span class="sh">"</span><span class="p">:</span> <span class="n">title</span><span class="p">,</span> <span class="sh">"</span><span class="s">done</span><span class="sh">"</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span> <span class="sh">"</span><span class="s">created_at</span><span class="sh">"</span><span class="p">:</span> <span class="n">datetime</span><span class="p">.</span><span class="nf">now</span><span class="p">().</span><span class="nf">isoformat</span><span class="p">()}</span>
    <span class="n">tasks</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
    <span class="nf">save_tasks</span><span class="p">(</span><span class="n">tasks</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">할 일 추가됨: </span><span class="si">{</span><span class="n">title</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">list_tasks</span><span class="p">():</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="nf">load_tasks</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">tasks</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">할 일이 없음.</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">task</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">tasks</span><span class="p">):</span>
        <span class="n">status</span> <span class="o">=</span> <span class="sh">"</span><span class="s">✔</span><span class="sh">"</span> <span class="k">if</span> <span class="n">task</span><span class="p">[</span><span class="sh">"</span><span class="s">done</span><span class="sh">"</span><span class="p">]</span> <span class="k">else</span> <span class="sh">"</span><span class="s">✘</span><span class="sh">"</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s">. [</span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s">] </span><span class="si">{</span><span class="n">task</span><span class="p">[</span><span class="sh">'</span><span class="s">title</span><span class="sh">'</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">사용법: python todo.py add &lt;내용&gt; | list</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">sys</span><span class="p">.</span><span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">command</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">command</span> <span class="o">==</span> <span class="sh">"</span><span class="s">add</span><span class="sh">"</span> <span class="ow">and</span> <span class="nf">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="nf">add_task</span><span class="p">(</span><span class="sh">"</span><span class="s"> </span><span class="sh">"</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">:]))</span>
    <span class="k">elif</span> <span class="n">command</span> <span class="o">==</span> <span class="sh">"</span><span class="s">list</span><span class="sh">"</span><span class="p">:</span>
        <span class="nf">list_tasks</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">지원하지 않는 명령어.</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>실제 테스트 해보면 아래와 같다.</p>

<div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">python</span> <span class="kd">todo</span>.py <span class="kd">add</span> <span class="s2">"tteesstt"</span>
할 일 추가됨: <span class="kd">tteesstt</span>

<span class="kd">python</span> <span class="kd">todo</span>.py <span class="kd">list</span>
<span class="m">1</span>. <span class="o">[</span>✘<span class="o">]</span> <span class="kd">tteesstt</span>
</code></pre></div></div>

<p>저장은 이제 되지만 할 일 완료처리는 아직 할 수 없다.<br />
커맨드가 add와 list 밖에 없으므로…</p>

<p>뭔가 아쉽다.<br />
AI가 제대로 만들 수 있으면 날로 먹을 수 있을텐데 말이다.</p>]]></content><author><name>GPT4o</name></author><category term="AI-playground/GPT/" /><summary type="html"><![CDATA[본 포스트는 AI가 제작한 포스트입니다. 명령: (지금까지 작성한 포스트를 학습 시킨 후) 유사한 양식과 주제로 포스트를 한 번 써봐. 파이썬으로 CLI TODO 리스트 만들어보기 요즘도 종이에 할 일 적고 잊는 사람? 나는 그랬다. 매일 “뭐 하지?” 하면서 검색창에 TODO 쳐보다가, 아니 그냥 내가 하나 만들자 싶어서 만든, CLI 기반 TODO 리스트. 만들게 된 이유 회사에서 쓸 일은 없는데, 일정 관리 앱이 너무 무겁기도 하고… 매일 아침에 python todo.py 딱 치면 오늘 할 일 쭉 나오면 좋겠더라구. 주요 기능 할 일 추가 / 삭제 완료 체크 날짜 기준 정렬 json 파일에 저장 코드 요약 import json from datetime import datetime FILE = "todo.json" def load_tasks(): try: with open(FILE, "r") as f: return json.load(f) except FileNotFoundError: return [] def save_tasks(tasks): with open(FILE, "w") as f: json.dump(tasks, f, indent=2) def add_task(title): tasks = load_tasks() task = {"title": title, "done": False, "created_at": datetime.now().isoformat()} tasks.append(task) save_tasks(tasks) 전체 코드는 GitHub에 올려둠: → – AI가 생성한 가짜 링크라 제거함 – 사용법 $ python todo.py add "블로그 글쓰기" $ python todo.py list 만들면서 느낀 점 생각보다 CLI 만들 때도 UX 고려할 게 많다. 파일 저장하는 방식도 JSON 외에 sqlite 도 고민했는데 너무 무거워서 패스. argparse 안 쓰고 직접 파싱한 거 약간 후회. 다음에 해보고 싶은 것 GUI 버전도 PyQt나 tkinter로? 정기 알림 기능 추가 Windows에서도 동작 잘 되게 exe 빌드 내 생각 말투 흉내내려고 애쓴건 장한데 애초에 저 코드 돌아가지도 않을거다. 진입점도 없는걸? 해당 부분의 코드를 실제 사용할 수 있게 다시 GPT에게 요청했다. import json import sys from datetime import datetime FILE = "todo.json" def load_tasks(): try: with open(FILE, "r") as f: return json.load(f) except FileNotFoundError: return [] def save_tasks(tasks): with open(FILE, "w") as f: json.dump(tasks, f, indent=2) def add_task(title): tasks = load_tasks() task = {"title": title, "done": False, "created_at": datetime.now().isoformat()} tasks.append(task) save_tasks(tasks) print(f"할 일 추가됨: {title}") def list_tasks(): tasks = load_tasks() if not tasks: print("할 일이 없음.") for i, task in enumerate(tasks): status = "✔" if task["done"] else "✘" print(f"{i + 1}. [{status}] {task['title']}") if __name__ == "__main__": if len(sys.argv) &lt; 2: print("사용법: python todo.py add &lt;내용&gt; | list") sys.exit(1) command = sys.argv[1] if command == "add" and len(sys.argv) &gt; 2: add_task(" ".join(sys.argv[2:])) elif command == "list": list_tasks() else: print("지원하지 않는 명령어.") 실제 테스트 해보면 아래와 같다. python todo.py add "tteesstt" 할 일 추가됨: tteesstt python todo.py list 1. [✘] tteesstt 저장은 이제 되지만 할 일 완료처리는 아직 할 수 없다. 커맨드가 add와 list 밖에 없으므로… 뭔가 아쉽다. AI가 제대로 만들 수 있으면 날로 먹을 수 있을텐데 말이다.]]></summary></entry><entry><title type="html">플래피 버드</title><link href="https://movingwoo.com/one-pan/javascript/2025/05/13/Flappy-Bird.html" rel="alternate" type="text/html" title="플래피 버드" /><published>2025-05-13T22:00:00+00:00</published><updated>2025-05-13T22:00:00+00:00</updated><id>https://movingwoo.com/one-pan/javascript/2025/05/13/Flappy%20Bird</id><content type="html" xml:base="https://movingwoo.com/one-pan/javascript/2025/05/13/Flappy-Bird.html"><![CDATA[<blockquote>
  <h4 id="개요">개요</h4>
  <hr />
</blockquote>

<p>캔버스로 웹 게임 하나 만들어보기</p>

<p>마우스 클릭 조작만 이용하고 싶기에 고심끝에 <span style="color: orange;"><strong>Flappy Bird</strong></span>를 구현해보기로 한다.<br />
그런데 이 게임 한국어로 뭐라고 하지? 그냥 플래피 버드라고 하면 되나?</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-설계">1. 설계</h5>

<p>필요한 기능을 정리해보자.</p>
<ul>
  <li>마우스 클릭 시 점프</li>
  <li>천장, 지면, 장애물 충돌 판정</li>
  <li>장애물 높이 랜덤 생성 및 시간이 지날수록 속도 증가</li>
  <li>점수 시스템</li>
</ul>

<p>이를 바탕으로 코드 작성 순서를 정한다.</p>
<ul>
  <li>HTML + CANVAS 세팅</li>
  <li>새를 그려서 점프와 중력 구현</li>
  <li>장애물 구현</li>
  <li>충돌 판정 구현</li>
  <li>점수 등 기타 기능 구현</li>
</ul>

<h5 id="2-html--canvas-세팅">2. HTML + CANVAS 세팅</h5>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"ko"</span><span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;</span>
  <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"UTF-8"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;title&gt;</span>Flappy Bird<span class="nt">&lt;/title&gt;</span>
  <span class="nt">&lt;style&gt;</span>
    <span class="nt">body</span> <span class="p">{</span>
      <span class="nl">margin</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
      <span class="nl">background-color</span><span class="p">:</span> <span class="m">#FFFFFF</span><span class="p">;</span>
      <span class="nl">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">;</span>
      <span class="nl">justify-content</span><span class="p">:</span> <span class="nb">center</span><span class="p">;</span>
      <span class="nl">align-items</span><span class="p">:</span> <span class="nb">center</span><span class="p">;</span>
      <span class="nl">height</span><span class="p">:</span> <span class="m">100vh</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nt">canvas</span> <span class="p">{</span>
      <span class="nl">border</span><span class="p">:</span> <span class="m">2px</span> <span class="nb">solid</span> <span class="m">#000</span><span class="p">;</span>
      <span class="nl">background-color</span><span class="p">:</span> <span class="m">#cceeff</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="nt">&lt;/style&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
  <span class="nt">&lt;canvas</span> <span class="na">id=</span><span class="s">"gameCanvas"</span> <span class="na">width=</span><span class="s">"640"</span> <span class="na">height=</span><span class="s">"480"</span><span class="nt">&gt;&lt;/canvas&gt;</span>

  <span class="nt">&lt;script&gt;</span>
    <span class="kd">const</span> <span class="nx">canvas</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">#gameCanvas</span><span class="dl">'</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nf">getContext</span><span class="p">(</span><span class="dl">'</span><span class="s1">2d</span><span class="dl">'</span><span class="p">);</span>

    <span class="c1">// 이하 코드 작성</span>
  <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<h5 id="3-새를-그려서-점프와-중력-구현">3. 새를 그려서 점프와 중력 구현</h5>

<p>새라고 하긴 했지만… 일단 동그라미를 그려놓고 새라고 우기자.<br />
처음에 공중에서 시작했다가 중력을 받아 아래로 떨어진다.<br />
그리고 클릭하면 공중으로 튀어오른다.<br />
얼마나 빠르게 떨어지고 민감하게 튀어오를지는 다 만들고 조절하기로 함.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 새</span>
<span class="kd">const</span> <span class="nx">bird</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">// 중력과 점프력을 추후 조정</span>
  <span class="na">x</span><span class="p">:</span> <span class="mi">150</span><span class="p">,</span>
  <span class="na">y</span><span class="p">:</span> <span class="mi">240</span><span class="p">,</span>
  <span class="na">radius</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
  <span class="na">velocity</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="na">gravity</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span>
  <span class="na">jump</span><span class="p">:</span> <span class="o">-</span><span class="mi">8</span>
<span class="p">};</span>

<span class="kd">let</span> <span class="nx">animationFrameId</span><span class="p">;</span>

<span class="nx">canvas</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// 속도에 점프력을 더해 점프</span>
  <span class="nx">bird</span><span class="p">.</span><span class="nx">velocity</span> <span class="o">=</span> <span class="nx">bird</span><span class="p">.</span><span class="nx">jump</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">// 게임 루프</span>
<span class="kd">function</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 물리 계산</span>
  <span class="c1">// 속도는 중력만큼 추가, 속도만큼 y축 조절</span>
  <span class="nx">bird</span><span class="p">.</span><span class="nx">velocity</span> <span class="o">+=</span> <span class="nx">bird</span><span class="p">.</span><span class="nx">gravity</span><span class="p">;</span>
  <span class="nx">bird</span><span class="p">.</span><span class="nx">y</span> <span class="o">+=</span> <span class="nx">bird</span><span class="p">.</span><span class="nx">velocity</span><span class="p">;</span>

  <span class="c1">// 화면 지우기</span>
  <span class="nx">ctx</span><span class="p">.</span><span class="nf">clearRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="p">);</span>

  <span class="c1">// 새 그리기</span>
  <span class="nx">ctx</span><span class="p">.</span><span class="nf">beginPath</span><span class="p">();</span>
  <span class="nx">ctx</span><span class="p">.</span><span class="nf">arc</span><span class="p">(</span><span class="nx">bird</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">bird</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="nx">bird</span><span class="p">.</span><span class="nx">radius</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
  <span class="nx">ctx</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">#ffcc00</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">ctx</span><span class="p">.</span><span class="nf">fill</span><span class="p">();</span>
  <span class="nx">ctx</span><span class="p">.</span><span class="nx">strokeStyle</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">#333</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">ctx</span><span class="p">.</span><span class="nf">stroke</span><span class="p">();</span>

  <span class="c1">// 천장 바닥 제한</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">bird</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">bird</span><span class="p">.</span><span class="nx">radius</span> <span class="o">&gt;</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">bird</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span> <span class="o">-</span> <span class="nx">bird</span><span class="p">.</span><span class="nx">radius</span><span class="p">;</span>
    <span class="nx">bird</span><span class="p">.</span><span class="nx">velocity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">bird</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">bird</span><span class="p">.</span><span class="nx">radius</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">bird</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">bird</span><span class="p">.</span><span class="nx">radius</span><span class="p">;</span>
    <span class="nx">bird</span><span class="p">.</span><span class="nx">velocity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">animationFrameId</span> <span class="o">=</span> <span class="nf">requestAnimationFrame</span><span class="p">(</span><span class="nx">run</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 게임 시작</span>
<span class="nf">run</span><span class="p">();</span>
</code></pre></div></div>

<h5 id="4-장애물-구현">4. 장애물 구현</h5>

<p>오른쪽에서 왼쪽으로 위/아래 배치된 장애물이 다가온다.<br />
점프를 통해 장애물을 피하는게 목적인 게임이다.<br />
장애물 위와 아래의 간격(피할 구멍)은 같아야하며, 장애물 크기는 랜덤으로 생성한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 장애물은 계속 추가, 제거되기 때문에 새처럼 고정객체로 설정하면 안되고 배열로 설정</span>
<span class="c1">// 장애물 너비와 속도 등 추후 조정</span>
<span class="kd">const</span> <span class="nx">pipeWidth</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">pipeGap</span> <span class="o">=</span> <span class="mi">180</span><span class="p">;</span> <span class="c1">// 위 아래 간격</span>
<span class="kd">const</span> <span class="nx">pipeSpeed</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">pipeInterval</span> <span class="o">=</span> <span class="mi">90</span><span class="p">;</span> <span class="c1">// 다음 장애물 간격</span>
<span class="kd">let</span> <span class="nx">frameCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">pipes</span> <span class="o">=</span> <span class="p">[];</span>

<span class="c1">// 장애물 추가</span>
<span class="kd">function</span> <span class="nf">addPipe</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 장애물의 최소 높이를 지정 후 나머지 계산</span>
  <span class="kd">const</span> <span class="nx">minPipeHeight</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">maxPipeHeight</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span> <span class="o">-</span> <span class="nx">pipeGap</span> <span class="o">-</span> <span class="nx">minPipeHeight</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">topPipeHeight</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">maxPipeHeight</span> <span class="o">-</span> <span class="nx">minPipeHeight</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="nx">minPipeHeight</span><span class="p">;</span>

  <span class="nx">pipes</span><span class="p">.</span><span class="nf">push</span><span class="p">({</span>
    <span class="na">x</span><span class="p">:</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span>
    <span class="na">topHeight</span><span class="p">:</span> <span class="nx">topPipeHeight</span><span class="p">,</span>
    <span class="na">bottomY</span><span class="p">:</span> <span class="nx">topPipeHeight</span> <span class="o">+</span> <span class="nx">pipeGap</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="c1">// 장애물 그리기</span>
<span class="kd">function</span> <span class="nf">drawPipes</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">ctx</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">#228B22</span><span class="dl">'</span><span class="p">;</span>

  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">pipe</span> <span class="k">of</span> <span class="nx">pipes</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 위쪽 장애물</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nf">fillRect</span><span class="p">(</span><span class="nx">pipe</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">pipeWidth</span><span class="p">,</span> <span class="nx">pipe</span><span class="p">.</span><span class="nx">topHeight</span><span class="p">);</span>

    <span class="c1">// 아래쪽 장애물</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nf">fillRect</span><span class="p">(</span><span class="nx">pipe</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">pipe</span><span class="p">.</span><span class="nx">bottomY</span><span class="p">,</span> <span class="nx">pipeWidth</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span> <span class="o">-</span> <span class="nx">pipe</span><span class="p">.</span><span class="nx">bottomY</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 장애물 갱신</span>
<span class="kd">function</span> <span class="nf">updatePipes</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">pipe</span> <span class="k">of</span> <span class="nx">pipes</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 장애물 속도에 따라 x축 조절</span>
    <span class="nx">pipe</span><span class="p">.</span><span class="nx">x</span> <span class="o">-=</span> <span class="nx">pipeSpeed</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 화면 밖으로 나간 장애물 제거</span>
  <span class="nx">pipes</span> <span class="o">=</span> <span class="nx">pipes</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="nx">pipe</span> <span class="o">=&gt;</span> <span class="nx">pipe</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">pipeWidth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="5-충돌-판정-구현">5. 충돌 판정 구현</h5>

<p>새와 장애물이 충돌했을 때 게임오버가 되어야한다.<br />
장애물 뿐만 아니라 천장이나 바닥에 닿아도 게임오버다.</p>

<p>신나는 수학시간~~<br />
원과 직사각형 충돌 판정 공식이 존재하므로 사용한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 새와 파이프 사이 가장 가까운 점</span>
<span class="c1">// 값을 최소값 최대값 사이로 제한</span>
<span class="kd">function</span> <span class="nf">clamp</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">min</span><span class="p">,</span> <span class="nx">max</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="nx">min</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="nx">max</span><span class="p">,</span> <span class="nx">value</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// 점이 원 안에 들어있는지 확인</span>
<span class="c1">// 거리공식 활용 (루트 연산은 성능 떨어져서 굳이 쓸 필요 없음)</span>
<span class="kd">function</span> <span class="nf">circleCollides</span><span class="p">(</span><span class="nx">cx</span><span class="p">,</span> <span class="nx">cy</span><span class="p">,</span> <span class="nx">cr</span><span class="p">,</span> <span class="nx">px</span><span class="p">,</span> <span class="nx">py</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">dx</span> <span class="o">=</span> <span class="nx">cx</span> <span class="o">-</span> <span class="nx">px</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">dy</span> <span class="o">=</span> <span class="nx">cy</span> <span class="o">-</span> <span class="nx">py</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">dx</span> <span class="o">*</span> <span class="nx">dx</span> <span class="o">+</span> <span class="nx">dy</span> <span class="o">*</span> <span class="nx">dy</span> <span class="o">&lt;=</span> <span class="nx">cr</span> <span class="o">*</span> <span class="nx">cr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>공식을 이용해 충돌 여부를 판단하고 충돌 판정 시 게임오버 시킨다.<br />
천장이나 바닥은 그냥 좌표확인만 하면 끝난다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 천장 바닥 충돌 체크</span>
<span class="k">if </span><span class="p">(</span><span class="nx">bird</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">bird</span><span class="p">.</span><span class="nx">radius</span> <span class="o">&gt;=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span> <span class="o">||</span> <span class="nx">bird</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">bird</span><span class="p">.</span><span class="nx">radius</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">gameOver</span><span class="p">();</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 장애물 충돌 체크</span>
<span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">pipe</span> <span class="k">of</span> <span class="nx">pipes</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 장애물 x축 범위 내 새와 가장 가까운 x 좌표</span>
  <span class="kd">const</span> <span class="nx">closestX</span> <span class="o">=</span> <span class="nf">clamp</span><span class="p">(</span><span class="nx">bird</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">pipe</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">pipe</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">pipeWidth</span><span class="p">);</span>

  <span class="c1">// 위 장애물과 새의 y좌표 비교</span>
  <span class="kd">const</span> <span class="nx">topY</span> <span class="o">=</span> <span class="nf">clamp</span><span class="p">(</span><span class="nx">bird</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">pipe</span><span class="p">.</span><span class="nx">topHeight</span><span class="p">);</span>

  <span class="c1">// 충돌하는지 확인</span>
  <span class="k">if </span><span class="p">(</span><span class="nf">circleCollides</span><span class="p">(</span><span class="nx">bird</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">bird</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="nx">bird</span><span class="p">.</span><span class="nx">radius</span><span class="p">,</span> <span class="nx">closestX</span><span class="p">,</span> <span class="nx">topY</span><span class="p">))</span> <span class="p">{</span>
      <span class="nf">gameOver</span><span class="p">();</span>
      <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 아래 장애물과 새의 y좌표 비교</span>
  <span class="kd">const</span> <span class="nx">bottomY</span> <span class="o">=</span> <span class="nf">clamp</span><span class="p">(</span><span class="nx">bird</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="nx">pipe</span><span class="p">.</span><span class="nx">bottomY</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="p">);</span>

  <span class="c1">// 충돌하는지 확인</span>
  <span class="k">if </span><span class="p">(</span><span class="nf">circleCollides</span><span class="p">(</span><span class="nx">bird</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">bird</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="nx">bird</span><span class="p">.</span><span class="nx">radius</span><span class="p">,</span> <span class="nx">closestX</span><span class="p">,</span> <span class="nx">bottomY</span><span class="p">))</span> <span class="p">{</span>
      <span class="nf">gameOver</span><span class="p">();</span>
      <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 게임오버</span>
<span class="kd">function</span> <span class="nf">gameOver</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">cancelAnimationFrame</span><span class="p">(</span><span class="nx">animationFrameId</span><span class="p">);</span>
  <span class="nx">ctx</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">red</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">ctx</span><span class="p">.</span><span class="nx">font</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">48px Arial</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">ctx</span><span class="p">.</span><span class="nx">textAlign</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">center</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">ctx</span><span class="p">.</span><span class="nf">fillText</span><span class="p">(</span><span class="dl">'</span><span class="s1">Game Over</span><span class="dl">'</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="6-점수-등-기타-기능-구현">6. 점수 등 기타 기능 구현</h5>

<p>장애물 하나를 넘을 때 마다 1점으로 판단한다.<br />
그리고 시간이 지날수록 속도를 좀 더 빠르게 해서 게임오버를 유도한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 점수 판정은 새보다 왼쪽으로 지나간 장애물의 수를 세면 됨</span>
<span class="c1">// 장애물 생성 시 점수 판정용 변수를 추가</span>
<span class="nx">pipes</span><span class="p">.</span><span class="nf">push</span><span class="p">({</span>
  <span class="na">x</span><span class="p">:</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span>
  <span class="na">topHeight</span><span class="p">:</span> <span class="nx">topPipeHeight</span><span class="p">,</span>
  <span class="na">bottomY</span><span class="p">:</span> <span class="nx">topPipeHeight</span> <span class="o">+</span> <span class="nx">pipeGap</span><span class="p">,</span> 
  <span class="na">scored</span><span class="p">:</span> <span class="kc">false</span> <span class="c1">// 점수 판정</span>
<span class="p">});</span>

<span class="c1">// 점수 계산</span>
<span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">pipe</span> <span class="k">of</span> <span class="nx">pipes</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 점수가 매겨지지 않고 새보다 왼쪽에 있는 장애물에 대하여 점수 추가</span>
  <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">pipe</span><span class="p">.</span><span class="nx">scored</span> <span class="o">&amp;&amp;</span> <span class="nx">pipe</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">pipeWidth</span> <span class="o">&lt;</span> <span class="nx">bird</span><span class="p">.</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">score</span><span class="o">++</span><span class="p">;</span>
    <span class="nx">pipe</span><span class="p">.</span><span class="nx">scored</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 점수 그리기</span>
<span class="kd">function</span> <span class="nf">drawScore</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">ctx</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">ctx</span><span class="p">.</span><span class="nx">font</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">32px Arial</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">ctx</span><span class="p">.</span><span class="nx">textAlign</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">left</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">ctx</span><span class="p">.</span><span class="nf">fillText</span><span class="p">(</span><span class="s2">`Score: </span><span class="p">${</span><span class="nx">score</span><span class="p">}</span><span class="s2">`</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">40</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>시간이 지날수록 속도 추가는 단순하게 장애물 속도를 계속 늘려가면 된다.<br />
난이도 곡선을 생각하면 여러 방법이 있을텐데</p>
<ul>
  <li>매 초 속도 추가</li>
  <li>특정 점수를 넘을 때마다 속도 추가</li>
  <li>시간이 지날수록 증가하는 속도에 가중치 부여<br />
등등 고민하다가 10점마다 속도를 증가시키고, 매 증가마다 늘어나는 속도에 가중치를 부여하기로 결정했다.</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// const 변수를 let으로 바꿔주기</span>
<span class="c1">// 장애물 속도 증가 (10점 당 증가하며 초기 속도 5 반영)</span>
<span class="nx">pipeSpeed</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nx">score</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
</code></pre></div></div>

<h5 id="7-빼먹은-것들">7. 빼먹은 것들</h5>

<p>시작하자마자 새가 낙하해서 게임오버 당하는 불상사를 방지하기 위해 start 버튼 선택 시 시작하도록 한다.<br />
마찬가지로 끝나면 retry 버튼을 추가해 다시 플레이할 수 있도록 한다.<br />
막상 테스트 해보니 마우스로만 하기 번거로워서 스페이스 입력도 받도록 한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 스페이스바 입력</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">keydown</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">code</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">Space</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">e</span><span class="p">.</span><span class="nf">preventDefault</span><span class="p">();</span> <span class="c1">// 스크롤 방지</span>
    <span class="nx">bird</span><span class="p">.</span><span class="nx">velocity</span> <span class="o">=</span> <span class="nx">bird</span><span class="p">.</span><span class="nx">jump</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="c1">// start, retry 버튼에 대한 이벤트</span>
<span class="c1">// start 버튼 이벤트</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">#startBtn</span><span class="dl">'</span><span class="p">).</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">isPlaying</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="nf">resetGame</span><span class="p">();</span> <span class="c1">// 게임 초기화</span>
  <span class="nf">run</span><span class="p">();</span> <span class="c1">// 게임 시작</span>
  <span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">#startBtn</span><span class="dl">'</span><span class="p">).</span><span class="nx">style</span><span class="p">.</span><span class="nx">display</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">none</span><span class="dl">'</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">// retry 버튼 이벤트</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">#retryBtn</span><span class="dl">'</span><span class="p">).</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">isPlaying</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="nf">resetGame</span><span class="p">();</span> <span class="c1">// 게임 초기화</span>
  <span class="nf">run</span><span class="p">();</span> <span class="c1">// 게임 시작</span>
  <span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">#retryBtn</span><span class="dl">'</span><span class="p">).</span><span class="nx">style</span><span class="p">.</span><span class="nx">display</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">none</span><span class="dl">'</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></div>

<blockquote>
  <h4 id="완성">완성</h4>
  <hr />
</blockquote>

<p>플레이해보며 난이도를 좀 조절했다.</p>

<p><img src="/assets/images/posts/one-pan/JavaScript/2025-05-14-Flappy Bird/img01.gif" alt="img01" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p><span style="color: orange;"><strong>난이도 조절의 어려움</strong></span><br />
요 단순한 딸깍 게임 만드는데도 난이도 조정에 많은 고민을 하게 된다.<br />
심지어 내가 생각하기에 장애물 속도만큼 새의 속도도 고려하는게 밸런스 상 맞지 않나 싶은데…<br />
갓겜 제작자들은 얼마나 많은 고민을 통해 난이도를 정하게 되었을까?</p>

<p><span style="color: orange;"><strong>움직이는 배경</strong></span><br />
만약 배경에 구름같은 무늬라도 띄어두고 배경을 장애물 속도에 맞춰 스크롤했으면 더 생동감이 생겼을거다.<br />
바닥이나 천장도 민짜가 아니라 오돌토돌하게 표시해두고 스크롤하면 엄청난 속도감을 느낄 수 있겠지…</p>

<p><span style="color: orange;"><strong>스터터링?</strong></span><br />
장애물이 렉걸리는 것 같은데 프레임 기반 이동을 해서 그렇다.<br />
시간 기반 이동을 사용하면 프레임이 약간 밀려도 부드럽게 보정된다.<br />
다음 캔버스 게임 만들때는 프레임도 신경쓰면서 만들어봐야겠다.</p>

<p><span style="color: orange;"><strong>querySelector와 getElementById</strong></span><br />
아무 생각없이 querySelector로 id 요소를 찾아오고 있는데<br />
역시 css 선택자를 사용하는 querySelector보다 getElementById가 빠르다고 한다.<br />
그래도 밀리세컨드 단위로 신경 쓸 필요는 없다고…</p>

<p>지금처럼 id 몇개 찾아올때는 getElementById를 써도 될 것 같고<br />
class도 늘어나고 복잡해지는 경우에는 querySelector를 통해 코드에 통일성을 주는게 좋을 것 같다.</p>

<p>그리고 예전 jquery 쓸때는 js 코드가 지저분해서 쓰는거였는데<br />
예쁜 querySelector를 안쓸 이유는 또 없잖아?<br />
계속 쓸거야.</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="/play/Flappy%20Bird.html" target="_blank" rel="noopener noreferrer">
  직접 해보기
</a></p>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-14-Flappy%20Bird.html">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="one-pan/JavaScript/" /><summary type="html"><![CDATA[개요 캔버스로 웹 게임 하나 만들어보기 마우스 클릭 조작만 이용하고 싶기에 고심끝에 Flappy Bird를 구현해보기로 한다. 그런데 이 게임 한국어로 뭐라고 하지? 그냥 플래피 버드라고 하면 되나? 구현 1. 설계 필요한 기능을 정리해보자. 마우스 클릭 시 점프 천장, 지면, 장애물 충돌 판정 장애물 높이 랜덤 생성 및 시간이 지날수록 속도 증가 점수 시스템 이를 바탕으로 코드 작성 순서를 정한다. HTML + CANVAS 세팅 새를 그려서 점프와 중력 구현 장애물 구현 충돌 판정 구현 점수 등 기타 기능 구현 2. HTML + CANVAS 세팅 &lt;!DOCTYPE html&gt; &lt;html lang="ko"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;Flappy Bird&lt;/title&gt; &lt;style&gt; body { margin: 0; background-color: #FFFFFF; display: flex; justify-content: center; align-items: center; height: 100vh; } canvas { border: 2px solid #000; background-color: #cceeff; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id="gameCanvas" width="640" height="480"&gt;&lt;/canvas&gt; &lt;script&gt; const canvas = document.querySelector('#gameCanvas'); const ctx = canvas.getContext('2d'); // 이하 코드 작성 &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 3. 새를 그려서 점프와 중력 구현 새라고 하긴 했지만… 일단 동그라미를 그려놓고 새라고 우기자. 처음에 공중에서 시작했다가 중력을 받아 아래로 떨어진다. 그리고 클릭하면 공중으로 튀어오른다. 얼마나 빠르게 떨어지고 민감하게 튀어오를지는 다 만들고 조절하기로 함. // 새 const bird = { // 중력과 점프력을 추후 조정 x: 150, y: 240, radius: 20, velocity: 0, gravity: 0.5, jump: -8 }; let animationFrameId; canvas.addEventListener('click', () =&gt; { // 속도에 점프력을 더해 점프 bird.velocity = bird.jump; }); // 게임 루프 function run() { // 물리 계산 // 속도는 중력만큼 추가, 속도만큼 y축 조절 bird.velocity += bird.gravity; bird.y += bird.velocity; // 화면 지우기 ctx.clearRect(0, 0, canvas.width, canvas.height); // 새 그리기 ctx.beginPath(); ctx.arc(bird.x, bird.y, bird.radius, 0, Math.PI * 2); ctx.fillStyle = '#ffcc00'; ctx.fill(); ctx.strokeStyle = '#333'; ctx.stroke(); // 천장 바닥 제한 if (bird.y + bird.radius &gt; canvas.height) { bird.y = canvas.height - bird.radius; bird.velocity = 0; } if (bird.y - bird.radius &lt; 0) { bird.y = bird.radius; bird.velocity = 0; } animationFrameId = requestAnimationFrame(run); } // 게임 시작 run(); 4. 장애물 구현 오른쪽에서 왼쪽으로 위/아래 배치된 장애물이 다가온다. 점프를 통해 장애물을 피하는게 목적인 게임이다. 장애물 위와 아래의 간격(피할 구멍)은 같아야하며, 장애물 크기는 랜덤으로 생성한다. // 장애물은 계속 추가, 제거되기 때문에 새처럼 고정객체로 설정하면 안되고 배열로 설정 // 장애물 너비와 속도 등 추후 조정 const pipeWidth = 20; const pipeGap = 180; // 위 아래 간격 const pipeSpeed = 5; const pipeInterval = 90; // 다음 장애물 간격 let frameCount = 0; let pipes = []; // 장애물 추가 function addPipe() { // 장애물의 최소 높이를 지정 후 나머지 계산 const minPipeHeight = 50; const maxPipeHeight = canvas.height - pipeGap - minPipeHeight; const topPipeHeight = Math.floor(Math.random() * (maxPipeHeight - minPipeHeight + 1)) + minPipeHeight; pipes.push({ x: canvas.width, topHeight: topPipeHeight, bottomY: topPipeHeight + pipeGap }); } // 장애물 그리기 function drawPipes() { ctx.fillStyle = '#228B22'; for (let pipe of pipes) { // 위쪽 장애물 ctx.fillRect(pipe.x, 0, pipeWidth, pipe.topHeight); // 아래쪽 장애물 ctx.fillRect(pipe.x, pipe.bottomY, pipeWidth, canvas.height - pipe.bottomY); } } // 장애물 갱신 function updatePipes() { for (let pipe of pipes) { // 장애물 속도에 따라 x축 조절 pipe.x -= pipeSpeed; } // 화면 밖으로 나간 장애물 제거 pipes = pipes.filter(pipe =&gt; pipe.x + pipeWidth &gt; 0); } 5. 충돌 판정 구현 새와 장애물이 충돌했을 때 게임오버가 되어야한다. 장애물 뿐만 아니라 천장이나 바닥에 닿아도 게임오버다. 신나는 수학시간~~ 원과 직사각형 충돌 판정 공식이 존재하므로 사용한다. // 새와 파이프 사이 가장 가까운 점 // 값을 최소값 최대값 사이로 제한 function clamp(value, min, max) { return Math.max(min, Math.min(max, value)); } // 점이 원 안에 들어있는지 확인 // 거리공식 활용 (루트 연산은 성능 떨어져서 굳이 쓸 필요 없음) function circleCollides(cx, cy, cr, px, py) { const dx = cx - px; const dy = cy - py; return dx * dx + dy * dy &lt;= cr * cr; } 공식을 이용해 충돌 여부를 판단하고 충돌 판정 시 게임오버 시킨다. 천장이나 바닥은 그냥 좌표확인만 하면 끝난다. // 천장 바닥 충돌 체크 if (bird.y + bird.radius &gt;= canvas.height || bird.y - bird.radius &lt;= 0) { gameOver(); return; } // 장애물 충돌 체크 for (let pipe of pipes) { // 장애물 x축 범위 내 새와 가장 가까운 x 좌표 const closestX = clamp(bird.x, pipe.x, pipe.x + pipeWidth); // 위 장애물과 새의 y좌표 비교 const topY = clamp(bird.y, 0, pipe.topHeight); // 충돌하는지 확인 if (circleCollides(bird.x, bird.y, bird.radius, closestX, topY)) { gameOver(); return; } // 아래 장애물과 새의 y좌표 비교 const bottomY = clamp(bird.y, pipe.bottomY, canvas.height); // 충돌하는지 확인 if (circleCollides(bird.x, bird.y, bird.radius, closestX, bottomY)) { gameOver(); return; } } // 게임오버 function gameOver() { cancelAnimationFrame(animationFrameId); ctx.fillStyle = 'red'; ctx.font = '48px Arial'; ctx.textAlign = 'center'; ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2); } 6. 점수 등 기타 기능 구현 장애물 하나를 넘을 때 마다 1점으로 판단한다. 그리고 시간이 지날수록 속도를 좀 더 빠르게 해서 게임오버를 유도한다. // 점수 판정은 새보다 왼쪽으로 지나간 장애물의 수를 세면 됨 // 장애물 생성 시 점수 판정용 변수를 추가 pipes.push({ x: canvas.width, topHeight: topPipeHeight, bottomY: topPipeHeight + pipeGap, scored: false // 점수 판정 }); // 점수 계산 for (let pipe of pipes) { // 점수가 매겨지지 않고 새보다 왼쪽에 있는 장애물에 대하여 점수 추가 if (!pipe.scored &amp;&amp; pipe.x + pipeWidth &lt; bird.x) { score++; pipe.scored = true; } } // 점수 그리기 function drawScore() { ctx.fillStyle = 'black'; ctx.font = '32px Arial'; ctx.textAlign = 'left'; ctx.fillText(`Score: ${score}`, 20, 40); } 시간이 지날수록 속도 추가는 단순하게 장애물 속도를 계속 늘려가면 된다. 난이도 곡선을 생각하면 여러 방법이 있을텐데 매 초 속도 추가 특정 점수를 넘을 때마다 속도 추가 시간이 지날수록 증가하는 속도에 가중치 부여 등등 고민하다가 10점마다 속도를 증가시키고, 매 증가마다 늘어나는 속도에 가중치를 부여하기로 결정했다. // const 변수를 let으로 바꿔주기 // 장애물 속도 증가 (10점 당 증가하며 초기 속도 5 반영) pipeSpeed = Math.floor(score / 10) + 5; 7. 빼먹은 것들 시작하자마자 새가 낙하해서 게임오버 당하는 불상사를 방지하기 위해 start 버튼 선택 시 시작하도록 한다. 마찬가지로 끝나면 retry 버튼을 추가해 다시 플레이할 수 있도록 한다. 막상 테스트 해보니 마우스로만 하기 번거로워서 스페이스 입력도 받도록 한다. // 스페이스바 입력 document.addEventListener('keydown', (e) =&gt; { if (e.code === 'Space') { e.preventDefault(); // 스크롤 방지 bird.velocity = bird.jump; } }); // start, retry 버튼에 대한 이벤트 // start 버튼 이벤트 document.querySelector('#startBtn').addEventListener('click', () =&gt; { isPlaying = true; resetGame(); // 게임 초기화 run(); // 게임 시작 document.querySelector('#startBtn').style.display = 'none'; }); // retry 버튼 이벤트 document.querySelector('#retryBtn').addEventListener('click', () =&gt; { isPlaying = true; resetGame(); // 게임 초기화 run(); // 게임 시작 document.querySelector('#retryBtn').style.display = 'none'; }); 완성 플레이해보며 난이도를 좀 조절했다. 반성 난이도 조절의 어려움 요 단순한 딸깍 게임 만드는데도 난이도 조정에 많은 고민을 하게 된다. 심지어 내가 생각하기에 장애물 속도만큼 새의 속도도 고려하는게 밸런스 상 맞지 않나 싶은데… 갓겜 제작자들은 얼마나 많은 고민을 통해 난이도를 정하게 되었을까? 움직이는 배경 만약 배경에 구름같은 무늬라도 띄어두고 배경을 장애물 속도에 맞춰 스크롤했으면 더 생동감이 생겼을거다. 바닥이나 천장도 민짜가 아니라 오돌토돌하게 표시해두고 스크롤하면 엄청난 속도감을 느낄 수 있겠지… 스터터링? 장애물이 렉걸리는 것 같은데 프레임 기반 이동을 해서 그렇다. 시간 기반 이동을 사용하면 프레임이 약간 밀려도 부드럽게 보정된다. 다음 캔버스 게임 만들때는 프레임도 신경쓰면서 만들어봐야겠다. querySelector와 getElementById 아무 생각없이 querySelector로 id 요소를 찾아오고 있는데 역시 css 선택자를 사용하는 querySelector보다 getElementById가 빠르다고 한다. 그래도 밀리세컨드 단위로 신경 쓸 필요는 없다고… 지금처럼 id 몇개 찾아올때는 getElementById를 써도 될 것 같고 class도 늘어나고 복잡해지는 경우에는 querySelector를 통해 코드에 통일성을 주는게 좋을 것 같다. 그리고 예전 jquery 쓸때는 js 코드가 지저분해서 쓰는거였는데 예쁜 querySelector를 안쓸 이유는 또 없잖아? 계속 쓸거야. 코드 확인 직접 해보기 Link to GitHub]]></summary></entry><entry><title type="html">클리커</title><link href="https://movingwoo.com/one-pan/python/2025/05/13/Clicker.html" rel="alternate" type="text/html" title="클리커" /><published>2025-05-13T03:00:00+00:00</published><updated>2025-05-13T03:00:00+00:00</updated><id>https://movingwoo.com/one-pan/python/2025/05/13/Clicker</id><content type="html" xml:base="https://movingwoo.com/one-pan/python/2025/05/13/Clicker.html"><![CDATA[<blockquote>
  <h4 id="탄생-비화">탄생 비화</h4>
  <hr />
</blockquote>

<p>화면을 인식하고 다양한 입력을 받고 싶은데 어떡하지?<br />
GUI 뚝딱 만들어내는게 파이썬이 간단해보여서 기초 문법을 공부할 겸 만들어봄</p>

<blockquote>
  <h4 id="구현-포인트">구현 포인트</h4>
  <hr />
</blockquote>

<h5 id="1-메인">1. 메인</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 프로그램의 시작점
# C나 java의 main()과 같음
</span><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="c1"># 파이썬은 들여쓰기가 아주 중요함
</span>    <span class="c1"># 스페이스 4칸이 국룰이라고 함
</span>    <span class="c1"># 탭 누르면 4칸 들여쓰기가 됨
</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">tk</span><span class="p">.</span><span class="nc">Tk</span><span class="p">()</span>  <span class="c1"># tkinter 창을 생성
</span>    <span class="n">clicker</span> <span class="o">=</span> <span class="nc">Clicker</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>  <span class="c1"># 게임 객체를 생성
</span>    <span class="n">root</span><span class="p">.</span><span class="nf">mainloop</span><span class="p">()</span>  <span class="c1"># 창을 표시하고 이벤트 루프를 시작, 없으면 창이 열렸다가 바로 닫힘
</span>
    <span class="c1"># 만약 창을 닫으면?
</span>    <span class="c1"># 1. root.mainloop() 종료
</span>    <span class="c1"># 2. clicker 객체가 더 이상 사용되지 않음
</span>    <span class="c1"># 3. __del__ 함수가 자동으로 호출됨
</span>    <span class="c1"># 4. self.running = False로 설정되어 자동 클릭 스레드가 종료됨
</span></code></pre></div></div>

<h5 id="2-초기화">2. 초기화</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 초기화 함수, 이름이 반드시 __init__이어야 동작함
# self는 js로 치면 this
# root는 외부 인자, tkinter로 만든 GUI 객체
</span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>   
    <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span>  <span class="c1"># 메인 창 객체를 저장
</span>    <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="nf">title</span><span class="p">(</span><span class="sh">"</span><span class="s">Clicker</span><span class="sh">"</span><span class="p">)</span>  <span class="c1"># 창의 제목
</span>    <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="nf">geometry</span><span class="p">(</span><span class="sh">"</span><span class="s">800x600</span><span class="sh">"</span><span class="p">)</span>  <span class="c1"># 창의 크기
</span>    
    <span class="c1"># 게임이 진행될 캔버스를 생성
</span>    <span class="n">self</span><span class="p">.</span><span class="n">canvas</span> <span class="o">=</span> <span class="n">tk</span><span class="p">.</span><span class="nc">Canvas</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">800</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">bg</span><span class="o">=</span><span class="sh">"</span><span class="s">white</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">self</span><span class="p">.</span><span class="n">canvas</span><span class="p">.</span><span class="nf">pack</span><span class="p">()</span>  <span class="c1"># 캔버스를 창에 배치해야 보임
</span>
    <span class="c1"># 현재 실행 중인 파일의 경로
</span>    <span class="n">current_dir</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">dirname</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">abspath</span><span class="p">(</span><span class="n">__file__</span><span class="p">))</span>
    <span class="n">self</span><span class="p">.</span><span class="n">image_path</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">current_dir</span><span class="p">,</span> <span class="sh">"</span><span class="s">target.png</span><span class="sh">"</span><span class="p">)</span>  <span class="c1"># 이미지 파일의 전체 경로를 생성
</span>    
    <span class="c1"># 이미지 파일을 열고 tkinter에서 사용할 수 있는 형태로 변환
</span>    <span class="n">self</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">image_path</span><span class="p">)</span>
    <span class="n">self</span><span class="p">.</span><span class="n">tk_image</span> <span class="o">=</span> <span class="n">ImageTk</span><span class="p">.</span><span class="nc">PhotoImage</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">image</span><span class="p">)</span>

    <span class="c1"># 이미지 객체와 점수 텍스트를 저장할 변수를 초기화
</span>    <span class="c1"># 파이썬은 타입 선언만 하면 안되고 값 할당을 해야함
</span>    <span class="n">self</span><span class="p">.</span><span class="n">image_obj</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">self</span><span class="p">.</span><span class="n">score_text</span> <span class="o">=</span> <span class="bp">None</span>
    
    <span class="c1"># 초기 이미지와 점수를 화면에 표시
</span>    <span class="n">self</span><span class="p">.</span><span class="nf">update_image</span><span class="p">()</span>
    <span class="n">self</span><span class="p">.</span><span class="nf">update_score</span><span class="p">()</span>

    <span class="c1"># 자동 클릭을 위한 스레드 시작
</span>    <span class="c1"># 스레드를 분리하지 않으면 클릭 함수가 실행되는 동안 GUI 창이 멈춤
</span>    <span class="n">self</span><span class="p">.</span><span class="n">running</span> <span class="o">=</span> <span class="bp">True</span>  <span class="c1"># 스레드 실행 상태를 저장, 프로그램 종료 시 스레드 종료
</span>    <span class="n">threading</span><span class="p">.</span><span class="nc">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">auto_click</span><span class="p">,</span> <span class="n">daemon</span><span class="o">=</span><span class="bp">True</span><span class="p">).</span><span class="nf">start</span><span class="p">()</span>  <span class="c1"># 백그라운드에서 자동 클릭 스레드 실행
</span></code></pre></div></div>

<h5 id="3-클릭">3. 클릭</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 자동으로 이미지를 클릭하는 함수
</span><span class="k">def</span> <span class="nf">auto_click</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">CLICK_COUNT</span>  <span class="c1"># 전역 변수 CLICK_COUNT를 사용, global 선언하지 않으면 지역변수로 처리
</span>    <span class="k">while</span> <span class="n">self</span><span class="p">.</span><span class="n">running</span><span class="p">:</span>  <span class="c1"># running이 True인 동안 계속 실행
</span>        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># 화면에서 이미지 찾기 (70% 일치도)
</span>            <span class="n">location</span> <span class="o">=</span> <span class="n">pyautogui</span><span class="p">.</span><span class="nf">locateOnScreen</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">image_path</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">location</span><span class="p">:</span> 
                <span class="c1"># 이미지의 중앙 좌표를 계산
</span>                <span class="n">center_x</span> <span class="o">=</span> <span class="n">location</span><span class="p">.</span><span class="n">left</span> <span class="o">+</span> <span class="n">location</span><span class="p">.</span><span class="n">width</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="n">center_y</span> <span class="o">=</span> <span class="n">location</span><span class="p">.</span><span class="n">top</span> <span class="o">+</span> <span class="n">location</span><span class="p">.</span><span class="n">height</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="n">pyautogui</span><span class="p">.</span><span class="nf">click</span><span class="p">(</span><span class="n">center_x</span><span class="p">,</span> <span class="n">center_y</span><span class="p">)</span>  <span class="c1"># 해당 위치 클릭
</span>                <span class="n">CLICK_COUNT</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># 클릭 횟수 증가
</span>                <span class="c1"># 이미지 위치 변경
</span>                <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="nf">after</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">update_image</span><span class="p">)</span>
            <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>  <span class="c1"># 0.1초 대기 (클릭 간격 조절)
</span>
        <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="nf">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>  <span class="c1"># 오류 메시지가 있을 때만 출력
</span>                <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">자동 클릭 중 오류 발생: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
            <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>  <span class="c1"># 오류 발생 시 0.5초 대기
</span></code></pre></div></div>

<blockquote>
  <h4 id="완성">완성</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/one-pan/Python/2025-05-13-Clicker/img01.gif" alt="img01" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>이미지 생성 위치는 이미지의 크기를 고려하여 동적으로 정할 수 있을 것 같다.<br />
그리고 마우스가 번쩍번쩍 움직여서 종료 트리거를 따로 만들어주는게 좋을지도?<br />
지금은 Alt+F4로만 종료하는데 다른 키 입력이나 우클릭 등 간단하게 종료할 수 있도록 하는게 좋겠지.</p>

<p>pyautogui.click() 함수는 실제 반환 값이 없다고 한다.<br />
예외 또한 거의 발생시키지 않고 클릭을 안하면 그만이라서 <span style="color: orange;"><strong>진짜 클릭 되었는지 판단하기 어렵다고 한다.</strong></span><br />
따라서 클릭 성공과 실패를 위해선 UI 변화를 주고 변화를 통한 클릭 여부 판단을 해야할 듯 하다.<br />
클릭 여부 판정 코드가 없는 지금은 클릭 이벤트를 빼버려도 이미지가 위치를 바꾸는지라…</p>

<p>아무튼 클릭은 잘 해주고 있으니 이번에 배운 것을 다음에 응용하면 되겠다.</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/Python/2025-05-13-Clicker.py">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="one-pan/Python/" /><summary type="html"><![CDATA[탄생 비화 화면을 인식하고 다양한 입력을 받고 싶은데 어떡하지? GUI 뚝딱 만들어내는게 파이썬이 간단해보여서 기초 문법을 공부할 겸 만들어봄 구현 포인트 1. 메인 # 프로그램의 시작점 # C나 java의 main()과 같음 if __name__ == "__main__": # 파이썬은 들여쓰기가 아주 중요함 # 스페이스 4칸이 국룰이라고 함 # 탭 누르면 4칸 들여쓰기가 됨 root = tk.Tk() # tkinter 창을 생성 clicker = Clicker(root) # 게임 객체를 생성 root.mainloop() # 창을 표시하고 이벤트 루프를 시작, 없으면 창이 열렸다가 바로 닫힘 # 만약 창을 닫으면? # 1. root.mainloop() 종료 # 2. clicker 객체가 더 이상 사용되지 않음 # 3. __del__ 함수가 자동으로 호출됨 # 4. self.running = False로 설정되어 자동 클릭 스레드가 종료됨 2. 초기화 # 초기화 함수, 이름이 반드시 __init__이어야 동작함 # self는 js로 치면 this # root는 외부 인자, tkinter로 만든 GUI 객체 def __init__(self, root): self.root = root # 메인 창 객체를 저장 self.root.title("Clicker") # 창의 제목 self.root.geometry("800x600") # 창의 크기 # 게임이 진행될 캔버스를 생성 self.canvas = tk.Canvas(root, width=800, height=600, bg="white") self.canvas.pack() # 캔버스를 창에 배치해야 보임 # 현재 실행 중인 파일의 경로 current_dir = os.path.dirname(os.path.abspath(__file__)) self.image_path = os.path.join(current_dir, "target.png") # 이미지 파일의 전체 경로를 생성 # 이미지 파일을 열고 tkinter에서 사용할 수 있는 형태로 변환 self.image = Image.open(self.image_path) self.tk_image = ImageTk.PhotoImage(self.image) # 이미지 객체와 점수 텍스트를 저장할 변수를 초기화 # 파이썬은 타입 선언만 하면 안되고 값 할당을 해야함 self.image_obj = None self.score_text = None # 초기 이미지와 점수를 화면에 표시 self.update_image() self.update_score() # 자동 클릭을 위한 스레드 시작 # 스레드를 분리하지 않으면 클릭 함수가 실행되는 동안 GUI 창이 멈춤 self.running = True # 스레드 실행 상태를 저장, 프로그램 종료 시 스레드 종료 threading.Thread(target=self.auto_click, daemon=True).start() # 백그라운드에서 자동 클릭 스레드 실행 3. 클릭 # 자동으로 이미지를 클릭하는 함수 def auto_click(self): global CLICK_COUNT # 전역 변수 CLICK_COUNT를 사용, global 선언하지 않으면 지역변수로 처리 while self.running: # running이 True인 동안 계속 실행 try: # 화면에서 이미지 찾기 (70% 일치도) location = pyautogui.locateOnScreen(self.image_path, confidence=0.7) if location: # 이미지의 중앙 좌표를 계산 center_x = location.left + location.width // 2 center_y = location.top + location.height // 2 pyautogui.click(center_x, center_y) # 해당 위치 클릭 CLICK_COUNT += 1 # 클릭 횟수 증가 # 이미지 위치 변경 self.root.after(0, self.update_image) time.sleep(0.1) # 0.1초 대기 (클릭 간격 조절) except Exception as e: if str(e): # 오류 메시지가 있을 때만 출력 print(f"자동 클릭 중 오류 발생: {e}") time.sleep(0.5) # 오류 발생 시 0.5초 대기 완성 반성 이미지 생성 위치는 이미지의 크기를 고려하여 동적으로 정할 수 있을 것 같다. 그리고 마우스가 번쩍번쩍 움직여서 종료 트리거를 따로 만들어주는게 좋을지도? 지금은 Alt+F4로만 종료하는데 다른 키 입력이나 우클릭 등 간단하게 종료할 수 있도록 하는게 좋겠지. pyautogui.click() 함수는 실제 반환 값이 없다고 한다. 예외 또한 거의 발생시키지 않고 클릭을 안하면 그만이라서 진짜 클릭 되었는지 판단하기 어렵다고 한다. 따라서 클릭 성공과 실패를 위해선 UI 변화를 주고 변화를 통한 클릭 여부 판단을 해야할 듯 하다. 클릭 여부 판정 코드가 없는 지금은 클릭 이벤트를 빼버려도 이미지가 위치를 바꾸는지라… 아무튼 클릭은 잘 해주고 있으니 이번에 배운 것을 다음에 응용하면 되겠다. 코드 확인 Link to GitHub]]></summary></entry><entry><title type="html">파일 복사기</title><link href="https://movingwoo.com/one-pan/shellscript/2025/05/12/File-Copier.html" rel="alternate" type="text/html" title="파일 복사기" /><published>2025-05-12T07:00:00+00:00</published><updated>2025-05-12T07:00:00+00:00</updated><id>https://movingwoo.com/one-pan/shellscript/2025/05/12/File%20Copier</id><content type="html" xml:base="https://movingwoo.com/one-pan/shellscript/2025/05/12/File-Copier.html"><![CDATA[<blockquote>
  <h4 id="탄생-비화">탄생 비화</h4>
  <hr />
</blockquote>

<p>리눅스 파일 100개를 일일이 복사하려는 안타까운 광경을 보고 대충 투닥투닥 만들어줌…</p>

<blockquote>
  <h4 id="구현-포인트">구현 포인트</h4>
  <hr />
</blockquote>

<h5 id="1-입력받기">1. 입력받기</h5>

<p>파일과 복사할 숫자를 입력받고 없으면 예외처리해준다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">read</span> <span class="nt">-p</span> <span class="s2">"파일명 입력 (확장자 포함) : "</span> FILENAME

<span class="k">if</span> <span class="o">[</span> <span class="o">!</span> <span class="nt">-e</span> <span class="s2">"</span><span class="nv">$FILENAME</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"파일이 없음..."</span>
  <span class="nb">exit </span>1
<span class="k">fi

</span><span class="nb">read</span> <span class="nt">-p</span> <span class="s2">"복사할 개수 (숫자) : "</span> COUNT

<span class="k">if</span> <span class="o">[[</span> <span class="o">!</span> <span class="nv">$COUNT</span> <span class="o">=</span>~ ^[0-9]+<span class="nv">$ </span><span class="o">]]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"숫자가 아님..."</span>
  <span class="nb">exit </span>1
<span class="k">fi</span>
</code></pre></div></div>

<h5 id="2-복사">2. 복사</h5>

<p>인덱스를 1부터 잡고 반복문을 돌려 파일을 생성한다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for </span>i <span class="k">in</span> <span class="si">$(</span><span class="nb">seq </span>1 <span class="nv">$COUNT</span><span class="si">)</span>
<span class="k">do
  </span><span class="nb">cp</span> <span class="nt">-r</span> <span class="s2">"</span><span class="nv">$FILENAME</span><span class="s2">"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">FILENAME</span><span class="p">%.*</span><span class="k">}</span><span class="nv">$i</span><span class="s2">.</span><span class="k">${</span><span class="nv">FILENAME</span><span class="p">##*.</span><span class="k">}</span><span class="s2">"</span>
  <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$i</span><span class="s2">/</span><span class="nv">$COUNT</span><span class="s2"> 진행 중.."</span>
<span class="k">done

</span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$COUNT</span><span class="s2"> 개 복사 완료!!"</span>
</code></pre></div></div>

<blockquote>
  <h4 id="완성">완성</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/one-pan/ShellScript/2025-05-12-File Copier/img01.jpg" alt="img01" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>같은 경로에 있는 파일만 되는데 제대로 할거면</p>
<ul>
  <li>복사할 파일 경로</li>
  <li>복사 위치</li>
  <li>파일명 규칙</li>
</ul>

<p>이렇게 받아야하지 않을까?</p>

<p>다음에 해봐야겠다.</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/ShellScript/2025-05-12-File%20Copier.sh">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="one-pan/ShellScript/" /><summary type="html"><![CDATA[탄생 비화 리눅스 파일 100개를 일일이 복사하려는 안타까운 광경을 보고 대충 투닥투닥 만들어줌… 구현 포인트 1. 입력받기 파일과 복사할 숫자를 입력받고 없으면 예외처리해준다. read -p "파일명 입력 (확장자 포함) : " FILENAME if [ ! -e "$FILENAME" ]; then echo "파일이 없음..." exit 1 fi read -p "복사할 개수 (숫자) : " COUNT if [[ ! $COUNT =~ ^[0-9]+$ ]]; then echo "숫자가 아님..." exit 1 fi 2. 복사 인덱스를 1부터 잡고 반복문을 돌려 파일을 생성한다. for i in $(seq 1 $COUNT) do cp -r "$FILENAME" "${FILENAME%.*}$i.${FILENAME##*.}" echo "$i/$COUNT 진행 중.." done echo "$COUNT 개 복사 완료!!" 완성 반성 같은 경로에 있는 파일만 되는데 제대로 할거면 복사할 파일 경로 복사 위치 파일명 규칙 이렇게 받아야하지 않을까? 다음에 해봐야겠다. 코드 확인 Link to GitHub]]></summary></entry><entry><title type="html">숫자야구</title><link href="https://movingwoo.com/one-pan/java/2025/05/11/Bulls-and-Cows.html" rel="alternate" type="text/html" title="숫자야구" /><published>2025-05-11T22:00:00+00:00</published><updated>2025-05-11T22:00:00+00:00</updated><id>https://movingwoo.com/one-pan/java/2025/05/11/Bulls%20and%20Cows</id><content type="html" xml:base="https://movingwoo.com/one-pan/java/2025/05/11/Bulls-and-Cows.html"><![CDATA[<blockquote>
  <h4 id="탄생-비화">탄생 비화</h4>
  <hr />
</blockquote>

<p><span style="color: orange;"><strong>숫자야구 져서 꼴받아서</strong></span><br />
처음에는 전체 숫자 풀에서 틀린 후보를 삭제해가는 식으로 했는데<br />
Knuth 전략을 이용하면 6턴 내 클리어가 보장된다고 하여 공부할 겸 만들어 봄</p>

<blockquote>
  <h4 id="구현-포인트">구현 포인트</h4>
  <hr />
</blockquote>

<h5 id="1-피드백-클래스-생성">1. 피드백 클래스 생성</h5>

<p>Knuth 전략의 핵심은 최악의 경우를 최소화하는 것이다.<br />
각 추측마다 가능한 모든 피드백 그룹을 만들고, 가장 큰 그룹의 크기를 최소화한다.<br />
피드백 그룹을 비교하기 위해 피드백 클래스를 생성해 관리한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 피드백 결과를 구조화해서 비교하고 후보군을 나누기 위해 피드백 클래스 생성</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Feedback</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">strikes</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">balls</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">Feedback</span><span class="o">(</span><span class="kt">int</span> <span class="n">strikes</span><span class="o">,</span> <span class="kt">int</span> <span class="n">balls</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">strikes</span> <span class="o">=</span> <span class="n">strikes</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">balls</span> <span class="o">=</span> <span class="n">balls</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">object</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(!(</span><span class="n">object</span> <span class="k">instanceof</span> <span class="nc">Feedback</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    
    <span class="nc">Feedback</span> <span class="n">feedback</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Feedback</span><span class="o">)</span> <span class="n">object</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">strikes</span> <span class="o">==</span> <span class="n">feedback</span><span class="o">.</span><span class="na">strikes</span> <span class="o">&amp;&amp;</span> <span class="n">balls</span> <span class="o">==</span> <span class="n">feedback</span><span class="o">.</span><span class="na">balls</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// Map에서 올바르게 비교되도록 해시코드 설정</span>
    <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">hash</span><span class="o">(</span><span class="n">strikes</span><span class="o">,</span> <span class="n">balls</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h5 id="2-최적의-추측-선택">2. 최적의 추측 선택</h5>

<p>남은 후보군, 전체 후보군을 받아서 최악의 경우를 계산한다.<br />
피드백 그룹의 크기를 최악의 경우로 판단해서 그 숫자가 가장 작은 것을 선택한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 최적 추측 선택</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">chooseBestGuess</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">candidates</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">allCandidates</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">triedGuesses</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">minWorst</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
  <span class="nc">String</span> <span class="n">bestGuess</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

  <span class="c1">// 모든 추측을 가지고 후보군과 비교해 가장 피드백이 많이 나오는 그룹 수를 계산한다(최악의 경우)</span>
  <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">guess</span> <span class="o">:</span> <span class="n">allCandidates</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 이미 시도한 추측은 건너뛰기</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">triedGuesses</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">guess</span><span class="o">))</span> <span class="k">continue</span><span class="o">;</span>

    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Feedback</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">actual</span> <span class="o">:</span> <span class="n">candidates</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">Feedback</span> <span class="n">f</span> <span class="o">=</span> <span class="n">getFeedback</span><span class="o">(</span><span class="n">actual</span><span class="o">,</span> <span class="n">guess</span><span class="o">);</span>
      <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">// Knuth 전략의 핵심, 최악의 경우 계산 (가장 많은 후보가 남는 경우)</span>
    <span class="kt">int</span> <span class="n">worst</span> <span class="o">=</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">values</span><span class="o">());</span>
    
    <span class="c1">// 더 나은 추측을 찾았거나, 동일한 최악의 경우에서 더 작은 숫자를 선택</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">worst</span> <span class="o">&lt;</span> <span class="n">minWorst</span> <span class="o">||</span> <span class="o">(</span><span class="n">worst</span> <span class="o">==</span> <span class="n">minWorst</span> <span class="o">&amp;&amp;</span> <span class="n">guess</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">bestGuess</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">minWorst</span> <span class="o">=</span> <span class="n">worst</span><span class="o">;</span>
      <span class="n">bestGuess</span> <span class="o">=</span> <span class="n">guess</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">return</span> <span class="n">bestGuess</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h5 id="3-입력-받아-판단-수행">3. 입력 받아 판단 수행</h5>

<p>추측에 대한 결과를 입력받아 다음 추측을 제시하는 부분.<br />
최종적인 답이 나올때 까지 반복문을 돌린다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// 1턴에서는 추측이 의미 없으므로 1234를 제시하고 결과를 받도록 한다.</span>
  <span class="nc">String</span> <span class="n">guess</span> <span class="o">=</span> <span class="s">"1234"</span><span class="o">;</span>
  
  <span class="k">if</span> <span class="o">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">guess</span> <span class="o">=</span> <span class="n">chooseBestGuess</span><span class="o">(</span><span class="n">candidates</span><span class="o">,</span> <span class="n">allCandidates</span><span class="o">,</span> <span class="n">triedGuesses</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="n">triedGuesses</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">guess</span><span class="o">);</span>  <span class="c1">// 시도한 추측 기록</span>

  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">turn</span> <span class="o">+</span> <span class="s">"턴) 추천 추측: "</span> <span class="o">+</span> <span class="n">guess</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"입력 (예: 1s2b / 3s / 2b / o): "</span><span class="o">);</span>
  <span class="c1">// 추천 추측에 대한 결과를 입력받는다.</span>
  <span class="nc">String</span> <span class="n">input</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextLine</span><span class="o">().</span><span class="na">trim</span><span class="o">().</span><span class="na">toLowerCase</span><span class="o">();</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">input</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">input</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"입력 없음"</span><span class="o">);</span>
    <span class="k">continue</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kt">int</span> <span class="n">strikes</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">balls</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

  <span class="c1">// 정규식으로 스트라이크 볼 패턴 구분</span>
  <span class="nc">Pattern</span> <span class="n">pattern</span> <span class="o">=</span> <span class="nc">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">"^(\\d+s)?(\\d+b)?$|^(\\d+b)?(\\d+s)?$"</span><span class="o">);</span>
  
  <span class="k">if</span> <span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"o"</span><span class="o">))</span> <span class="o">{</span>
    <span class="c1">// 아웃은 0s0b 따로 할 거 없음</span>
    <span class="n">strikes</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">balls</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">pattern</span><span class="o">.</span><span class="na">matcher</span><span class="o">(</span><span class="n">input</span><span class="o">).</span><span class="na">matches</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">Matcher</span> <span class="n">m</span> <span class="o">=</span> <span class="nc">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">"(\\d+)s|(\\d+)b"</span><span class="o">).</span><span class="na">matcher</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">find</span><span class="o">())</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">strikes</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
      <span class="o">}</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">balls</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"잘못된 입력 형식"</span><span class="o">);</span>
    <span class="k">continue</span><span class="o">;</span>
  <span class="o">}</span>
  
  <span class="nc">Feedback</span> <span class="n">feedback</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Feedback</span><span class="o">(</span><span class="n">strikes</span><span class="o">,</span> <span class="n">balls</span><span class="o">);</span>
  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">filter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
  
  <span class="c1">// 피드백을 입력받으면 정확히 일치하는 후보만 남김</span>
  <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">c</span> <span class="o">:</span> <span class="n">candidates</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">getFeedback</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">guess</span><span class="o">).</span><span class="na">equals</span><span class="o">(</span><span class="n">feedback</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">filter</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
  
  <span class="c1">// 필터가 비면 잘못된 것...</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">filter</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"후보가 없습니다. 입력값을 확인해 주세요."</span><span class="o">);</span>
    <span class="k">continue</span><span class="o">;</span>
  <span class="o">}</span>
  
  <span class="c1">// 후보군을 필터로 갱신</span>
  <span class="n">candidates</span> <span class="o">=</span> <span class="n">filter</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">candidates</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 유일한 정답 출력 후 종료</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"정답: "</span> <span class="o">+</span> <span class="n">candidates</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
    <span class="k">break</span><span class="o">;</span>
  <span class="o">}</span>
  
  <span class="n">turn</span><span class="o">++;</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="완성">완성</h4>
  <hr />
</blockquote>

<p>1차 테스트 숫자는 <span style="color: orange;"><strong>4865</strong></span></p>

<p><img src="/assets/images/posts/one-pan/Java/2025-05-12-Bulls and Cows/img01.jpg" alt="img01" /></p>

<p>2차 테스트 숫자는 <span style="color: orange;"><strong>0918</strong></span></p>

<p><img src="/assets/images/posts/one-pan/Java/2025-05-12-Bulls and Cows/img02.jpg" alt="img02" /></p>

<p>3차 테스트 숫자는 <span style="color: orange;"><strong>2580</strong></span></p>

<p><img src="/assets/images/posts/one-pan/Java/2025-05-12-Bulls and Cows/img03.jpg" alt="img03" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>사실 이 상태에서는 아웃에 대한 판단이 잘못되어있다.<br />
숫자 4개를 통으로 날릴 수 있는 아웃이 아무리 생각해도 최대 효율인데 왜 최악으로 판단되지?</p>

<p>Knuth 전략에서는 피드백 그룹의 크기로 최악의 그룹을 찾는다.<br />
<span style="color: orange;"><strong>그런데 아웃의 경우 (0s0b) 그룹에 속하는 후보가 많을 수 있어서 최악의 경우로 판단된다.</strong></span></p>
<ul>
  <li>인간) 4개 다 아니네? 개꿀 ㅋㅋㅋㅋ</li>
  <li>깡통) 0s0b 그룹이 너무 많네? 이것은 최악의 경우이다.</li>
</ul>

<p>최적화를 위해서는 단순히 그룹의 크기로만 판단하지 않고 <span style="color: orange;"><strong>정보량을 고려</strong></span>해야 한다.<br />
아웃에 가중치를 주고 <span style="color: orange;"><strong>아웃을 우수한 추측으로 간주</strong></span>하도록 설정(점수제 도입)하면 더 나은 로직을 짤 수 있다.</p>

<p>하지만 현 상태로도 6턴 내 클리어가 보장되며, 감히 숫자야구 덤비는 애송이들의 뚝배기를 조각낼 수 있기 때문에 여기서 스탑.</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/Java/2025-05-12-Bulls%20and%20Cows.java">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="one-pan/Java/" /><summary type="html"><![CDATA[탄생 비화 숫자야구 져서 꼴받아서 처음에는 전체 숫자 풀에서 틀린 후보를 삭제해가는 식으로 했는데 Knuth 전략을 이용하면 6턴 내 클리어가 보장된다고 하여 공부할 겸 만들어 봄 구현 포인트 1. 피드백 클래스 생성 Knuth 전략의 핵심은 최악의 경우를 최소화하는 것이다. 각 추측마다 가능한 모든 피드백 그룹을 만들고, 가장 큰 그룹의 크기를 최소화한다. 피드백 그룹을 비교하기 위해 피드백 클래스를 생성해 관리한다. // 피드백 결과를 구조화해서 비교하고 후보군을 나누기 위해 피드백 클래스 생성 private static class Feedback { int strikes; int balls; public Feedback(int strikes, int balls) { this.strikes = strikes; this.balls = balls; } @Override public boolean equals(Object object) { if (this == object) return true; if (!(object instanceof Feedback)) return false; Feedback feedback = (Feedback) object; return strikes == feedback.strikes &amp;&amp; balls == feedback.balls; } @Override public int hashCode() { // Map에서 올바르게 비교되도록 해시코드 설정 return Objects.hash(strikes, balls); } } 2. 최적의 추측 선택 남은 후보군, 전체 후보군을 받아서 최악의 경우를 계산한다. 피드백 그룹의 크기를 최악의 경우로 판단해서 그 숫자가 가장 작은 것을 선택한다. // 최적 추측 선택 private static String chooseBestGuess(List&lt;String&gt; candidates, List&lt;String&gt; allCandidates, Set&lt;String&gt; triedGuesses) { int minWorst = Integer.MAX_VALUE; String bestGuess = null; // 모든 추측을 가지고 후보군과 비교해 가장 피드백이 많이 나오는 그룹 수를 계산한다(최악의 경우) for (String guess : allCandidates) { // 이미 시도한 추측은 건너뛰기 if (triedGuesses.contains(guess)) continue; Map&lt;Feedback, Integer&gt; map = new HashMap&lt;&gt;(); for (String actual : candidates) { Feedback f = getFeedback(actual, guess); map.put(f, map.getOrDefault(f, 0) + 1); } // Knuth 전략의 핵심, 최악의 경우 계산 (가장 많은 후보가 남는 경우) int worst = Collections.max(map.values()); // 더 나은 추측을 찾았거나, 동일한 최악의 경우에서 더 작은 숫자를 선택 if (worst &lt; minWorst || (worst == minWorst &amp;&amp; guess.compareTo(bestGuess) &lt; 0)) { minWorst = worst; bestGuess = guess; } } return bestGuess; } 3. 입력 받아 판단 수행 추측에 대한 결과를 입력받아 다음 추측을 제시하는 부분. 최종적인 답이 나올때 까지 반복문을 돌린다. while (true) { // 1턴에서는 추측이 의미 없으므로 1234를 제시하고 결과를 받도록 한다. String guess = "1234"; if (turn != 1) { guess = chooseBestGuess(candidates, allCandidates, triedGuesses); } triedGuesses.add(guess); // 시도한 추측 기록 System.out.println(turn + "턴) 추천 추측: " + guess); System.out.print("입력 (예: 1s2b / 3s / 2b / o): "); // 추천 추측에 대한 결과를 입력받는다. String input = sc.nextLine().trim().toLowerCase(); if (input == null || input.length() == 0) { System.out.println("입력 없음"); continue; } int strikes = 0; int balls = 0; // 정규식으로 스트라이크 볼 패턴 구분 Pattern pattern = Pattern.compile("^(\\d+s)?(\\d+b)?$|^(\\d+b)?(\\d+s)?$"); if (input.equals("o")) { // 아웃은 0s0b 따로 할 거 없음 strikes = 0; balls = 0; } else if (pattern.matcher(input).matches()) { Matcher m = Pattern.compile("(\\d+)s|(\\d+)b").matcher(input); while (m.find()) { if (m.group(1) != null) { strikes = Integer.parseInt(m.group(1)); } if (m.group(2) != null) { balls = Integer.parseInt(m.group(2)); } } } else { System.out.println("잘못된 입력 형식"); continue; } Feedback feedback = new Feedback(strikes, balls); List&lt;String&gt; filter = new ArrayList&lt;&gt;(); // 피드백을 입력받으면 정확히 일치하는 후보만 남김 for (String c : candidates) { if (getFeedback(c, guess).equals(feedback)) { filter.add(c); } } // 필터가 비면 잘못된 것... if (filter.isEmpty()) { System.out.println("후보가 없습니다. 입력값을 확인해 주세요."); continue; } // 후보군을 필터로 갱신 candidates = filter; if (candidates.size() == 1) { // 유일한 정답 출력 후 종료 System.out.println("정답: " + candidates.get(0)); break; } turn++; } 완성 1차 테스트 숫자는 4865 2차 테스트 숫자는 0918 3차 테스트 숫자는 2580 반성 사실 이 상태에서는 아웃에 대한 판단이 잘못되어있다. 숫자 4개를 통으로 날릴 수 있는 아웃이 아무리 생각해도 최대 효율인데 왜 최악으로 판단되지? Knuth 전략에서는 피드백 그룹의 크기로 최악의 그룹을 찾는다. 그런데 아웃의 경우 (0s0b) 그룹에 속하는 후보가 많을 수 있어서 최악의 경우로 판단된다. 인간) 4개 다 아니네? 개꿀 ㅋㅋㅋㅋ 깡통) 0s0b 그룹이 너무 많네? 이것은 최악의 경우이다. 최적화를 위해서는 단순히 그룹의 크기로만 판단하지 않고 정보량을 고려해야 한다. 아웃에 가중치를 주고 아웃을 우수한 추측으로 간주하도록 설정(점수제 도입)하면 더 나은 로직을 짤 수 있다. 하지만 현 상태로도 6턴 내 클리어가 보장되며, 감히 숫자야구 덤비는 애송이들의 뚝배기를 조각낼 수 있기 때문에 여기서 스탑. 코드 확인 Link to GitHub]]></summary></entry></feed>