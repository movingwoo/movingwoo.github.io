<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://movingwoo.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://movingwoo.com/" rel="alternate" type="text/html" hreflang="ko-KR" /><updated>2025-06-05T01:26:22+00:00</updated><id>https://movingwoo.com/feed.xml</id><title type="html">뭐라도 하겠지</title><subtitle>나도 사람인데 뭐라도 하겠지</subtitle><entry><title type="html">2784번 가로 세로 퍼즐</title><link href="https://movingwoo.com/random-solve/java/2025/06/04/2784.html" rel="alternate" type="text/html" title="2784번 가로 세로 퍼즐" /><published>2025-06-04T07:00:00+00:00</published><updated>2025-06-04T07:00:00+00:00</updated><id>https://movingwoo.com/random-solve/java/2025/06/04/2784</id><content type="html" xml:base="https://movingwoo.com/random-solve/java/2025/06/04/2784.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Java/2025-06-04-2784/img01.webp" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/2784">2784번 가로 세로 퍼즐 - 백준</a></p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p><span style="color: orange;"><strong>개똥아</strong></span><br />
<span style="color: orange;"><strong>똥쌌니</strong></span><br />
<span style="color: orange;"><strong>아니오</strong></span><br />
를 만드는 문제</p>

<p>생각보다… 조건이 복잡한건가?
일단 모든 단어 6개가 들어가야하니 중복 체크가 필요하고<br />
출력 시 사전순으로 앞서는 것을 출력하라고 되어있는데<br />
가로3개-&gt;세로3개 순으로 사전순인가? 가로-&gt;세로-&gt;가로-&gt;세로-&gt;가로-&gt;세로 순인가?<br />
도통 알 수 없다.</p>

<p>단어 6개 밖에 안들어오기 때문에 하나씩 넣으면서 시뮬레이션 돌려보면 되려나?<br />
대충 하나하나 다 갖다박아보자.</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-세로-단어-추출">1. 세로 단어 추출</h5>

<p>일단 사전 순서대로 들어온다고 하니 i, j, k 인덱스를 잡아서 순서대로 가로로 배치한다.<br />
그리고 세로 단어를 뽑아서 존재하는 단어인지 확인한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">6</span> <span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">6</span> <span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">k</span> <span class="o">||</span> <span class="n">j</span> <span class="o">==</span> <span class="n">k</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
			
			<span class="nc">String</span> <span class="n">horizontalWord1</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
			<span class="nc">String</span> <span class="n">horizontalWord2</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
			<span class="nc">String</span> <span class="n">horizontalWord3</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">k</span><span class="o">);</span>
			
			<span class="c1">// 만든 단어</span>
			<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">used</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
			
			<span class="kt">int</span> <span class="n">putCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
			<span class="c1">// 세로 줄 단어 생성</span>
			<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">;</span> <span class="n">l</span><span class="o">++)</span> <span class="o">{</span>
				<span class="nc">String</span> <span class="n">verticalWord</span> <span class="o">=</span> <span class="s">""</span> <span class="o">+</span> <span class="n">horizontalWord1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">l</span><span class="o">)</span> <span class="o">+</span> <span class="n">horizontalWord2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">l</span><span class="o">)</span> <span class="o">+</span> <span class="n">horizontalWord3</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">l</span><span class="o">);</span>
				
				<span class="c1">// 세로단어가 존재하지 않는 단어면 통과</span>
				<span class="k">if</span> <span class="o">(!</span><span class="n">words</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">verticalWord</span><span class="o">))</span> <span class="k">break</span><span class="o">;</span>
				
				<span class="n">used</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">verticalWord</span><span class="o">,</span> <span class="n">used</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">verticalWord</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
				<span class="n">putCount</span><span class="o">++;</span>
			<span class="o">}</span>
			
			<span class="c1">// 3번 안넣었으면 굳이 더 볼 필요 없음</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">putCount</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
			
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h5 id="2-단어가-모이면-비교">2. 단어가 모이면 비교</h5>

<p>입력으로 중복이 들어올 수 있어서 Set은 사용하면 안된다.<br />
입력 받을때 단어 사용 횟수를 저장하는 Map을 만들고<br />
세로단어 생성 후 나온 퍼즐의 Map과 비교해 유효한지 판단한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="c1">// 비교 시 중복때문에 Set을 못써서 Map 사용</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
	<span class="nc">String</span> <span class="n">word</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
	<span class="n">words</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
	<span class="n">count</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">count</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// ... 중략 ...</span>

<span class="kt">boolean</span> <span class="n">valid</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
<span class="c1">// 비교</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">used</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">!=</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">()))</span> <span class="o">{</span>
		<span class="n">valid</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
		<span class="k">break</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="k">if</span> <span class="o">(</span><span class="n">valid</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">result</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
	<span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">horizontalWord1</span><span class="o">);</span>
	<span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"\n"</span><span class="o">);</span>
	<span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">horizontalWord2</span><span class="o">);</span>
	<span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"\n"</span><span class="o">);</span>
	<span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">horizontalWord3</span><span class="o">);</span>
	<span class="k">break</span> <span class="n">exit</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Java/2025-06-04-2784/img02.webp" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>입력이 너무 적어서 아무 의미 없겠지만 생각해보자.<br />
이거 입력이 터져 나가는 경우엔 어떻게 풀어야하지?<br />
가로줄을 추가할 때마다 세로줄을 추출해서 접두사 검색을 해봐야하나?<br />
그럼 백트래킹 같은 걸 끼얹고 접두사 검색을 위해 트라이를 써야하는건가…<br />
이거 굉장히 곤란한 문제가 될 수 있겠다.<br />
에잇 끔찍한 소리 치워 꼴도 보기 싫어</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/random-solve/Java/2025-06-04-2784.java">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="random-solve/Java/" /><summary type="html"><![CDATA[문제 2784번 가로 세로 퍼즐 - 백준 설계 개똥아 똥쌌니 아니오 를 만드는 문제 생각보다… 조건이 복잡한건가? 일단 모든 단어 6개가 들어가야하니 중복 체크가 필요하고 출력 시 사전순으로 앞서는 것을 출력하라고 되어있는데 가로3개-&gt;세로3개 순으로 사전순인가? 가로-&gt;세로-&gt;가로-&gt;세로-&gt;가로-&gt;세로 순인가? 도통 알 수 없다. 단어 6개 밖에 안들어오기 때문에 하나씩 넣으면서 시뮬레이션 돌려보면 되려나? 대충 하나하나 다 갖다박아보자. 구현 1. 세로 단어 추출 일단 사전 순서대로 들어온다고 하니 i, j, k 인덱스를 잡아서 순서대로 가로로 배치한다. 그리고 세로 단어를 뽑아서 존재하는 단어인지 확인한다. for (int i = 0 ; i &lt; 6 ; i++) { for (int j = 0 ; j &lt; 6 ; j++) { if (i == j) continue; for (int k = 0 ; k &lt; 6 ; k++) { if (i == k || j == k) continue; String horizontalWord1 = words.get(i); String horizontalWord2 = words.get(j); String horizontalWord3 = words.get(k); // 만든 단어 Map&lt;String, Integer&gt; used = new HashMap&lt;&gt;(); int putCount = 0; // 세로 줄 단어 생성 for (int l = 0 ; l &lt; 3 ; l++) { String verticalWord = "" + horizontalWord1.charAt(l) + horizontalWord2.charAt(l) + horizontalWord3.charAt(l); // 세로단어가 존재하지 않는 단어면 통과 if (!words.contains(verticalWord)) break; used.put(verticalWord, used.getOrDefault(verticalWord, 0) + 1); putCount++; } // 3번 안넣었으면 굳이 더 볼 필요 없음 if (putCount &lt; 3) continue; } } } 2. 단어가 모이면 비교 입력으로 중복이 들어올 수 있어서 Set은 사용하면 안된다. 입력 받을때 단어 사용 횟수를 저장하는 Map을 만들고 세로단어 생성 후 나온 퍼즐의 Map과 비교해 유효한지 판단한다. List&lt;String&gt; words = new ArrayList&lt;&gt;(); // 비교 시 중복때문에 Set을 못써서 Map 사용 Map&lt;String, Integer&gt; count = new HashMap&lt;&gt;(); for (int i = 0 ; i &lt; 6 ; i++) { String word = br.readLine(); words.add(word); count.put(word, count.getOrDefault(word, 0) + 1); } // ... 중략 ... boolean valid = true; // 비교 for (Map.Entry&lt;String, Integer&gt; entry : used.entrySet()) { if (entry.getValue() != count.get(entry.getKey())) { valid = false; break; } } if (valid) { result = true; bw.write(horizontalWord1); bw.write("\n"); bw.write(horizontalWord2); bw.write("\n"); bw.write(horizontalWord3); break exit; } 채점 반성 입력이 너무 적어서 아무 의미 없겠지만 생각해보자. 이거 입력이 터져 나가는 경우엔 어떻게 풀어야하지? 가로줄을 추가할 때마다 세로줄을 추출해서 접두사 검색을 해봐야하나? 그럼 백트래킹 같은 걸 끼얹고 접두사 검색을 위해 트라이를 써야하는건가… 이거 굉장히 곤란한 문제가 될 수 있겠다. 에잇 끔찍한 소리 치워 꼴도 보기 싫어 코드 확인 Link to GitHub]]></summary></entry><entry><title type="html">4676번 Haiku Review</title><link href="https://movingwoo.com/random-solve/python/2025/06/04/4676.html" rel="alternate" type="text/html" title="4676번 Haiku Review" /><published>2025-06-04T05:00:00+00:00</published><updated>2025-06-04T05:00:00+00:00</updated><id>https://movingwoo.com/random-solve/python/2025/06/04/4676</id><content type="html" xml:base="https://movingwoo.com/random-solve/python/2025/06/04/4676.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Python/2025-06-04-4676/img01.webp" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/4676">4676번 Haiku Review - 백준</a></p>

<blockquote>
  <h4 id="번역">번역</h4>
  <hr />
</blockquote>

<p>하이쿠는 5/7/5 조의 일본 시다.<br />
입력을 받아 하이쿠가 맞다면 Y 아니라면 잘못된 행의 숫자를 출력하시오.</p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p><span style="color: orange;"><strong>a, e, i, o, u, y</strong></span> 6개를 모음으로 치며 모음이 붙어있는 경우에는 1음절로 친다.</p>

<p>예제의 경우를 확인해보면<br />
h<span style="color: orange;"><strong>a</strong></span>pp<span style="color: orange;"><strong>y</strong></span> p<span style="color: orange;"><strong>u</strong></span>rpl<span style="color: orange;"><strong>e</strong></span> fr<span style="color: orange;"><strong>o</strong></span>g<br />
<span style="color: orange;"><strong>ea</strong></span>t<span style="color: orange;"><strong>i</strong></span>ng b<span style="color: orange;"><strong>u</strong></span>gs <span style="color: orange;"><strong>i</strong></span>n th<span style="color: orange;"><strong>e</strong></span> m<span style="color: orange;"><strong>a</strong></span>rsh<span style="color: orange;"><strong>e</strong></span>s<br />
g<span style="color: orange;"><strong>e</strong></span>t <span style="color: orange;"><strong>i</strong></span>nd<span style="color: orange;"><strong>i</strong></span>g<span style="color: orange;"><strong>e</strong></span>sti<span style="color: orange;"><strong>o</strong></span>n</p>

<p>그래서 Y로 볼 수 있다.</p>

<p>아니 이거 정규식 짜면 한 방 아닌가?</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<p>정규식은 <span style="color: orange;"><strong>[aeiouy]+</strong></span> 을 사용한다.<br />
aeiouy 중 하나 이상(+)의 연속된 그룹을 찾는 정규식이다.</p>

<p>자동으로 찾아주니 분기만 잘 태워주면 끝</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">re</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">haikus</span> <span class="o">=</span> <span class="nf">input</span><span class="p">().</span><span class="nf">strip</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">haikus</span> <span class="o">==</span> <span class="sh">'</span><span class="s">e/o/i</span><span class="sh">'</span><span class="p">:</span>
        <span class="k">break</span>

    <span class="n">haiku</span> <span class="o">=</span> <span class="n">haikus</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">'</span><span class="s">/</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">jo</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>

        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="nf">findall</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">[aeiouy]+</span><span class="sh">'</span><span class="p">,</span> <span class="n">haiku</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">!=</span> <span class="n">jo</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">break</span>

        <span class="n">result</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Y</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Python/2025-06-04-4676/img02.webp" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>예전에 정규식으로 XSS 방지 스크립트 짜던 기억이 떠오른다.<br />
힘들었는데 진짜…</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/random-solve/Python/2025-06-04-4676.py">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="random-solve/Python/" /><summary type="html"><![CDATA[문제 4676번 Haiku Review - 백준 번역 하이쿠는 5/7/5 조의 일본 시다. 입력을 받아 하이쿠가 맞다면 Y 아니라면 잘못된 행의 숫자를 출력하시오. 설계 a, e, i, o, u, y 6개를 모음으로 치며 모음이 붙어있는 경우에는 1음절로 친다. 예제의 경우를 확인해보면 happy purple frog eating bugs in the marshes get indigestion 그래서 Y로 볼 수 있다. 아니 이거 정규식 짜면 한 방 아닌가? 구현 정규식은 [aeiouy]+ 을 사용한다. aeiouy 중 하나 이상(+)의 연속된 그룹을 찾는 정규식이다. 자동으로 찾아주니 분기만 잘 태워주면 끝 import re while True: haikus = input().strip() if haikus == 'e/o/i': break haiku = haikus.split('/') jo = [5, 7, 5] result = 1; for i in range(3): if len(re.findall(r'[aeiouy]+', haiku[i])) != jo[i]: print(result) break result += 1 if result == 4: print('Y') 채점 반성 예전에 정규식으로 XSS 방지 스크립트 짜던 기억이 떠오른다. 힘들었는데 진짜… 코드 확인 Link to GitHub]]></summary></entry><entry><title type="html">WebP 변환기</title><link href="https://movingwoo.com/one-pan/python/2025/06/04/WebP-Converter.html" rel="alternate" type="text/html" title="WebP 변환기" /><published>2025-06-04T02:00:00+00:00</published><updated>2025-06-04T02:00:00+00:00</updated><id>https://movingwoo.com/one-pan/python/2025/06/04/WebP%20Converter</id><content type="html" xml:base="https://movingwoo.com/one-pan/python/2025/06/04/WebP-Converter.html"><![CDATA[<blockquote>
  <h4 id="개요">개요</h4>
  <hr />
</blockquote>

<p>jpg는 화질을 제법 깎아먹어서 용량이 가벼운 편이다.<br />
하지만 지난 포스트를 작성하며 이미지를 더 가볍게 유지할 필요성을 느꼈고<br />
<span style="color: orange;"><strong>webp</strong></span>로 변환하는게 좋겠다는 결론에 도달했다.</p>

<p>그러면 WebP 변환기를 만들어야겠지!!!</p>

<p>변환하며 화질을 살짝 열화시키면 더 효과가 좋을 것이다.<br />
뭐 영화 보는 것도 아니고 고화질 유지할 필요는 없으니</p>

<p>파이썬을 선택한 이유는 간단하다.<br />
딸깍 한 번 하면 필요한 라이브러리가 설치되니까.</p>

<p>자바로 하면 TwelveMonkeys 같은 외부 라이브러리 끌어와야하고<br />
C++하면 libwebp 빌드부터가 귀찮다.</p>

<p>편하게 쓰려고 내가 파이썬을 배웠지</p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>webp로 변환할 타겟 폴더를 선택하는게 좋나, 타겟 이미지가 있는 폴더에 소스코드를 넣어두고 실행시키는게 좋나?<br />
고민 끝에 더 생각없이 쓰려면 후자가 쉽고 빠를 것 같아 후자로 한다.</p>

<p>현재 폴더의 모든 이미지를 타겟 폴더에 webp로 뱉어내도록 한다.</p>

<p>하는 김에 용량 얼마나 줄였는지 디스플레이도 해주면 좋겠다.</p>

<blockquote>
  <h4 id="구현-포인트">구현 포인트</h4>
  <hr />
</blockquote>

<p><span style="color: orange;"><strong>Pillow</strong></span> 라이브러리를 사용한다.</p>

<h5 id="1-기초-코드">1. 기초 코드</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">import</span> <span class="n">os</span>

<span class="c1"># 실행 경로
</span><span class="n">folder</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="nf">getcwd</span><span class="p">()</span>

<span class="c1"># 폴더 내 파일들을 대상으로 변환
</span><span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">os</span><span class="p">.</span><span class="nf">listdir</span><span class="p">(</span><span class="n">folder</span><span class="p">):</span>
    <span class="n">img_path</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
    <span class="n">webp_path</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">splitext</span><span class="p">(</span><span class="n">img_path</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="sh">"</span><span class="s">.webp</span><span class="sh">"</span>
    <span class="n">Image</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="n">img_path</span><span class="p">).</span><span class="nf">save</span><span class="p">(</span><span class="n">webp_path</span><span class="p">,</span> <span class="sh">"</span><span class="s">WEBP</span><span class="sh">"</span><span class="p">,</span> <span class="n">quality</span><span class="o">=</span><span class="mi">80</span><span class="p">)</span> <span class="c1"># 80% 품질
</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">변환 완료</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h5 id="2-세부-설정">2. 세부 설정</h5>

<p>예외처리를 위해 이미지 확장자를 제한한다.<br />
jpg와 png, gif 3종류면 되겠지 뭐.</p>

<p>그리고 변환 전후로 용량을 확인해 print 시 표시해준다.</p>

<p>gif 파일은 그냥 변환하면 애니메이션이 사라지므로 따로 분기를 태워준다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># jpg, png, gif
</span><span class="k">if</span> <span class="n">filename</span><span class="p">.</span><span class="nf">lower</span><span class="p">().</span><span class="nf">endswith</span><span class="p">((</span><span class="sh">"</span><span class="s">.jpg</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">.jpeg</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">.png</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">.gif</span><span class="sh">"</span><span class="p">)):</span>
    <span class="n">img_path</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
    <span class="n">webp_path</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">target_folder</span><span class="p">,</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">splitext</span><span class="p">(</span><span class="n">filename</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="sh">"</span><span class="s">.webp</span><span class="sh">"</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">Image</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="n">img_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">img</span><span class="p">:</span>
        <span class="c1"># gif는 애니메이션 때문에 특수 처리
</span>        <span class="k">if</span> <span class="n">img</span><span class="p">.</span><span class="nb">format</span> <span class="o">==</span> <span class="sh">"</span><span class="s">GIF</span><span class="sh">"</span> <span class="ow">and</span> <span class="nf">getattr</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="sh">"</span><span class="s">is_animated</span><span class="sh">"</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">durations</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># 그냥 변환하면 너무 느려서 duration 직접 추출
</span>            <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">ImageSequence</span><span class="p">.</span><span class="nc">Iterator</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
                <span class="n">frames</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="nf">copy</span><span class="p">())</span>
                <span class="n">durations</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="sh">"</span><span class="s">duration</span><span class="sh">"</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span> 

            <span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">save</span><span class="p">(</span>
                <span class="n">webp_path</span><span class="p">,</span>
                <span class="sh">"</span><span class="s">WEBP</span><span class="sh">"</span><span class="p">,</span>
                <span class="n">save_all</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                <span class="n">append_images</span><span class="o">=</span><span class="n">frames</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                <span class="n">duration</span><span class="o">=</span><span class="n">durations</span><span class="p">,</span>
                <span class="n">loop</span><span class="o">=</span><span class="n">img</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="sh">"</span><span class="s">loop</span><span class="sh">"</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                <span class="n">quality</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># 애니메이션 없으면 그냥 변환
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">img</span><span class="p">.</span><span class="nf">save</span><span class="p">(</span><span class="n">webp_path</span><span class="p">,</span> <span class="sh">"</span><span class="s">WEBP</span><span class="sh">"</span><span class="p">,</span> <span class="n">quality</span><span class="o">=</span><span class="mi">80</span><span class="p">)</span>

    <span class="c1"># 용량 확인 (kb)
</span>    <span class="n">before_size</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">getsize</span><span class="p">(</span><span class="n">img_path</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1024</span>
    <span class="n">after_size</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">getsize</span><span class="p">(</span><span class="n">webp_path</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1024</span>

    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s"> 변환 완료</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">after_size</span> <span class="o">&gt;</span> <span class="n">before_size</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">↑↑증가↑↑ </span><span class="si">{</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">before_size</span> <span class="o">/</span> <span class="n">after_size</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="si">:</span><span class="p">.</span><span class="mi">1</span><span class="n">f</span><span class="si">}</span><span class="s">% (</span><span class="si">{</span><span class="n">before_size</span><span class="si">:</span><span class="p">.</span><span class="mi">1</span><span class="n">f</span><span class="si">}</span><span class="s">kb -&gt; </span><span class="si">{</span><span class="n">after_size</span><span class="si">:</span><span class="p">.</span><span class="mi">1</span><span class="n">f</span><span class="si">}</span><span class="s">kb)</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">↓↓감소↓↓ </span><span class="si">{</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">after_size</span> <span class="o">/</span> <span class="n">before_size</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="si">:</span><span class="p">.</span><span class="mi">1</span><span class="n">f</span><span class="si">}</span><span class="s">% (</span><span class="si">{</span><span class="n">before_size</span><span class="si">:</span><span class="p">.</span><span class="mi">1</span><span class="n">f</span><span class="si">}</span><span class="s">kb -&gt; </span><span class="si">{</span><span class="n">after_size</span><span class="si">:</span><span class="p">.</span><span class="mi">1</span><span class="n">f</span><span class="si">}</span><span class="s">kb)</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <h4 id="완성">완성</h4>
  <hr />
</blockquote>

<p>테스트 이미지 파일 몇개 넣어놓고 돌려보았다.</p>

<p><img src="/assets/images/posts/one-pan/Python/2025-06-04-WebP Converter/img01.webp" alt="img01" /></p>

<p><span style="color: red;"><strong>gif는 용량이 오히려 늘어날 수 있다!!!</strong></span><br />
변환해보고 webp가 오히려 용량이 많은 경우 gif를 그대로 써야겠다.</p>

<p>늘어난 파일 제외하고 테스트 이미지 파일 압축 시 용량변화는 아래와 같다.</p>

<p><img src="/assets/images/posts/one-pan/Python/2025-06-04-WebP Converter/img02.webp" alt="img02" /></p>

<p><span style="color: orange;"><strong>18.1mb에서 4.51mb로 줄였으니 75% 가량 줄인 셈이다!!!</strong></span><br />
홀리 지져스 크라이스트</p>

<p>이제 그동안 올린 이미지 파일도 전체 용량 줄이기에 들어가자.<br />
쌓이면 답도 없으니 이미지가 하나라도 적은 지금 작업해야한다…</p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>더 발전 시킬 수 있을거란 마음이 계속 생긴다.<br />
하지만 이런건 적당히 끊어줘야한다.<br />
잘 돌아가고 목적을 달성했으면 됐지.<br />
여기서 칼같이 끊어야겠다.<br />
이것 말고도 할게 많단 말이야.</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/Python/2025-06-04-WebP%20Converter.py">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="one-pan/Python/" /><summary type="html"><![CDATA[개요 jpg는 화질을 제법 깎아먹어서 용량이 가벼운 편이다. 하지만 지난 포스트를 작성하며 이미지를 더 가볍게 유지할 필요성을 느꼈고 webp로 변환하는게 좋겠다는 결론에 도달했다. 그러면 WebP 변환기를 만들어야겠지!!! 변환하며 화질을 살짝 열화시키면 더 효과가 좋을 것이다. 뭐 영화 보는 것도 아니고 고화질 유지할 필요는 없으니 파이썬을 선택한 이유는 간단하다. 딸깍 한 번 하면 필요한 라이브러리가 설치되니까. 자바로 하면 TwelveMonkeys 같은 외부 라이브러리 끌어와야하고 C++하면 libwebp 빌드부터가 귀찮다. 편하게 쓰려고 내가 파이썬을 배웠지 설계 webp로 변환할 타겟 폴더를 선택하는게 좋나, 타겟 이미지가 있는 폴더에 소스코드를 넣어두고 실행시키는게 좋나? 고민 끝에 더 생각없이 쓰려면 후자가 쉽고 빠를 것 같아 후자로 한다. 현재 폴더의 모든 이미지를 타겟 폴더에 webp로 뱉어내도록 한다. 하는 김에 용량 얼마나 줄였는지 디스플레이도 해주면 좋겠다. 구현 포인트 Pillow 라이브러리를 사용한다. 1. 기초 코드 from PIL import Image import os # 실행 경로 folder = os.getcwd() # 폴더 내 파일들을 대상으로 변환 for filename in os.listdir(folder): img_path = os.path.join(folder, filename) webp_path = os.path.splitext(img_path)[0] + ".webp" Image.open(img_path).save(webp_path, "WEBP", quality=80) # 80% 품질 print("변환 완료") 2. 세부 설정 예외처리를 위해 이미지 확장자를 제한한다. jpg와 png, gif 3종류면 되겠지 뭐. 그리고 변환 전후로 용량을 확인해 print 시 표시해준다. gif 파일은 그냥 변환하면 애니메이션이 사라지므로 따로 분기를 태워준다. # jpg, png, gif if filename.lower().endswith((".jpg", ".jpeg", ".png", ".gif")): img_path = os.path.join(folder, filename) webp_path = os.path.join(target_folder, os.path.splitext(filename)[0] + ".webp") with Image.open(img_path) as img: # gif는 애니메이션 때문에 특수 처리 if img.format == "GIF" and getattr(img, "is_animated", False): frames = [] durations = [] # 그냥 변환하면 너무 느려서 duration 직접 추출 for frame in ImageSequence.Iterator(img): frames.append(frame.copy()) durations.append(frame.info.get("duration", 100)) frames[0].save( webp_path, "WEBP", save_all=True, append_images=frames[1:], duration=durations, loop=img.info.get("loop", 0), quality=80, ) # 애니메이션 없으면 그냥 변환 else: img.save(webp_path, "WEBP", quality=80) # 용량 확인 (kb) before_size = os.path.getsize(img_path) / 1024 after_size = os.path.getsize(webp_path) / 1024 print(f"{filename} 변환 완료") if after_size &gt; before_size: print(f"↑↑증가↑↑ {(1 - before_size / after_size) * 100:.1f}% ({before_size:.1f}kb -&gt; {after_size:.1f}kb)") else: print(f"↓↓감소↓↓ {(1 - after_size / before_size) * 100:.1f}% ({before_size:.1f}kb -&gt; {after_size:.1f}kb)") 완성 테스트 이미지 파일 몇개 넣어놓고 돌려보았다. gif는 용량이 오히려 늘어날 수 있다!!! 변환해보고 webp가 오히려 용량이 많은 경우 gif를 그대로 써야겠다. 늘어난 파일 제외하고 테스트 이미지 파일 압축 시 용량변화는 아래와 같다. 18.1mb에서 4.51mb로 줄였으니 75% 가량 줄인 셈이다!!! 홀리 지져스 크라이스트 이제 그동안 올린 이미지 파일도 전체 용량 줄이기에 들어가자. 쌓이면 답도 없으니 이미지가 하나라도 적은 지금 작업해야한다… 반성 더 발전 시킬 수 있을거란 마음이 계속 생긴다. 하지만 이런건 적당히 끊어줘야한다. 잘 돌아가고 목적을 달성했으면 됐지. 여기서 칼같이 끊어야겠다. 이것 말고도 할게 많단 말이야. 코드 확인 Link to GitHub]]></summary></entry><entry><title type="html">마법의 소라고둥</title><link href="https://movingwoo.com/one-pan/shortcuts/2025/06/02/Magic-Conch-Shell.html" rel="alternate" type="text/html" title="마법의 소라고둥" /><published>2025-06-02T08:00:00+00:00</published><updated>2025-06-02T08:00:00+00:00</updated><id>https://movingwoo.com/one-pan/shortcuts/2025/06/02/Magic%20Conch%20Shell</id><content type="html" xml:base="https://movingwoo.com/one-pan/shortcuts/2025/06/02/Magic-Conch-Shell.html"><![CDATA[<blockquote>
  <h4 id="개요">개요</h4>
  <hr />
</blockquote>

<p>심심하면 아이폰 단축어로 이것저것 만드는데 제법 재밌다</p>

<p>오늘은 스폰지밥 에피소드 중 하나인 <span style="color: orange;"><strong>마법의 소라고둥</strong></span>을 따라서<br />
질문에 랜덤으로 소라고둥이 답해주는걸 만들거다.</p>

<p>그런데 소라고동임 소라고둥임?<br />
애니메이션은 소라고동이라고 하고 표준어는 소라고둥이다.<br />
고민 끝에 표준어로 간다.</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-사진-준비">1. 사진 준비</h5>

<p>뭐 외부 API 쓸 거 아니면 단축어 만드는 법은 상당히 단순한 편이다.<br />
조건문 블럭에만 잘 집어넣으면 돌아간다.</p>

<p>랜덤으로 사진 4장 중 하나를 보여줘야하니 소라고둥 사진 4장을 만든다.<br />
사진에 글자는 마크업 기능으로 그냥 쓰면 편하다.</p>

<p><img src="/assets/images/posts/one-pan/Shortcuts/2025-06-02-Magic Conch Shell/img01.webp" alt="img01" width="300" style="height: auto;" />
<img src="/assets/images/posts/one-pan/Shortcuts/2025-06-02-Magic Conch Shell/img02.webp" alt="img02" width="300" style="height: auto;" /><br />
<img src="/assets/images/posts/one-pan/Shortcuts/2025-06-02-Magic Conch Shell/img03.webp" alt="img03" width="300" style="height: auto;" />
<img src="/assets/images/posts/one-pan/Shortcuts/2025-06-02-Magic Conch Shell/img04.webp" alt="img04" width="300" style="height: auto;" /></p>

<h5 id="2-사용자-입력-받기">2. 사용자 입력 받기</h5>

<p>마법의 소라고둥님께 할 질문을 입력받는다.<br />
오오 고둥님…</p>

<p>물론 로직 상 질문은 그저 형식에 불과하다.</p>

<p><img src="/assets/images/posts/one-pan/Shortcuts/2025-06-02-Magic Conch Shell/img05.webp" alt="img05" width="300" style="height: auto;" /></p>

<h5 id="3-무작위-처리">3. 무작위 처리</h5>

<p>랜덤으로 사진 중 하나를 뽑아 보여준다.<br />
사진 이름을 magic_conch_1 부터 4까지 이름을 지어둬서<br />
무작위 숫자를 뽑아서 문자열 뒤에 붙여주고<br />
해당 이름을 가진 사진을 찾아서 보여준다.</p>

<p><img src="/assets/images/posts/one-pan/Shortcuts/2025-06-02-Magic Conch Shell/img06.webp" alt="img06" width="300" style="height: auto;" /><br />
<img src="/assets/images/posts/one-pan/Shortcuts/2025-06-02-Magic Conch Shell/img07.webp" alt="img07" width="300" style="height: auto;" /></p>

<blockquote>
  <h4 id="완성">완성</h4>
  <hr />
</blockquote>

<p>고민이 될 때는 소라고둥님을 부르자.<br />
<span style="color: red;"><strong>마법의 소라고둥님! 이번 주는 진짜 로또가 될 수 있을까요?</strong></span></p>

<p><img src="/assets/images/posts/one-pan/Shortcuts/2025-06-02-Magic Conch Shell/img08.webp" alt="img08" width="300" style="height: auto;" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>단축어는 마크다운 파일 내 코드로 쓰기 마땅치 않다.<br />
json 형식으로 작성한다해도 알아보기가 힘들고<br />
결국 이미지 덕지덕지 붙이는 방법 외에 떠올리지 못했다.</p>

<p>실현 가능한지 몰라 테스트케이스로 이번 포스트를 작성해봤는데<br />
요 코딱지만한 단축어에 사진이 8개가 나왔다.</p>

<p>이미지 사용을 피할 수 없다면 이미지 사이즈를 줄이고 열화시켜 용량이라도 줄여봐야하나?</p>

<p>코드로 깃에 올려 공유하기 어려운 대신 단축어는 아이클라우드 공유가 가능한데<br />
소라고둥 단축어는 이미지를 따로 만들어서 공유해도 사용할 수 없다.</p>

<p>가능하면 쓸만한 놈 만든 경우엔 코드 공유 대신 단축어 자체를 공유하도록 해야겠다.</p>

<p>업로드 전 단축어 포스트 단점 하나 더 찾음<br />
소스코드가 없어서 포스트 내 글자수가 확 줄어들었다!</p>]]></content><author><name>movingwoo</name></author><category term="one-pan/Shortcuts/" /><summary type="html"><![CDATA[개요 심심하면 아이폰 단축어로 이것저것 만드는데 제법 재밌다 오늘은 스폰지밥 에피소드 중 하나인 마법의 소라고둥을 따라서 질문에 랜덤으로 소라고둥이 답해주는걸 만들거다. 그런데 소라고동임 소라고둥임? 애니메이션은 소라고동이라고 하고 표준어는 소라고둥이다. 고민 끝에 표준어로 간다. 구현 1. 사진 준비 뭐 외부 API 쓸 거 아니면 단축어 만드는 법은 상당히 단순한 편이다. 조건문 블럭에만 잘 집어넣으면 돌아간다. 랜덤으로 사진 4장 중 하나를 보여줘야하니 소라고둥 사진 4장을 만든다. 사진에 글자는 마크업 기능으로 그냥 쓰면 편하다. 2. 사용자 입력 받기 마법의 소라고둥님께 할 질문을 입력받는다. 오오 고둥님… 물론 로직 상 질문은 그저 형식에 불과하다. 3. 무작위 처리 랜덤으로 사진 중 하나를 뽑아 보여준다. 사진 이름을 magic_conch_1 부터 4까지 이름을 지어둬서 무작위 숫자를 뽑아서 문자열 뒤에 붙여주고 해당 이름을 가진 사진을 찾아서 보여준다. 완성 고민이 될 때는 소라고둥님을 부르자. 마법의 소라고둥님! 이번 주는 진짜 로또가 될 수 있을까요? 반성 단축어는 마크다운 파일 내 코드로 쓰기 마땅치 않다. json 형식으로 작성한다해도 알아보기가 힘들고 결국 이미지 덕지덕지 붙이는 방법 외에 떠올리지 못했다. 실현 가능한지 몰라 테스트케이스로 이번 포스트를 작성해봤는데 요 코딱지만한 단축어에 사진이 8개가 나왔다. 이미지 사용을 피할 수 없다면 이미지 사이즈를 줄이고 열화시켜 용량이라도 줄여봐야하나? 코드로 깃에 올려 공유하기 어려운 대신 단축어는 아이클라우드 공유가 가능한데 소라고둥 단축어는 이미지를 따로 만들어서 공유해도 사용할 수 없다. 가능하면 쓸만한 놈 만든 경우엔 코드 공유 대신 단축어 자체를 공유하도록 해야겠다. 업로드 전 단축어 포스트 단점 하나 더 찾음 소스코드가 없어서 포스트 내 글자수가 확 줄어들었다!]]></summary></entry><entry><title type="html">1148번 단어 만들기</title><link href="https://movingwoo.com/random-solve/java/2025/06/02/1148.html" rel="alternate" type="text/html" title="1148번 단어 만들기" /><published>2025-06-02T05:00:00+00:00</published><updated>2025-06-02T05:00:00+00:00</updated><id>https://movingwoo.com/random-solve/java/2025/06/02/1148</id><content type="html" xml:base="https://movingwoo.com/random-solve/java/2025/06/02/1148.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Java/2025-06-02-1148/img01.webp" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/1148">1148번 단어 만들기 - 백준</a></p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p><span style="color: orange;"><strong>20만개</strong></span>의 사전 단어…<br />
이해가 안가는 점이 단어가 20만개인데 문제 분류가 구현/문자열이다?<br />
이게 되남??</p>

<p>믿을 수 없어서 20만개 순회하는 로직으로 제출해보니 메모리 초과가 났다.<br />
아니 또 시간이 문제가 아니라 메모리가 문제였네!<br />
맵과 리스트와 셋을 마구 쑤셔박으니 메모리가 터질 수 밖에</p>

<p><span style="color: orange;"><strong>비트마스크 ㄱㄱ</strong></span></p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-단어와-사전">1. 단어와 사전</h5>

<p>단어 클래스를 구현해 사전에 넣는다.<br />
단어는 비트마스크와 문자 수를 가진다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    	
	<span class="k">try</span><span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
		<span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">))){</span>
		
		<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Word</span><span class="o">&gt;</span> <span class="n">dictionary</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
		
		<span class="c1">// 사전 채우기</span>
		<span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
			<span class="nc">String</span> <span class="n">word</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'-'</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>

			<span class="n">dictionary</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Word</span><span class="o">(</span><span class="n">word</span><span class="o">));</span>
		<span class="o">}</span>
		
	<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="c1">// Word class</span>
<span class="kd">static</span> <span class="kd">class</span> <span class="nc">Word</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">mask</span><span class="o">;</span>
	<span class="kt">int</span><span class="o">[]</span> <span class="n">count</span><span class="o">;</span>

	<span class="nc">Word</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
	<span class="o">}</span>

	<span class="nc">Word</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">();</span>
		
		<span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">word</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
			<span class="c1">// 무조건 대문자로 들어옴</span>
			<span class="n">count</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'A'</span><span class="o">]++;</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'A'</span><span class="o">));</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h5 id="2-메인-루프">2. 메인 루프</h5>

<p>퍼즐판을 입력받으면 단어와 마찬가지로 비트마스크와 단어 수를 계산한다.<br />
분해한 퍼즐판의 각 알파벳을 중앙글자로 삼아서 비교하고 최소, 최대 알파벳을 찾아 정렬 후 출력한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
	<span class="nc">String</span> <span class="n">puzzle</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">puzzle</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'#'</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>

	<span class="c1">// 퍼즐판 비트마스크 변환</span>
	<span class="kt">int</span><span class="o">[]</span> <span class="n">puzzleCount</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
	<span class="kt">int</span> <span class="n">puzzleMask</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	
	<span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">puzzle</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
		<span class="n">puzzleCount</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'A'</span><span class="o">]++;</span>
		<span class="n">puzzleMask</span> <span class="o">|=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'A'</span><span class="o">));</span>
	<span class="o">}</span>

	<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">center</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

	<span class="c1">// 중심글자 하나씩 넣어보기</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">puzzle</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">centerMask</span> <span class="o">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'A'</span><span class="o">));</span>
		<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

		<span class="k">for</span> <span class="o">(</span><span class="nc">Word</span> <span class="n">w</span> <span class="o">:</span> <span class="n">dictionary</span><span class="o">)</span> <span class="o">{</span>
			<span class="c1">// 알파벳 체크</span>
			<span class="k">if</span> <span class="o">((</span><span class="n">w</span><span class="o">.</span><span class="na">mask</span> <span class="o">&amp;</span> <span class="n">puzzleMask</span><span class="o">)</span> <span class="o">!=</span> <span class="n">w</span><span class="o">.</span><span class="na">mask</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
			<span class="c1">// 중심글자 체크</span>
			<span class="k">if</span> <span class="o">((</span><span class="n">w</span><span class="o">.</span><span class="na">mask</span> <span class="o">&amp;</span> <span class="n">centerMask</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>

			<span class="kt">boolean</span> <span class="n">valid</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
			<span class="c1">// 개수 체크</span>
			<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">w</span><span class="o">.</span><span class="na">count</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">puzzleCount</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
					<span class="n">valid</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
					<span class="k">break</span><span class="o">;</span>
				<span class="o">}</span>
			<span class="o">}</span>

			<span class="k">if</span> <span class="o">(</span><span class="n">valid</span><span class="o">)</span> <span class="n">count</span><span class="o">++;</span>
		<span class="o">}</span>

		<span class="n">center</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">count</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="c1">// 최소값 최대값 찾기</span>
	<span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">center</span><span class="o">.</span><span class="na">values</span><span class="o">());</span>
	<span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">center</span><span class="o">.</span><span class="na">values</span><span class="o">());</span>

	<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">minLetters</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
	<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">maxLetters</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

	<span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">:</span> <span class="n">center</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">==</span> <span class="n">min</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">minLetters</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getKey</span><span class="o">()))</span> <span class="o">{</span>
			<span class="n">minLetters</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getKey</span><span class="o">());</span>
		<span class="o">}</span>

		<span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">==</span> <span class="n">max</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">maxLetters</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getKey</span><span class="o">()))</span> <span class="o">{</span>
			<span class="n">maxLetters</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getKey</span><span class="o">());</span>
		<span class="o">}</span>
	<span class="o">}</span>

	<span class="c1">// 알파벳 순 정렬</span>
	<span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">minLetters</span><span class="o">);</span>
	<span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">maxLetters</span><span class="o">);</span>

	<span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">ch</span> <span class="o">:</span> <span class="n">minLetters</span><span class="o">)</span> <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>
	<span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">" "</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="n">min</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">ch</span> <span class="o">:</span> <span class="n">maxLetters</span><span class="o">)</span> <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>
	<span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">" "</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="n">max</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">"\n"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Java/2025-06-02-1148/img02.webp" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>처음에 단순하게 20만개 사전 만든 후 순회하는 코드를 짰다가<br />
전체적인 틀을 유지하며 비트마스크로 바꿨더니 효율적으로 보이진 않는다.<br />
어쨌든 20만개를 저장해서 순회하는 식이니 말이다.</p>

<p>좀 더 빠르게 찾거나 사전을 압축하거나 할 수 있으면 더 빠를듯?<br />
하지만 어쨌든 풀었으니 그만둬야지</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/random-solve/Java/2025-06-02-1148.java">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="random-solve/Java/" /><summary type="html"><![CDATA[문제 1148번 단어 만들기 - 백준 설계 20만개의 사전 단어… 이해가 안가는 점이 단어가 20만개인데 문제 분류가 구현/문자열이다? 이게 되남?? 믿을 수 없어서 20만개 순회하는 로직으로 제출해보니 메모리 초과가 났다. 아니 또 시간이 문제가 아니라 메모리가 문제였네! 맵과 리스트와 셋을 마구 쑤셔박으니 메모리가 터질 수 밖에 비트마스크 ㄱㄱ 구현 1. 단어와 사전 단어 클래스를 구현해 사전에 넣는다. 단어는 비트마스크와 문자 수를 가진다. public static void main(String[] args) { try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out))){ List&lt;Word&gt; dictionary = new ArrayList&lt;&gt;(); // 사전 채우기 while (true) { String word = br.readLine(); if (word.charAt(0) == '-') break; dictionary.add(new Word(word)); } } catch (IOException e) {} } // Word class static class Word { int mask; int[] count; Word() { this.count = new int[26]; } Word(String word) { this(); for (char c : word.toCharArray()) { // 무조건 대문자로 들어옴 count[c - 'A']++; mask |= (1 &lt;&lt; (c - 'A')); } } } 2. 메인 루프 퍼즐판을 입력받으면 단어와 마찬가지로 비트마스크와 단어 수를 계산한다. 분해한 퍼즐판의 각 알파벳을 중앙글자로 삼아서 비교하고 최소, 최대 알파벳을 찾아 정렬 후 출력한다. while (true) { String puzzle = br.readLine(); if (puzzle.charAt(0) == '#') break; // 퍼즐판 비트마스크 변환 int[] puzzleCount = new int[26]; int puzzleMask = 0; for (char c : puzzle.toCharArray()) { puzzleCount[c - 'A']++; puzzleMask |= (1 &lt;&lt; (c - 'A')); } Map&lt;Character, Integer&gt; center = new HashMap&lt;&gt;(); // 중심글자 하나씩 넣어보기 for (char c : puzzle.toCharArray()) { int centerMask = (1 &lt;&lt; (c - 'A')); int count = 0; for (Word w : dictionary) { // 알파벳 체크 if ((w.mask &amp; puzzleMask) != w.mask) continue; // 중심글자 체크 if ((w.mask &amp; centerMask) == 0) continue; boolean valid = true; // 개수 체크 for (int i = 0; i &lt; 26; i++) { if (w.count[i] &gt; puzzleCount[i]) { valid = false; break; } } if (valid) count++; } center.put(c, count); } // 최소값 최대값 찾기 int min = Collections.min(center.values()); int max = Collections.max(center.values()); List&lt;Character&gt; minLetters = new ArrayList&lt;&gt;(); List&lt;Character&gt; maxLetters = new ArrayList&lt;&gt;(); for (Map.Entry&lt;Character, Integer&gt; e : center.entrySet()) { if (e.getValue() == min &amp;&amp; !minLetters.contains(e.getKey())) { minLetters.add(e.getKey()); } if (e.getValue() == max &amp;&amp; !maxLetters.contains(e.getKey())) { maxLetters.add(e.getKey()); } } // 알파벳 순 정렬 Collections.sort(minLetters); Collections.sort(maxLetters); for (char ch : minLetters) sb.append(ch); sb.append(" ").append(min).append(" "); for (char ch : maxLetters) sb.append(ch); sb.append(" ").append(max).append("\n"); } 채점 반성 처음에 단순하게 20만개 사전 만든 후 순회하는 코드를 짰다가 전체적인 틀을 유지하며 비트마스크로 바꿨더니 효율적으로 보이진 않는다. 어쨌든 20만개를 저장해서 순회하는 식이니 말이다. 좀 더 빠르게 찾거나 사전을 압축하거나 할 수 있으면 더 빠를듯? 하지만 어쨌든 풀었으니 그만둬야지 코드 확인 Link to GitHub]]></summary></entry><entry><title type="html">11761번 Shuffling Along</title><link href="https://movingwoo.com/random-solve/python/2025/06/02/11761.html" rel="alternate" type="text/html" title="11761번 Shuffling Along" /><published>2025-06-02T03:00:00+00:00</published><updated>2025-06-02T03:00:00+00:00</updated><id>https://movingwoo.com/random-solve/python/2025/06/02/11761</id><content type="html" xml:base="https://movingwoo.com/random-solve/python/2025/06/02/11761.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Python/2025-06-02-11761/img01.webp" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/11761">11761번 Shuffling Along - 백준</a></p>

<blockquote>
  <h4 id="번역">번역</h4>
  <hr />
</blockquote>

<p>덱을 절반을 나눠서 교차로 셔플한다.<br />
ABCDEFGH의 카드를 예시로 할때<br />
A가 위로 오면 아웃셔플 (AEBFCGDH)<br />
E가 위로 오면 인셔플 (EAFBGCHD)</p>

<p>셔플을 여러번 하면 원래 덱 상태로 돌아오는데<br />
덱 수와 셔플 방식이 주어지면 몇 회만에 원래 덱으로 돌아오는지 구하시오.<br />
홀수인 경우 아웃셔플은 왼쪽에 1장, 인셔플은 오른쪽에 1장 더 준다.</p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>단순 구현 문제로 보인다.<br />
인셔플과 아웃셔플 함수를 두고 개수세며 섞기만 하면 끝인가?<br />
n이 작아서 충분히 가능할 것 같다.</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<p>홀수일때 아웃셔플은 왼쪽이 한 장 많고 인셔플은 오른쪽이 한 장 많다.<br />
중간점만 잘 체크해주기</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 아웃셔플
</span><span class="k">def</span> <span class="nf">out_shuffle</span><span class="p">(</span><span class="n">deck</span><span class="p">):</span>
    <span class="c1"># 왼쪽이 더 많게
</span>    <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>  
    <span class="n">left</span> <span class="o">=</span> <span class="n">deck</span><span class="p">[:</span><span class="n">mid</span><span class="p">]</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">deck</span><span class="p">[</span><span class="n">mid</span><span class="p">:]</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">left</span><span class="p">[</span><span class="n">i</span> <span class="o">//</span> <span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">right</span><span class="p">[</span><span class="n">i</span> <span class="o">//</span> <span class="mi">2</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="c1"># 인셔플
</span><span class="k">def</span> <span class="nf">in_shuffle</span><span class="p">(</span><span class="n">deck</span><span class="p">):</span>
    <span class="c1"># 오른쪽이 더 많게
</span>    <span class="n">mid</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">deck</span><span class="p">[:</span><span class="n">mid</span><span class="p">]</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">deck</span><span class="p">[</span><span class="n">mid</span><span class="p">:]</span>
    
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">right</span><span class="p">[</span><span class="n">i</span> <span class="o">//</span> <span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">left</span><span class="p">[</span><span class="n">i</span> <span class="o">//</span> <span class="mi">2</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<p>호출하며 카운트를 센다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">str_n</span><span class="p">,</span> <span class="n">o</span> <span class="o">=</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">()</span>
<span class="n">n</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">str_n</span><span class="p">)</span>

<span class="n">deck</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

<span class="n">shuffled_deck</span> <span class="o">=</span> <span class="n">deck</span>
<span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">o</span> <span class="o">==</span> <span class="sh">'</span><span class="s">in</span><span class="sh">'</span><span class="p">:</span>
        <span class="n">shuffled_deck</span> <span class="o">=</span> <span class="nf">in_shuffle</span><span class="p">(</span><span class="n">shuffled_deck</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">o</span> <span class="o">==</span> <span class="sh">'</span><span class="s">out</span><span class="sh">'</span><span class="p">:</span>
        <span class="n">shuffled_deck</span> <span class="o">=</span> <span class="nf">out_shuffle</span><span class="p">(</span><span class="n">shuffled_deck</span><span class="p">)</span>
    
    <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">shuffled_deck</span> <span class="o">==</span> <span class="n">deck</span><span class="p">:</span>
        <span class="k">break</span>

<span class="nf">print</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Python/2025-06-02-11761/img02.webp" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>n이 작아서 단순 시뮬레이션으로 통과 가능했다.<br />
만약 엄청나게 컸다면?<br />
전체 덱의 셔플 주기를 찾아서 순환 길이들의 최소공배수를 찾아야할 것이다.<br />
휴~~~ 간단한 문제라서 다행이야</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/random-solve/Python/2025-06-02-11761.py">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="random-solve/Python/" /><summary type="html"><![CDATA[문제 11761번 Shuffling Along - 백준 번역 덱을 절반을 나눠서 교차로 셔플한다. ABCDEFGH의 카드를 예시로 할때 A가 위로 오면 아웃셔플 (AEBFCGDH) E가 위로 오면 인셔플 (EAFBGCHD) 셔플을 여러번 하면 원래 덱 상태로 돌아오는데 덱 수와 셔플 방식이 주어지면 몇 회만에 원래 덱으로 돌아오는지 구하시오. 홀수인 경우 아웃셔플은 왼쪽에 1장, 인셔플은 오른쪽에 1장 더 준다. 설계 단순 구현 문제로 보인다. 인셔플과 아웃셔플 함수를 두고 개수세며 섞기만 하면 끝인가? n이 작아서 충분히 가능할 것 같다. 구현 홀수일때 아웃셔플은 왼쪽이 한 장 많고 인셔플은 오른쪽이 한 장 많다. 중간점만 잘 체크해주기 # 아웃셔플 def out_shuffle(deck): # 왼쪽이 더 많게 mid = (n + 1) // 2 left = deck[:mid] right = deck[mid:] result = [] for i in range(n): if i % 2 == 0: result.append(left[i // 2]) else: result.append(right[i // 2]) return result # 인셔플 def in_shuffle(deck): # 오른쪽이 더 많게 mid = n // 2 left = deck[:mid] right = deck[mid:] result = [] for i in range(n): if i % 2 == 0: result.append(right[i // 2]) else: result.append(left[i // 2]) return result 호출하며 카운트를 센다. str_n, o = input().split() n = int(str_n) deck = list(range(n)) shuffled_deck = deck cnt = 0 while True: if o == 'in': shuffled_deck = in_shuffle(shuffled_deck) elif o == 'out': shuffled_deck = out_shuffle(shuffled_deck) cnt += 1 if shuffled_deck == deck: break print(cnt) 채점 반성 n이 작아서 단순 시뮬레이션으로 통과 가능했다. 만약 엄청나게 컸다면? 전체 덱의 셔플 주기를 찾아서 순환 길이들의 최소공배수를 찾아야할 것이다. 휴~~~ 간단한 문제라서 다행이야 코드 확인 Link to GitHub]]></summary></entry><entry><title type="html">7663번 Dreadful Deadlines</title><link href="https://movingwoo.com/random-solve/c++/2025/05/30/7663.html" rel="alternate" type="text/html" title="7663번 Dreadful Deadlines" /><published>2025-05-30T06:00:00+00:00</published><updated>2025-05-30T06:00:00+00:00</updated><id>https://movingwoo.com/random-solve/c++/2025/05/30/7663</id><content type="html" xml:base="https://movingwoo.com/random-solve/c++/2025/05/30/7663.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/C++/2025-05-30-7663/img01.webp" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/7663">7663번 Dreadful Deadlines - 백준</a></p>

<blockquote>
  <h4 id="번역">번역</h4>
  <hr />
</blockquote>

<p>데이빗은 과제를 n개 해야한다.<br />
한 번 시작한 과제는 끝까지 달려야하고 한 번에 하나만 처리할 수 있다.<br />
이때 데이빗이 데드라인 안에 과제를 끝낼 수 있는 가장 늦은 시간은 언제인가?</p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>또 다시 난이도를 알 수 없는 문제인데 번역해보니 그렇게 어려울 것 같진 않다?<br />
우리에겐 그리디 알고리즘이 있으니까!<br />
그리디… 그리디만 있다면…</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<p>여러 케이스 들어오니 while문에 집어넣고<br />
x와 t가 따로 들어오는걸 모아서 튜플로 만들어준다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">t</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">assignments</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// 튜플로 만들어 넣기</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">assignments</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>놀다가 제일 늦게 하고싶기 때문에 <span style="color: orange;"><strong>마감시간이 제일 늦은 순서로 정렬 후 탐색</strong></span>한다.<br />
시간이 모자라면 불가능 처리</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 늦게 시작하고 싶으니 마감시간이 제일 늦은 과제부터 거꾸로 확인</span>
<span class="n">sort</span><span class="p">(</span><span class="n">assignments</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">assignments</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">compare</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">time</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span> 

<span class="c1">// 과제 하나씩 체크</span>
<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">assignment</span> <span class="o">:</span> <span class="n">assignments</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">xi</span> <span class="o">=</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">assignment</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">ti</span> <span class="o">=</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">assignment</span><span class="p">);</span>

    <span class="n">time</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">ti</span><span class="p">);</span>
    <span class="n">time</span> <span class="o">-=</span> <span class="n">xi</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 시간이 부족하면 impossible</span>
<span class="k">if</span> <span class="p">(</span><span class="n">time</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"impossible</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="k">else</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">time</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

<span class="c1">// ... 중략 ...</span>

<span class="c1">// 커스텀 정렬 함수</span>
<span class="kt">bool</span> <span class="nf">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> 
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/C++/2025-05-30-7663/img02.webp" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>이번엔 climits 헤더 빼먹어서 컴파일 에러 발생<br />
정신을 못차리니 오늘은 쉬어야지</p>

<p>java문제 풀고 c문제 푸니 느끼는데 진짜 입출력이 사기다.<br />
java였으면 테스트 케이스 사이 공백도 따로 처리해줬을텐데</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/random-solve/C%2B%2B/2025-05-30-7663.cpp">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="random-solve/C++/" /><summary type="html"><![CDATA[문제 7663번 Dreadful Deadlines - 백준 번역 데이빗은 과제를 n개 해야한다. 한 번 시작한 과제는 끝까지 달려야하고 한 번에 하나만 처리할 수 있다. 이때 데이빗이 데드라인 안에 과제를 끝낼 수 있는 가장 늦은 시간은 언제인가? 설계 또 다시 난이도를 알 수 없는 문제인데 번역해보니 그렇게 어려울 것 같진 않다? 우리에겐 그리디 알고리즘이 있으니까! 그리디… 그리디만 있다면… 구현 여러 케이스 들어오니 while문에 집어넣고 x와 t가 따로 들어오는걸 모아서 튜플로 만들어준다. while(true){ int n; cin &gt;&gt; n; if (n == 0) break; vector&lt;int&gt; x(n); vector&lt;int&gt; t(n); vector&lt;tuple&lt;int, int&gt;&gt; assignments; for (int i = 0 ; i &lt; n ; i++) { cin &gt;&gt; x[i]; } for (int i = 0 ; i &lt; n ; i++) { cin &gt;&gt; t[i]; } // 튜플로 만들어 넣기 for (int i = 0; i &lt; n; ++i) { assignments.push_back(make_tuple(x[i], t[i])); } } 놀다가 제일 늦게 하고싶기 때문에 마감시간이 제일 늦은 순서로 정렬 후 탐색한다. 시간이 모자라면 불가능 처리 // 늦게 시작하고 싶으니 마감시간이 제일 늦은 과제부터 거꾸로 확인 sort(assignments.begin(), assignments.end(), compare); int time = INT_MAX; // 과제 하나씩 체크 for (const auto&amp; assignment : assignments) { int xi = get&lt;0&gt;(assignment); int ti = get&lt;1&gt;(assignment); time = min(time, ti); time -= xi; } // 시간이 부족하면 impossible if (time &lt; 0) cout &lt;&lt; "impossible\n"; else cout &lt;&lt; time &lt;&lt; '\n'; // ... 중략 ... // 커스텀 정렬 함수 bool compare(const tuple&lt;int, int&gt;&amp; a, const tuple&lt;int, int&gt;&amp; b) { return get&lt;1&gt;(a) &gt; get&lt;1&gt;(b); } 채점 반성 이번엔 climits 헤더 빼먹어서 컴파일 에러 발생 정신을 못차리니 오늘은 쉬어야지 java문제 풀고 c문제 푸니 느끼는데 진짜 입출력이 사기다. java였으면 테스트 케이스 사이 공백도 따로 처리해줬을텐데 코드 확인 Link to GitHub]]></summary></entry><entry><title type="html">6862번 Tin Can Telephone</title><link href="https://movingwoo.com/random-solve/java/2025/05/30/6862.html" rel="alternate" type="text/html" title="6862번 Tin Can Telephone" /><published>2025-05-30T05:00:00+00:00</published><updated>2025-05-30T05:00:00+00:00</updated><id>https://movingwoo.com/random-solve/java/2025/05/30/6862</id><content type="html" xml:base="https://movingwoo.com/random-solve/java/2025/05/30/6862.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Java/2025-05-30-6862/img01.webp" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/6862">6862번 Tin Can Telephone - 백준</a></p>

<blockquote>
  <h4 id="번역">번역</h4>
  <hr />
</blockquote>

<p>깡통 전화라는 문제인데<br />
한국인에겐 종이컵 전화가 더 익숙할 듯 하다.</p>

<p>깡통이든 종이컵이든 양 수화부를 쭉 펼쳐서 통화를 하려는데<br />
경로에 건물이 있거나 닿으면 안된다.</p>

<p>입력을 받았을때 걸리적 거리는 건물의 수를 출력하시오.<br />
건물 모서리는 최대 32개다.</p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>두 가지를 고려해 구현하면 될 것 같다.</p>
<ul>
  <li><span style="color: orange;"><strong>전화선이 건물의 변과 교차하는 경우</strong></span></li>
  <li><span style="color: orange;"><strong>전화선이 건물의 꼭지점과 접촉하는 경우</strong></span></li>
</ul>

<p>꼭지점과 접촉 판별이 가능하면 꼭지점을 통해 건물을 가로지르는 경우는 생각하지 않아도 될 것 같다.</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-건물-꼭지점-클래스와-입력받기">1. 건물 꼭지점 클래스와 입력받기</h5>

<p>건물이 사각형으로 정해진게 아니라서 꼭지점 클래스, 꼭지점 클래스의 집합인 건물 클래스를 만들고 사용하려했는데<br />
막상 구현해보니 건물 클래스는 의미 없어서 제외하고 꼭지점 클래스만 사용한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

	<span class="k">try</span><span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
		<span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
		
		<span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">(),</span><span class="s">" "</span><span class="o">);</span>
		
		<span class="kt">int</span> <span class="n">xR</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		<span class="kt">int</span> <span class="n">yR</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		<span class="kt">int</span> <span class="n">xJ</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		<span class="kt">int</span> <span class="n">yJ</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		
		<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
		<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
		
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">(),</span><span class="s">" "</span><span class="o">);</span>
			<span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
			<span class="nc">Vertex</span><span class="o">[]</span> <span class="n">vertexes</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Vertex</span><span class="o">[</span><span class="n">length</span><span class="o">];</span>
			<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
			
			<span class="k">while</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">hasMoreTokens</span><span class="o">())</span> <span class="o">{</span>
				<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
				<span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
				
				<span class="n">vertexes</span><span class="o">[</span><span class="n">j</span><span class="o">++]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Vertex</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
			<span class="o">}</span>
			
		<span class="o">}</span>
		
		<span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">count</span><span class="o">));</span>
		<span class="n">bw</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
		
	<span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 건물 꼭지점 클래스</span>
<span class="kd">static</span> <span class="kd">class</span> <span class="nc">Vertex</span><span class="o">{</span>
	<span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
	
	<span class="nc">Vertex</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
		<span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h5 id="2-함수와-메인루프">2. 함수와 메인루프</h5>

<p><span style="color: orange;"><strong>세 점의 방향성을 계산</strong></span>하는 Counter ClockWise 함수와 <span style="color: orange;"><strong>점이 선분위에 있는지 판단</strong></span>하는 onSegment 함수를 작성.<br />
이후 꼭지점 수만큼 계산한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Counter ClockWise</span>
<span class="kd">static</span> <span class="kt">long</span> <span class="nf">counterClockWise</span><span class="o">(</span><span class="kt">int</span> <span class="n">x1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x3</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y3</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">return</span> <span class="o">(</span><span class="kt">long</span><span class="o">)(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="n">y3</span> <span class="o">-</span> <span class="n">y1</span><span class="o">)</span> <span class="o">-</span> <span class="o">(</span><span class="kt">long</span><span class="o">)(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="n">x3</span> <span class="o">-</span> <span class="n">x1</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 점이 선분위에 있는지 여부</span>
<span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">onSegment</span><span class="o">(</span><span class="kt">int</span> <span class="n">x1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x3</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y3</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">x1</span><span class="o">,</span> <span class="n">x2</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="n">x3</span> <span class="o">&amp;&amp;</span> <span class="n">x3</span> <span class="o">&lt;=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">x1</span><span class="o">,</span> <span class="n">x2</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
			<span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">y1</span><span class="o">,</span> <span class="n">y2</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="n">y3</span> <span class="o">&amp;&amp;</span> <span class="n">y3</span> <span class="o">&lt;=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">y1</span><span class="o">,</span> <span class="n">y2</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// ... 중략 ...</span>

<span class="kt">boolean</span> <span class="n">blocked</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    			
<span class="c1">// 메인루프</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
	
	<span class="c1">// 세 점의 방향성을 확인해 선분 교차 확인</span>
	<span class="kt">long</span> <span class="n">ab1</span> <span class="o">=</span> <span class="n">counterClockWise</span><span class="o">(</span><span class="n">xR</span><span class="o">,</span> <span class="n">yR</span><span class="o">,</span> <span class="n">xJ</span><span class="o">,</span> <span class="n">yJ</span><span class="o">,</span> <span class="n">vertexes</span><span class="o">[</span><span class="n">k</span><span class="o">].</span><span class="na">x</span><span class="o">,</span> <span class="n">vertexes</span><span class="o">[</span><span class="n">k</span><span class="o">].</span><span class="na">y</span><span class="o">);</span>
	<span class="kt">long</span> <span class="n">ab2</span> <span class="o">=</span> <span class="n">counterClockWise</span><span class="o">(</span><span class="n">xR</span><span class="o">,</span> <span class="n">yR</span><span class="o">,</span> <span class="n">xJ</span><span class="o">,</span> <span class="n">yJ</span><span class="o">,</span> <span class="n">vertexes</span><span class="o">[(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">length</span><span class="o">].</span><span class="na">x</span><span class="o">,</span> <span class="n">vertexes</span><span class="o">[(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">length</span><span class="o">].</span><span class="na">y</span><span class="o">);</span>
	<span class="kt">long</span> <span class="n">cd1</span> <span class="o">=</span> <span class="n">counterClockWise</span><span class="o">(</span><span class="n">vertexes</span><span class="o">[</span><span class="n">k</span><span class="o">].</span><span class="na">x</span><span class="o">,</span> <span class="n">vertexes</span><span class="o">[</span><span class="n">k</span><span class="o">].</span><span class="na">y</span><span class="o">,</span> <span class="n">vertexes</span><span class="o">[(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">length</span><span class="o">].</span><span class="na">x</span><span class="o">,</span> <span class="n">vertexes</span><span class="o">[(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">length</span><span class="o">].</span><span class="na">y</span><span class="o">,</span> <span class="n">xR</span><span class="o">,</span> <span class="n">yR</span><span class="o">);</span>
	<span class="kt">long</span> <span class="n">cd2</span> <span class="o">=</span> <span class="n">counterClockWise</span><span class="o">(</span><span class="n">vertexes</span><span class="o">[</span><span class="n">k</span><span class="o">].</span><span class="na">x</span><span class="o">,</span> <span class="n">vertexes</span><span class="o">[</span><span class="n">k</span><span class="o">].</span><span class="na">y</span><span class="o">,</span> <span class="n">vertexes</span><span class="o">[(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">length</span><span class="o">].</span><span class="na">x</span><span class="o">,</span> <span class="n">vertexes</span><span class="o">[(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">length</span><span class="o">].</span><span class="na">y</span><span class="o">,</span> <span class="n">xJ</span><span class="o">,</span> <span class="n">yJ</span><span class="o">);</span>
	
	<span class="k">if</span> <span class="o">(</span><span class="n">ab1</span> <span class="o">*</span> <span class="n">ab2</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">cd1</span> <span class="o">*</span> <span class="n">cd2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">blocked</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
		<span class="k">break</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="c1">// 꼭지점 접촉 확인</span>
	<span class="k">if</span> <span class="o">((</span><span class="n">ab1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">onSegment</span><span class="o">(</span><span class="n">xR</span><span class="o">,</span> <span class="n">yR</span><span class="o">,</span> <span class="n">xJ</span><span class="o">,</span> <span class="n">yJ</span><span class="o">,</span> <span class="n">vertexes</span><span class="o">[</span><span class="n">k</span><span class="o">].</span><span class="na">x</span><span class="o">,</span> <span class="n">vertexes</span><span class="o">[</span><span class="n">k</span><span class="o">].</span><span class="na">y</span><span class="o">))</span> <span class="o">||</span>
		<span class="o">(</span><span class="n">ab2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">onSegment</span><span class="o">(</span><span class="n">xR</span><span class="o">,</span> <span class="n">yR</span><span class="o">,</span> <span class="n">xJ</span><span class="o">,</span> <span class="n">yJ</span><span class="o">,</span> <span class="n">vertexes</span><span class="o">[(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">length</span><span class="o">].</span><span class="na">x</span><span class="o">,</span> <span class="n">vertexes</span><span class="o">[(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">length</span><span class="o">].</span><span class="na">y</span><span class="o">))</span> <span class="o">||</span>
		<span class="o">(</span><span class="n">cd1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">onSegment</span><span class="o">(</span><span class="n">vertexes</span><span class="o">[</span><span class="n">k</span><span class="o">].</span><span class="na">x</span><span class="o">,</span> <span class="n">vertexes</span><span class="o">[</span><span class="n">k</span><span class="o">].</span><span class="na">y</span><span class="o">,</span> <span class="n">vertexes</span><span class="o">[(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">length</span><span class="o">].</span><span class="na">x</span><span class="o">,</span> <span class="n">vertexes</span><span class="o">[(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">length</span><span class="o">].</span><span class="na">y</span><span class="o">,</span> <span class="n">xR</span><span class="o">,</span> <span class="n">yR</span><span class="o">))</span> <span class="o">||</span>
		<span class="o">(</span><span class="n">cd2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">onSegment</span><span class="o">(</span><span class="n">vertexes</span><span class="o">[</span><span class="n">k</span><span class="o">].</span><span class="na">x</span><span class="o">,</span> <span class="n">vertexes</span><span class="o">[</span><span class="n">k</span><span class="o">].</span><span class="na">y</span><span class="o">,</span> <span class="n">vertexes</span><span class="o">[(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">length</span><span class="o">].</span><span class="na">x</span><span class="o">,</span> <span class="n">vertexes</span><span class="o">[(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">length</span><span class="o">].</span><span class="na">y</span><span class="o">,</span> <span class="n">xJ</span><span class="o">,</span> <span class="n">yJ</span><span class="o">)))</span> <span class="o">{</span>
		<span class="n">blocked</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
		<span class="k">break</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="k">if</span> <span class="o">(</span><span class="n">blocked</span><span class="o">)</span> <span class="n">count</span><span class="o">++;</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Java/2025-05-30-6862/img02.webp" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>왜 자꾸 java 제출할때 패키지를 안지워서 오류내는거지<br />
정신차려라 나야</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/random-solve/Java/2025-05-30-6862.java">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="random-solve/Java/" /><summary type="html"><![CDATA[문제 6862번 Tin Can Telephone - 백준 번역 깡통 전화라는 문제인데 한국인에겐 종이컵 전화가 더 익숙할 듯 하다. 깡통이든 종이컵이든 양 수화부를 쭉 펼쳐서 통화를 하려는데 경로에 건물이 있거나 닿으면 안된다. 입력을 받았을때 걸리적 거리는 건물의 수를 출력하시오. 건물 모서리는 최대 32개다. 설계 두 가지를 고려해 구현하면 될 것 같다. 전화선이 건물의 변과 교차하는 경우 전화선이 건물의 꼭지점과 접촉하는 경우 꼭지점과 접촉 판별이 가능하면 꼭지점을 통해 건물을 가로지르는 경우는 생각하지 않아도 될 것 같다. 구현 1. 건물 꼭지점 클래스와 입력받기 건물이 사각형으로 정해진게 아니라서 꼭지점 클래스, 꼭지점 클래스의 집합인 건물 클래스를 만들고 사용하려했는데 막상 구현해보니 건물 클래스는 의미 없어서 제외하고 꼭지점 클래스만 사용한다. public static void main(String[] args) { try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out))) { StringTokenizer st = new StringTokenizer(br.readLine()," "); int xR = Integer.parseInt(st.nextToken()); int yR = Integer.parseInt(st.nextToken()); int xJ = Integer.parseInt(st.nextToken()); int yJ = Integer.parseInt(st.nextToken()); int n = Integer.parseInt(br.readLine()); int count = 0; for (int i = 0 ; i &lt; n ; i++) { st = new StringTokenizer(br.readLine()," "); int length = Integer.parseInt(st.nextToken()); Vertex[] vertexes = new Vertex[length]; int j = 0; while(st.hasMoreTokens()) { int x = Integer.parseInt(st.nextToken()); int y = Integer.parseInt(st.nextToken()); vertexes[j++] = new Vertex(x, y); } } bw.write(String.valueOf(count)); bw.flush(); }catch(IOException e) { e.printStackTrace(); } } // 건물 꼭지점 클래스 static class Vertex{ int x; int y; Vertex(int x, int y){ this.x = x; this.y = y; } } 2. 함수와 메인루프 세 점의 방향성을 계산하는 Counter ClockWise 함수와 점이 선분위에 있는지 판단하는 onSegment 함수를 작성. 이후 꼭지점 수만큼 계산한다. // Counter ClockWise static long counterClockWise(int x1, int y1, int x2, int y2, int x3, int y3) { return (long)(x2 - x1) * (y3 - y1) - (long)(y2 - y1) * (x3 - x1); } // 점이 선분위에 있는지 여부 static boolean onSegment(int x1, int y1, int x2, int y2, int x3, int y3) { return Math.min(x1, x2) &lt;= x3 &amp;&amp; x3 &lt;= Math.max(x1, x2) &amp;&amp; Math.min(y1, y2) &lt;= y3 &amp;&amp; y3 &lt;= Math.max(y1, y2); } // ... 중략 ... boolean blocked = false; // 메인루프 for(int k = 0 ; k &lt; length ; k++) { // 세 점의 방향성을 확인해 선분 교차 확인 long ab1 = counterClockWise(xR, yR, xJ, yJ, vertexes[k].x, vertexes[k].y); long ab2 = counterClockWise(xR, yR, xJ, yJ, vertexes[(k + 1) % length].x, vertexes[(k + 1) % length].y); long cd1 = counterClockWise(vertexes[k].x, vertexes[k].y, vertexes[(k + 1) % length].x, vertexes[(k + 1) % length].y, xR, yR); long cd2 = counterClockWise(vertexes[k].x, vertexes[k].y, vertexes[(k + 1) % length].x, vertexes[(k + 1) % length].y, xJ, yJ); if (ab1 * ab2 &lt; 0 &amp;&amp; cd1 * cd2 &lt; 0) { blocked = true; break; } // 꼭지점 접촉 확인 if ((ab1 == 0 &amp;&amp; onSegment(xR, yR, xJ, yJ, vertexes[k].x, vertexes[k].y)) || (ab2 == 0 &amp;&amp; onSegment(xR, yR, xJ, yJ, vertexes[(k + 1) % length].x, vertexes[(k + 1) % length].y)) || (cd1 == 0 &amp;&amp; onSegment(vertexes[k].x, vertexes[k].y, vertexes[(k + 1) % length].x, vertexes[(k + 1) % length].y, xR, yR)) || (cd2 == 0 &amp;&amp; onSegment(vertexes[k].x, vertexes[k].y, vertexes[(k + 1) % length].x, vertexes[(k + 1) % length].y, xJ, yJ))) { blocked = true; break; } } if (blocked) count++; 채점 반성 왜 자꾸 java 제출할때 패키지를 안지워서 오류내는거지 정신차려라 나야 코드 확인 Link to GitHub]]></summary></entry><entry><title type="html">15654번 N과 M (5)</title><link href="https://movingwoo.com/random-solve/python/2025/05/30/15654.html" rel="alternate" type="text/html" title="15654번 N과 M (5)" /><published>2025-05-30T02:00:00+00:00</published><updated>2025-05-30T02:00:00+00:00</updated><id>https://movingwoo.com/random-solve/python/2025/05/30/15654</id><content type="html" xml:base="https://movingwoo.com/random-solve/python/2025/05/30/15654.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Python/2025-05-30-15654/img01.webp" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/15654">15654번 N과 M (5) - 백준</a></p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>뭐야 드디어 번역이 필요없는 문제가…</p>

<p>N개의 자연수에서 M개를 고른 수열을 오름차순으로 출력하는 문제다.<br />
쉬어가는 문제로구나<br />
백트래킹 ㄱㄱ</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<p>설명할게 없음</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">())</span>

<span class="n">numbers</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">()))</span>
<span class="c1"># 오름차순
</span><span class="n">numbers</span><span class="p">.</span><span class="nf">sort</span><span class="p">()</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">M</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">visited</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">back_tracking</span><span class="p">(</span><span class="n">depth</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">depth</span> <span class="o">==</span> <span class="n">M</span><span class="p">:</span>
        <span class="c1"># M개 까지 출력
</span>        <span class="nf">print</span><span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">)</span>
        <span class="k">return</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="c1"># 방문 처리
</span>            <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">result</span><span class="p">[</span><span class="n">depth</span><span class="p">]</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="nf">back_tracking</span><span class="p">(</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

<span class="c1"># 재귀
</span><span class="nf">back_tracking</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Python/2025-05-30-15654/img02.webp" alt="img02" /></p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/random-solve/Python/2025-05-30-15654.py">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="random-solve/Python/" /><summary type="html"><![CDATA[문제 15654번 N과 M (5) - 백준 설계 뭐야 드디어 번역이 필요없는 문제가… N개의 자연수에서 M개를 고른 수열을 오름차순으로 출력하는 문제다. 쉬어가는 문제로구나 백트래킹 ㄱㄱ 구현 설명할게 없음 N, M = map(int, input().split()) numbers = list(map(int, input().split())) # 오름차순 numbers.sort() result = M * [0] visited = N * [False] def back_tracking(depth): if depth == M: # M개 까지 출력 print(*result, sep=' ') return for i in range(N): if not visited[i]: # 방문 처리 visited[i] = True result[depth] = numbers[i] back_tracking(depth + 1) visited[i] = False # 재귀 back_tracking(0) 채점 코드 확인 Link to GitHub]]></summary></entry><entry><title type="html">21308번 Ternary Machine</title><link href="https://movingwoo.com/random-solve/python/2025/05/30/21308.html" rel="alternate" type="text/html" title="21308번 Ternary Machine" /><published>2025-05-30T01:00:00+00:00</published><updated>2025-05-30T01:00:00+00:00</updated><id>https://movingwoo.com/random-solve/python/2025/05/30/21308</id><content type="html" xml:base="https://movingwoo.com/random-solve/python/2025/05/30/21308.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Python/2025-05-30-21308/img01.webp" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/21308">21308번 Ternary Machine - 백준</a></p>

<blockquote>
  <h4 id="번역">번역</h4>
  <hr />
</blockquote>

<p>롱——문제</p>

<p>3진수 프로그램을 해석하고 실행하는 인터프리터를 구현해야한다.</p>

<p>명령어는 고정된 형식이 존재하며 표를 참조한다.<br />
올바르지 않은 입력에 대해서는 런타임에러를 출력하는데, 실행되지 않는 오류는 무시한다.</p>

<p>프로그램은 최대 8192자이며 입력이 필요한 경우 충분한 입력이 반드시 주어진다.</p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>구현문제로 보이는데 생각할 부분이 다소 많아보인다.<br />
명령어 해석을 빠르게 처리해야하고<br />
스택과 힙을 구현해야하겠고<br />
예외처리도 해야하고…</p>

<p>주어진 것부터 묵묵히 하다보면 풀리겠지??</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-입출력과-기본함수">1. 입출력과 기본함수</h5>

<p>입력은 한번에 받아서 버퍼로 저장해둔다.<br />
필요하면 버퍼에 하나씩 꺼내 쓰도록 하고<br />
출력은 모아뒀다가 한번에 한다.</p>

<p><span style="color: orange;"><strong>오류 출력시에는 기존 프로그램이 생성한 출력은 먼저 출력</strong></span>해야하는 것에 주의</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">isError</span> <span class="o">=</span> <span class="bp">False</span>
<span class="c1"># 입력 버퍼 탐색 인덱스
</span><span class="n">buffer_index</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1"># 프로그램 탐색 인덱스
</span><span class="n">program_index</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1"># 명령어 사전
</span><span class="n">opcodes</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1"># 4자리 명령부터 판단
</span>    <span class="c1"># CODE | PARAM | DESCRIPTION
</span>    <span class="p">(</span><span class="sh">"</span><span class="s">1000</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">ADD</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">1001</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">SUB</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">1002</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">MUL</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">1010</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">DIV</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">1011</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">MOD</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">1200</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">PRINT_CHAR</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">1201</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">PRINT_NUM</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">1210</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">READ_CHAR</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">1211</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">READ_NUM</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">000</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">number</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">PUSH_POS</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">001</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">number</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">PUSH_NEG</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">020</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">DUP</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">021</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">SWAP</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">022</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">DROP</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">110</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">STORE</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">111</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">LOAD</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">200</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">label</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">LABEL</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">201</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">label</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">CALL</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">202</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">label</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">JUMP</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">210</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">label</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">JUMP_IF_ZERO</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">211</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">label</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">JUMP_IF_NEG</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">212</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">RETURN</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">(</span><span class="sh">"</span><span class="s">222</span><span class="sh">"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">"</span><span class="s">HALT</span><span class="sh">"</span><span class="p">),</span>
<span class="p">]</span>
<span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">heap</span> <span class="o">=</span> <span class="p">{}</span>
<span class="c1"># 복귀 주소 스택
</span><span class="n">call_stack</span> <span class="o">=</span> <span class="p">[]</span>
<span class="c1"># CALL, JUMP 등을 처리하기 위해 label 위치를 미리 매핑해야함
</span><span class="n">labels</span> <span class="o">=</span> <span class="p">{}</span>
<span class="c1"># 출력은 리스트에 모아두었다가 한 번에 출력
</span><span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">output</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="sh">''</span><span class="p">)</span>

<span class="k">if</span> <span class="n">isError</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">RUN-TIME ERROR</span><span class="sh">"</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="sh">''</span><span class="p">)</span>
</code></pre></div></div>

<p>한자리 숫자, 문자를 읽는 함수, 라벨을 읽는 함수, 프로그램 내 숫자를 읽는 함수가 필요하다.<br />
스택에 넣는 부분이 많아서 그부분도 따로 함수로 뺀다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 버퍼에서 숫자 하나 읽어오는 함수
</span><span class="k">def</span> <span class="nf">read_number</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">buffer_index</span><span class="p">,</span> <span class="n">isError</span>

    <span class="c1"># 입력에 공백이 주어지나??
</span>    <span class="k">while</span> <span class="n">buffer_index</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">)</span> <span class="ow">and</span> <span class="n">input_buffer</span><span class="p">[</span><span class="n">buffer_index</span><span class="p">].</span><span class="nf">isspace</span><span class="p">():</span>
        <span class="n">buffer_index</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">buffer_index</span> <span class="o">&gt;=</span> <span class="nf">len</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">):</span>
        <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="mi">0</span>
    
    <span class="n">start</span> <span class="o">=</span> <span class="n">buffer_index</span>
    <span class="c1"># 입력 값이 음수일 수 있음
</span>    <span class="k">if</span> <span class="n">input_buffer</span><span class="p">[</span><span class="n">buffer_index</span><span class="p">]</span> <span class="o">==</span> <span class="sh">'</span><span class="s">-</span><span class="sh">'</span><span class="p">:</span>
        <span class="n">buffer_index</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="n">buffer_index</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">)</span> <span class="ow">and</span> <span class="n">input_buffer</span><span class="p">[</span><span class="n">buffer_index</span><span class="p">].</span><span class="nf">isdigit</span><span class="p">():</span>
        <span class="n">buffer_index</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">buffer_index</span> <span class="ow">or</span> <span class="p">(</span><span class="n">input_buffer</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">==</span> <span class="sh">'</span><span class="s">-</span><span class="sh">'</span> <span class="ow">and</span> <span class="n">buffer_index</span> <span class="o">==</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="nf">int</span><span class="p">(</span><span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">buffer_index</span><span class="p">]))</span>

<span class="c1"># 버퍼에서 문자 하나 읽어오는 함수
</span><span class="k">def</span> <span class="nf">read_char</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">buffer_index</span><span class="p">,</span> <span class="n">isError</span>

    <span class="k">if</span> <span class="n">buffer_index</span> <span class="o">&gt;=</span> <span class="nf">len</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">):</span>
        <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="mi">0</span>
    
    <span class="n">ch</span> <span class="o">=</span> <span class="n">input_buffer</span><span class="p">[</span><span class="n">buffer_index</span><span class="p">]</span>
    <span class="n">buffer_index</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="nf">ord</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>

<span class="c1"># 프로그램에서 2로 끝나는 레이블을 읽어오는 함수
</span><span class="k">def</span> <span class="nf">read_label</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">program_index</span><span class="p">,</span> <span class="n">isError</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">program_index</span>

    <span class="k">while</span> <span class="n">program_index</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">program</span><span class="p">):</span>
        <span class="n">trit</span> <span class="o">=</span> <span class="n">program</span><span class="p">[</span><span class="n">program_index</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">trit</span> <span class="o">==</span> <span class="sh">'</span><span class="s">2</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">program</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">program_index</span><span class="p">]</span>
            <span class="n">program_index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">label</span>
        
        <span class="k">elif</span> <span class="n">trit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="sh">'</span><span class="s">01</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">return</span> <span class="bp">None</span>
        
        <span class="n">program_index</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">None</span>

<span class="c1"># 프로그램 내의 숫자 파싱하는 함수
</span><span class="k">def</span> <span class="nf">parse_number_program</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">program_index</span><span class="p">,</span> <span class="n">isError</span>
    <span class="n">bits</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">program_index</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">program</span><span class="p">):</span>
        <span class="n">trit</span> <span class="o">=</span> <span class="n">program</span><span class="p">[</span><span class="n">program_index</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">trit</span> <span class="o">==</span> <span class="sh">'</span><span class="s">0</span><span class="sh">'</span> <span class="ow">or</span> <span class="n">trit</span> <span class="o">==</span> <span class="sh">'</span><span class="s">1</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">bits</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">trit</span><span class="p">)</span>
            <span class="n">program_index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">31</span><span class="p">:</span>
                <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">return</span> <span class="mi">0</span>
            
        <span class="k">elif</span> <span class="n">trit</span> <span class="o">==</span> <span class="sh">'</span><span class="s">2</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">program_index</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">bits</span><span class="p">:</span>
                <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">return</span> <span class="mi">0</span>
            
            <span class="k">return</span> <span class="nf">int</span><span class="p">(</span><span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">bits</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">return</span> <span class="mi">0</span>

    <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="c1"># 스택에 넣는 함수
</span><span class="k">def</span> <span class="nf">push_stack</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">stack</span><span class="p">,</span> <span class="n">isError</span>

    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1024</span><span class="p">:</span>
        <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span>
    <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<span class="c1"># 콜스택에 넣는 함수
</span><span class="k">def</span> <span class="nf">push_call_stack</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">call_stack</span><span class="p">,</span> <span class="n">isError</span>

    <span class="c1"># 서브루틴도 1024 체크 필요
</span>    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">call_stack</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1024</span><span class="p">:</span>
        <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span>
    <span class="n">call_stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</code></pre></div></div>

<h5 id="2-레이블-스캔-함수">2. 레이블 스캔 함수</h5>

<p>CALL이나 JUMP 명령 시 어디로 가야하는가?<br />
그것을 미리 알기위해 <span style="color: orange;"><strong>레이블 스캔을 미리 진행</strong></span>한다.<br />
실행 시 찾으려면 비효율적일 것 같아서리</p>

<p>섣불리 에러처리 해버리면 에러 전까지의 프로그램 아웃풋이 없으므로 주의해야한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># label 스캔하는 함수
</span><span class="k">def</span> <span class="nf">scan_labels</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">labels</span><span class="p">,</span> <span class="n">isError</span>
    <span class="n">scan_index</span> <span class="o">=</span> <span class="mi">0</span>


    <span class="k">while</span> <span class="n">scan_index</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">program</span><span class="p">):</span>

        <span class="c1"># 트릿이 아니면 스캔 종료
</span>        <span class="k">if</span> <span class="n">program</span><span class="p">[</span><span class="n">scan_index</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="sh">'</span><span class="s">012</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">break</span>
            
        <span class="n">matched</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">for</span> <span class="n">code</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">description</span> <span class="ow">in</span> <span class="n">opcodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">program</span><span class="p">.</span><span class="nf">startswith</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">scan_index</span><span class="p">):</span>
                <span class="n">scan_index</span> <span class="o">+=</span> <span class="nf">len</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
                <span class="n">matched</span> <span class="o">=</span> <span class="bp">True</span>

                <span class="c1"># HALT 이후까지 스캔하면 불필요한 오류 발생 가능
</span>                <span class="k">if</span> <span class="n">description</span> <span class="o">==</span> <span class="sh">"</span><span class="s">HALT</span><span class="sh">"</span><span class="p">:</span>
                    <span class="c1"># return 해버리니 뒤쪽 레이블이 등록안됨...
</span>                    <span class="k">break</span>
                
                <span class="k">elif</span> <span class="n">description</span> <span class="o">==</span> <span class="sh">"</span><span class="s">LABEL</span><span class="sh">"</span><span class="p">:</span>
                    <span class="c1"># label 읽기
</span>                    <span class="n">start</span> <span class="o">=</span> <span class="n">scan_index</span>

                    <span class="k">while</span> <span class="n">scan_index</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">program</span><span class="p">):</span>
                        <span class="n">trit</span> <span class="o">=</span> <span class="n">program</span><span class="p">[</span><span class="n">scan_index</span><span class="p">]</span>

                        <span class="k">if</span> <span class="n">trit</span> <span class="o">==</span> <span class="sh">'</span><span class="s">2</span><span class="sh">'</span><span class="p">:</span>
                            <span class="n">label</span> <span class="o">=</span> <span class="n">program</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">scan_index</span><span class="p">]</span>
                            <span class="n">scan_index</span> <span class="o">+=</span> <span class="mi">1</span>

                            <span class="k">if</span> <span class="ow">not</span> <span class="n">label</span> <span class="ow">or</span> <span class="nf">any</span><span class="p">(</span><span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="sh">'</span><span class="s">01</span><span class="sh">'</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">label</span><span class="p">):</span>
                                <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
                                <span class="k">return</span>
                            
                            <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                                <span class="c1"># 같은 위치에 중복된 레이블이면 허용
</span>                                <span class="k">if</span> <span class="n">labels</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">!=</span> <span class="n">scan_index</span><span class="p">:</span>
                                    <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
                                    <span class="k">return</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># label 다음 위치
</span>                                <span class="n">labels</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">scan_index</span>
                            <span class="k">break</span>

                        <span class="k">elif</span> <span class="n">trit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="sh">'</span><span class="s">01</span><span class="sh">'</span><span class="p">:</span>
                            <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
                            <span class="k">return</span>
                        <span class="n">scan_index</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># 끝까지 2를 못 만남
</span>                        <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="k">return</span>

                <span class="c1"># 숫자 건너뛰기
</span>                <span class="k">elif</span> <span class="n">param</span> <span class="o">==</span> <span class="sh">"</span><span class="s">number</span><span class="sh">"</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="k">while</span> <span class="n">scan_index</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">program</span><span class="p">):</span>
                        <span class="n">trit</span> <span class="o">=</span> <span class="n">program</span><span class="p">[</span><span class="n">scan_index</span><span class="p">]</span>
                        <span class="n">scan_index</span> <span class="o">+=</span> <span class="mi">1</span>

                        <span class="k">if</span> <span class="n">trit</span> <span class="o">==</span> <span class="sh">'</span><span class="s">2</span><span class="sh">'</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="k">elif</span> <span class="n">trit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="sh">'</span><span class="s">01</span><span class="sh">'</span><span class="p">:</span>
                            <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
                            <span class="k">return</span>
                        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

                        <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">31</span><span class="p">:</span>
                            <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
                            <span class="k">return</span>

                <span class="c1"># 레이블 건너뛰기
</span>                <span class="k">elif</span> <span class="n">param</span> <span class="o">==</span> <span class="sh">"</span><span class="s">label</span><span class="sh">"</span><span class="p">:</span>
                    
                    <span class="k">while</span> <span class="n">scan_index</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">program</span><span class="p">):</span>
                        <span class="n">trit</span> <span class="o">=</span> <span class="n">program</span><span class="p">[</span><span class="n">scan_index</span><span class="p">]</span>
                        <span class="n">scan_index</span> <span class="o">+=</span> <span class="mi">1</span>

                        <span class="k">if</span> <span class="n">trit</span> <span class="o">==</span> <span class="sh">'</span><span class="s">2</span><span class="sh">'</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="k">elif</span> <span class="n">trit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="sh">'</span><span class="s">01</span><span class="sh">'</span><span class="p">:</span>
                            <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
                            <span class="k">return</span>

                <span class="c1"># param 없는 경우
</span>                <span class="k">break</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">matched</span><span class="p">:</span>
            <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">break</span>

    <span class="k">return</span>
</code></pre></div></div>

<h5 id="3-메인-루프">3. 메인 루프</h5>

<p>명령어 조건에 맞춰 메인 루프 작성<br />
가장 단순하고 가장 별거없고 가장 노가다 구간</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 본 로직
</span><span class="k">while</span> <span class="n">program_index</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">program</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">isError</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">halted</span><span class="p">:</span>

    <span class="n">matched</span> <span class="o">=</span> <span class="bp">False</span>
    
    <span class="k">for</span> <span class="n">code</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">description</span> <span class="ow">in</span> <span class="n">opcodes</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">program</span><span class="p">.</span><span class="nf">startswith</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">program_index</span><span class="p">):</span>
            <span class="n">program_index</span> <span class="o">+=</span> <span class="nf">len</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
            <span class="n">matched</span> <span class="o">=</span> <span class="bp">True</span>

            <span class="c1"># 분기 시작
</span>
            <span class="c1"># ... 중략 ...
</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">matched</span><span class="p">:</span>
        <span class="c1"># 남은 코드가 공백이거나 무의미하면 무시하고 종료
</span>        <span class="k">if</span> <span class="n">program_index</span> <span class="o">&gt;=</span> <span class="nf">len</span><span class="p">(</span><span class="n">program</span><span class="p">):</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">isError</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">break</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Python/2025-05-30-21308/img02.webp" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>하필 또 파이썬이라 푸는데 엄청 오래 걸린 문제</p>

<p>구현만 잘하면 문제없을 줄 알았는데 생각보다 오류가 엄청났다.<br />
레이블 스캔하는 부분에서 뜻대로 잘 동작하지 않아서 결과가 자꾸 틀어짐…</p>

<p>PyPy는 JIT 컴파일러가 있어서 더 빠르다고해서 Python3와 PyPy3 두개로 제출했다.<br />
생각보다 시간 차이가 안나는데, 메모리는 당연히 PyPy3가 많이 쓸거고<br />
속도는 연산자체가 그리 많은 문제가 아니라 큰 차이 안나는 것으로 보인다.</p>

<p>제한시간 빡빡한 문제에서 다시 한 번 비교해봐야할 듯</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/random-solve/Python/2025-05-30-21308.py">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="random-solve/Python/" /><summary type="html"><![CDATA[문제 21308번 Ternary Machine - 백준 번역 롱——문제 3진수 프로그램을 해석하고 실행하는 인터프리터를 구현해야한다. 명령어는 고정된 형식이 존재하며 표를 참조한다. 올바르지 않은 입력에 대해서는 런타임에러를 출력하는데, 실행되지 않는 오류는 무시한다. 프로그램은 최대 8192자이며 입력이 필요한 경우 충분한 입력이 반드시 주어진다. 설계 구현문제로 보이는데 생각할 부분이 다소 많아보인다. 명령어 해석을 빠르게 처리해야하고 스택과 힙을 구현해야하겠고 예외처리도 해야하고… 주어진 것부터 묵묵히 하다보면 풀리겠지?? 구현 1. 입출력과 기본함수 입력은 한번에 받아서 버퍼로 저장해둔다. 필요하면 버퍼에 하나씩 꺼내 쓰도록 하고 출력은 모아뒀다가 한번에 한다. 오류 출력시에는 기존 프로그램이 생성한 출력은 먼저 출력해야하는 것에 주의 isError = False # 입력 버퍼 탐색 인덱스 buffer_index = 0 # 프로그램 탐색 인덱스 program_index = 0 # 명령어 사전 opcodes = [ # 4자리 명령부터 판단 # CODE | PARAM | DESCRIPTION ("1000", None, "ADD"), ("1001", None, "SUB"), ("1002", None, "MUL"), ("1010", None, "DIV"), ("1011", None, "MOD"), ("1200", None, "PRINT_CHAR"), ("1201", None, "PRINT_NUM"), ("1210", None, "READ_CHAR"), ("1211", None, "READ_NUM"), ("000", "number", "PUSH_POS"), ("001", "number", "PUSH_NEG"), ("020", None, "DUP"), ("021", None, "SWAP"), ("022", None, "DROP"), ("110", None, "STORE"), ("111", None, "LOAD"), ("200", "label", "LABEL"), ("201", "label", "CALL"), ("202", "label", "JUMP"), ("210", "label", "JUMP_IF_ZERO"), ("211", "label", "JUMP_IF_NEG"), ("212", None, "RETURN"), ("222", None, "HALT"), ] stack = [] heap = {} # 복귀 주소 스택 call_stack = [] # CALL, JUMP 등을 처리하기 위해 label 위치를 미리 매핑해야함 labels = {} # 출력은 리스트에 모아두었다가 한 번에 출력 output = [] print(''.join(output), end='') if isError: print("RUN-TIME ERROR", end='') 한자리 숫자, 문자를 읽는 함수, 라벨을 읽는 함수, 프로그램 내 숫자를 읽는 함수가 필요하다. 스택에 넣는 부분이 많아서 그부분도 따로 함수로 뺀다. # 버퍼에서 숫자 하나 읽어오는 함수 def read_number(): global buffer_index, isError # 입력에 공백이 주어지나?? while buffer_index &lt; len(input_buffer) and input_buffer[buffer_index].isspace(): buffer_index += 1 if buffer_index &gt;= len(input_buffer): isError = True return 0 start = buffer_index # 입력 값이 음수일 수 있음 if input_buffer[buffer_index] == '-': buffer_index += 1 while buffer_index &lt; len(input_buffer) and input_buffer[buffer_index].isdigit(): buffer_index += 1 if start == buffer_index or (input_buffer[start] == '-' and buffer_index == start + 1): isError = True return 0 return int(''.join(input_buffer[start:buffer_index])) # 버퍼에서 문자 하나 읽어오는 함수 def read_char(): global buffer_index, isError if buffer_index &gt;= len(input_buffer): isError = True return 0 ch = input_buffer[buffer_index] buffer_index += 1 return ord(ch) # 프로그램에서 2로 끝나는 레이블을 읽어오는 함수 def read_label(): global program_index, isError start = program_index while program_index &lt; len(program): trit = program[program_index] if trit == '2': label = program[start:program_index] program_index += 1 return label elif trit not in '01': isError = True return None program_index += 1 isError = True return None # 프로그램 내의 숫자 파싱하는 함수 def parse_number_program(): global program_index, isError bits = [] count = 0 while program_index &lt; len(program): trit = program[program_index] if trit == '0' or trit == '1': bits.append(trit) program_index += 1 count += 1 if count &gt; 31: isError = True return 0 elif trit == '2': program_index += 1 if not bits: isError = True return 0 return int(''.join(bits), 2) else: isError = True return 0 isError = True return 0 # 스택에 넣는 함수 def push_stack(value): global stack, isError if len(stack) &gt;= 1024: isError = True return stack.append(value) # 콜스택에 넣는 함수 def push_call_stack(value): global call_stack, isError # 서브루틴도 1024 체크 필요 if len(call_stack) &gt;= 1024: isError = True return call_stack.append(value) 2. 레이블 스캔 함수 CALL이나 JUMP 명령 시 어디로 가야하는가? 그것을 미리 알기위해 레이블 스캔을 미리 진행한다. 실행 시 찾으려면 비효율적일 것 같아서리 섣불리 에러처리 해버리면 에러 전까지의 프로그램 아웃풋이 없으므로 주의해야한다. # label 스캔하는 함수 def scan_labels(): global labels, isError scan_index = 0 while scan_index &lt; len(program): # 트릿이 아니면 스캔 종료 if program[scan_index] not in '012': break matched = False for code, param, description in opcodes: if program.startswith(code, scan_index): scan_index += len(code) matched = True # HALT 이후까지 스캔하면 불필요한 오류 발생 가능 if description == "HALT": # return 해버리니 뒤쪽 레이블이 등록안됨... break elif description == "LABEL": # label 읽기 start = scan_index while scan_index &lt; len(program): trit = program[scan_index] if trit == '2': label = program[start:scan_index] scan_index += 1 if not label or any(c not in '01' for c in label): isError = True return if label in labels: # 같은 위치에 중복된 레이블이면 허용 if labels[label] != scan_index: isError = True return else: # label 다음 위치 labels[label] = scan_index break elif trit not in '01': isError = True return scan_index += 1 else: # 끝까지 2를 못 만남 isError = True return # 숫자 건너뛰기 elif param == "number": count = 0 while scan_index &lt; len(program): trit = program[scan_index] scan_index += 1 if trit == '2': break elif trit not in '01': isError = True return count += 1 if count &gt; 31: isError = True return # 레이블 건너뛰기 elif param == "label": while scan_index &lt; len(program): trit = program[scan_index] scan_index += 1 if trit == '2': break elif trit not in '01': isError = True return # param 없는 경우 break if not matched: isError = True break return 3. 메인 루프 명령어 조건에 맞춰 메인 루프 작성 가장 단순하고 가장 별거없고 가장 노가다 구간 # 본 로직 while program_index &lt; len(program) and not isError and not halted: matched = False for code, param, description in opcodes: if program.startswith(code, program_index): program_index += len(code) matched = True # 분기 시작 # ... 중략 ... if not matched: # 남은 코드가 공백이거나 무의미하면 무시하고 종료 if program_index &gt;= len(program): break else: isError = True break 채점 반성 하필 또 파이썬이라 푸는데 엄청 오래 걸린 문제 구현만 잘하면 문제없을 줄 알았는데 생각보다 오류가 엄청났다. 레이블 스캔하는 부분에서 뜻대로 잘 동작하지 않아서 결과가 자꾸 틀어짐… PyPy는 JIT 컴파일러가 있어서 더 빠르다고해서 Python3와 PyPy3 두개로 제출했다. 생각보다 시간 차이가 안나는데, 메모리는 당연히 PyPy3가 많이 쓸거고 속도는 연산자체가 그리 많은 문제가 아니라 큰 차이 안나는 것으로 보인다. 제한시간 빡빡한 문제에서 다시 한 번 비교해봐야할 듯 코드 확인 Link to GitHub]]></summary></entry></feed>