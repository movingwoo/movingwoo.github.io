<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://movingwoo.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://movingwoo.com/" rel="alternate" type="text/html" hreflang="ko-KR" /><updated>2025-05-27T02:01:42+00:00</updated><id>https://movingwoo.com/feed.xml</id><title type="html">뭐라도 하겠지</title><subtitle>나도 사람인데 뭐라도 하겠지</subtitle><entry><title type="html">던전 생성기 01</title><link href="https://movingwoo.com/one-pan/javascript/2025/05/27/Dungeon-Generator-01.html" rel="alternate" type="text/html" title="던전 생성기 01" /><published>2025-05-27T02:00:00+00:00</published><updated>2025-05-27T02:00:00+00:00</updated><id>https://movingwoo.com/one-pan/javascript/2025/05/27/Dungeon%20Generator%2001</id><content type="html" xml:base="https://movingwoo.com/one-pan/javascript/2025/05/27/Dungeon-Generator-01.html"><![CDATA[<blockquote>
  <h4 id="개요">개요</h4>
  <hr />
</blockquote>

<p>신나는 던전 맵 생성기<br />
5종 알고리즘과 함께</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-설계">1. 설계</h5>

<p>던전 맵 생성 관련 대표 알고리즘에 대해 찾아보았다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">알고리즘</th>
      <th style="text-align: left">스타일</th>
      <th style="text-align: left">특징</th>
      <th style="text-align: left">용도</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">BSP (Binary Space Partitioning)</td>
      <td style="text-align: left">직사각형 방 + 복도</td>
      <td style="text-align: left">공간을 재귀적으로 분할, 각 방을 연결</td>
      <td style="text-align: left">방 중심의 던전, 구조적 배치</td>
    </tr>
    <tr>
      <td style="text-align: left">Random Walk (Drunkard’s Walk)</td>
      <td style="text-align: left">유기적 경로, 비정형</td>
      <td style="text-align: left">무작위 방향 이동, 비선형 구조</td>
      <td style="text-align: left">자연 동굴, 탐험 중심 던전</td>
    </tr>
    <tr>
      <td style="text-align: left">Cellular Automata</td>
      <td style="text-align: left">자연 동굴 형태, 굴곡 많음</td>
      <td style="text-align: left">셀 규칙 반복으로 패턴 정제</td>
      <td style="text-align: left">동굴 스타일 던전, 유기적 형태</td>
    </tr>
    <tr>
      <td style="text-align: left">Delaunay Triangulation + MST</td>
      <td style="text-align: left">방 중심 + 경로 연결</td>
      <td style="text-align: left">무작위 방 &gt; 삼각분할 &gt; 최소 연결</td>
      <td style="text-align: left">모든 방 연결 보장, 전략적 맵</td>
    </tr>
    <tr>
      <td style="text-align: left">Wave Function Collapse (WFC)</td>
      <td style="text-align: left">타일 기반, 정교한 제약</td>
      <td style="text-align: left">타일 제약 기반 패턴 구성</td>
      <td style="text-align: left">정교한 던전, 룰 기반 구조</td>
    </tr>
  </tbody>
</table>

<p>맵을 그릴 캔버스가 있는 html은 이전 미로 생성기의 것을 그대로 가져와서 사용한다.</p>

<h5 id="2-bsp-알고리즘">2. BSP 알고리즘</h5>

<p>BSP 알고리즘을 공간을 재귀적으로 분할한다.<br />
분할 과정이 이진트리 형태로 표현되며 방 설정을 통해 크기와 개수를 쉽게 조절 가능하다.<br />
통로는 각 방의 중심을 직선 또는 L자로 적당히 연결한다.</p>

<p>방이 완전히 랜덤한 위치에 생성되기 때문에 방의 중심을 연결하는 통로의 특성 상<br />
통로가 겹치기도 하고 두껍게 이어지기도 한다.</p>

<p>또 현재 입구 생성을 [0, 0]에서 가장 가까운 셀로 해두었는데<br />
랜덤하게 생성되어 이어지는 구조 특성 상 통로가 가장 가까운 경우 통로에 입구가 생길 수도 있다.<br />
강제로 가까운 셀을 껴서 생성시키기에는 BSP의 취지에 맞지 않은 것 같고<br />
방과 통로를 구분할 수 있게 방 데이터를 가져오려면 공통함수로 쓰기 애매하다.<br />
그냥 복도에 입구가 생기면 운이 나쁜걸로…</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 방 클래스 정의</span>
<span class="kd">class</span> <span class="nc">Room</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">h</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">w</span> <span class="o">=</span> <span class="nx">w</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">h</span> <span class="o">=</span> <span class="nx">h</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 방의 중심 좌표</span>
  <span class="nf">center</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span>
      <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">w</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
      <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">h</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">// 다른 방과 겹치는지 판정</span>
  <span class="nf">intersects</span><span class="p">(</span><span class="nx">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return </span><span class="p">(</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">other</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">other</span><span class="p">.</span><span class="nx">w</span> <span class="o">&amp;&amp;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">w</span> <span class="o">&gt;</span> <span class="nx">other</span><span class="p">.</span><span class="nx">x</span> <span class="o">&amp;&amp;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">other</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">other</span><span class="p">.</span><span class="nx">h</span> <span class="o">&amp;&amp;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">h</span> <span class="o">&gt;</span> <span class="nx">other</span><span class="p">.</span><span class="nx">y</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
  
<span class="k">async</span> <span class="kd">function</span> <span class="nf">startBSP</span><span class="p">()</span> <span class="p">{</span>

  <span class="kd">const</span> <span class="nx">MIN_SIZE</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// 방 최소 크기</span>
  <span class="kd">const</span> <span class="nx">MAX_SIZE</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="c1">// 방 최대 크기</span>
  <span class="kd">const</span> <span class="nx">partitions</span> <span class="o">=</span> <span class="p">[{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">w</span><span class="p">:</span> <span class="nx">cols</span><span class="p">,</span> <span class="na">h</span><span class="p">:</span> <span class="nx">rows</span> <span class="p">}];</span>
  <span class="kd">const</span> <span class="nx">rooms</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// 생성된 방 목록</span>

  <span class="c1">// 공간을 재귀적으로 분할</span>
  <span class="k">async</span> <span class="kd">function</span> <span class="nf">splitSpace</span><span class="p">(</span><span class="nx">space</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">h</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">space</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">horizontal</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">;</span> <span class="c1">// 분할 방향 랜덤(수평/수직)</span>

    <span class="c1">// 더 이상 분할이 불가능할 때(최소 크기 이하)</span>
    <span class="k">if </span><span class="p">((</span><span class="nx">horizontal</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">MIN_SIZE</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="nx">horizontal</span> <span class="o">&amp;&amp;</span> <span class="nx">w</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">MIN_SIZE</span><span class="p">))</span> <span class="p">{</span>
      <span class="c1">// 방 생성 시도 (겹쳐서 실패할 경우 10회까지 재시도)</span>
      <span class="kd">let</span> <span class="nx">tryCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="kd">let</span> <span class="nx">room</span><span class="p">;</span>
      <span class="kd">let</span> <span class="nx">overlapped</span><span class="p">;</span>
      <span class="k">do</span> <span class="p">{</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">w</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">MIN_SIZE</span> <span class="o">||</span> <span class="nx">h</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">MIN_SIZE</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="c1">// 공간이 너무 작으면 중단</span>

        <span class="c1">// 방 크기 랜덤 (MIN_SIZE~MAX_SIZE), 위치도 랜덤(테두리와 1칸 이상 띄움)</span>
        <span class="kd">const</span> <span class="nx">rw</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span>
          <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">w</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="nx">MIN_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="nx">MIN_SIZE</span><span class="p">,</span>
          <span class="nx">MAX_SIZE</span>
        <span class="p">);</span>
        <span class="kd">const</span> <span class="nx">rh</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span>
          <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">h</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="nx">MIN_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="nx">MIN_SIZE</span><span class="p">,</span>
          <span class="nx">MAX_SIZE</span>
        <span class="p">);</span>
        <span class="kd">const</span> <span class="nx">rx</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">w</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="nx">rw</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">ry</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">h</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="nx">rh</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nx">room</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Room</span><span class="p">(</span><span class="nx">rx</span><span class="p">,</span> <span class="nx">ry</span><span class="p">,</span> <span class="nx">rw</span><span class="p">,</span> <span class="nx">rh</span><span class="p">);</span>
        <span class="nx">overlapped</span> <span class="o">=</span> <span class="nx">rooms</span><span class="p">.</span><span class="nf">some</span><span class="p">(</span><span class="nx">r</span> <span class="o">=&gt;</span> <span class="nx">room</span><span class="p">.</span><span class="nf">intersects</span><span class="p">(</span><span class="nx">r</span><span class="p">));</span>
        <span class="nx">tryCount</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">while </span><span class="p">(</span><span class="nx">overlapped</span> <span class="o">&amp;&amp;</span> <span class="nx">tryCount</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">);</span>

      <span class="c1">// 겹치지 않는 방만 생성</span>
      <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">overlapped</span> <span class="o">&amp;&amp;</span> <span class="nx">room</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">rooms</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">room</span><span class="p">);</span>
        <span class="c1">// 방 내부를 흰색칠</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">room</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">room</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">room</span><span class="p">.</span><span class="nx">h</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">room</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">room</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">room</span><span class="p">.</span><span class="nx">w</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">map</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="nf">drawCell</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
            <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 분할: 수평 또는 수직으로 영역을 나눔</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">horizontal</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 수평 분할</span>
      <span class="kd">const</span> <span class="nx">split</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">h</span> <span class="o">-</span> <span class="nx">MIN_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nx">MIN_SIZE</span><span class="p">);</span>
      <span class="kd">const</span> <span class="nx">top</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="na">h</span><span class="p">:</span> <span class="nx">split</span> <span class="p">};</span>
      <span class="kd">const</span> <span class="nx">bottom</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">split</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="na">h</span><span class="p">:</span> <span class="nx">h</span> <span class="o">-</span> <span class="nx">split</span> <span class="p">};</span>
      <span class="k">await</span> <span class="nf">splitSpace</span><span class="p">(</span><span class="nx">top</span><span class="p">);</span>
      <span class="k">await</span> <span class="nf">splitSpace</span><span class="p">(</span><span class="nx">bottom</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// 수직 분할</span>
      <span class="kd">const</span> <span class="nx">split</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">w</span> <span class="o">-</span> <span class="nx">MIN_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nx">MIN_SIZE</span><span class="p">);</span>
      <span class="kd">const</span> <span class="nx">left</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="na">w</span><span class="p">:</span> <span class="nx">split</span><span class="p">,</span> <span class="nx">h</span> <span class="p">};</span>
      <span class="kd">const</span> <span class="nx">right</span> <span class="o">=</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">split</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="na">w</span><span class="p">:</span> <span class="nx">w</span> <span class="o">-</span> <span class="nx">split</span><span class="p">,</span> <span class="nx">h</span> <span class="p">};</span>
      <span class="k">await</span> <span class="nf">splitSpace</span><span class="p">(</span><span class="nx">left</span><span class="p">);</span>
      <span class="k">await</span> <span class="nf">splitSpace</span><span class="p">(</span><span class="nx">right</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 터널 뚫는 함수</span>
  <span class="k">async</span> <span class="kd">function</span> <span class="nf">tunneling</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">dx</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sign</span><span class="p">(</span><span class="nx">x2</span> <span class="o">-</span> <span class="nx">x1</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">dy</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sign</span><span class="p">(</span><span class="nx">y2</span> <span class="o">-</span> <span class="nx">y1</span><span class="p">);</span>
    <span class="c1">// x축 방향으로 먼저 이동</span>
    <span class="k">while </span><span class="p">(</span><span class="nx">x1</span> <span class="o">!==</span> <span class="nx">x2</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">map</span><span class="p">[</span><span class="nx">y1</span><span class="p">][</span><span class="nx">x1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
      <span class="nx">x1</span> <span class="o">+=</span> <span class="nx">dx</span><span class="p">;</span>
      <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// y축 방향으로 이동</span>
    <span class="k">while </span><span class="p">(</span><span class="nx">y1</span> <span class="o">!==</span> <span class="nx">y2</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">map</span><span class="p">[</span><span class="nx">y1</span><span class="p">][</span><span class="nx">x1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
      <span class="nx">y1</span> <span class="o">+=</span> <span class="nx">dy</span><span class="p">;</span>
      <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">await</span> <span class="nf">splitSpace</span><span class="p">(</span><span class="nx">partitions</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

  <span class="c1">// 생성된 방들의 중심을 순서대로 복도로 연결</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">rooms</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">rooms</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="nf">center</span><span class="p">();</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">rooms</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nf">center</span><span class="p">();</span>

    <span class="k">if </span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">await</span> <span class="nf">tunneling</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y1</span><span class="p">);</span>
      <span class="k">await</span> <span class="nf">tunneling</span><span class="p">(</span><span class="nx">x2</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">await</span> <span class="nf">tunneling</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x1</span><span class="p">,</span> <span class="nx">y2</span><span class="p">);</span>
      <span class="k">await</span> <span class="nf">tunneling</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y2</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 입출구 생성</span>
  <span class="nf">generateEntrance</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="3-random-walk-알고리즘">3. Random Walk 알고리즘</h5>

<p>굉장히 간단한 알고리즘이다.<br />
이름에서 볼 수 있듯 방향을 랜덤으로 움직이며 길을 채우고<br />
정해둔 만큼 맵을 채우면 종료한다.</p>

<p>통로나 방이 곡선형으로 잘 생성되는데 랜덤으로 여기저기 쑤시다보니<br />
통로가 너무 좁을 수 있고 전체적인 구조를 제어하기 힙들다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nf">startRandomWalk</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">initMap</span><span class="p">();</span>
  
  <span class="c1">// 시작점 (중앙)</span>
  <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nx">cols</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nx">rows</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
  
  <span class="c1">// 방문한 셀 수를 추적</span>
  <span class="kd">let</span> <span class="nx">visitedCells</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">targetCells</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">((</span><span class="nx">cols</span> <span class="o">*</span> <span class="nx">rows</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.4</span><span class="p">);</span> <span class="c1">// 전체 셀의 40% 채우면 종료</span>
  
  <span class="c1">// 4방향 이동 </span>
  <span class="kd">const</span> <span class="nx">directions</span> <span class="o">=</span> <span class="p">[</span>
      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
      <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
      <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
  <span class="p">];</span>
  
  <span class="c1">// 현재 위치를 통로로 만들고 방문 표시</span>
  <span class="nx">map</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">visitedCells</span><span class="o">++</span><span class="p">;</span>
  
  <span class="k">while </span><span class="p">(</span><span class="nx">visitedCells</span> <span class="o">&lt;</span> <span class="nx">targetCells</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 랜덤한 방향 선택</span>
      <span class="kd">const</span> <span class="p">[</span><span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">]</span> <span class="o">=</span> <span class="nx">directions</span><span class="p">[</span><span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)];</span>
      <span class="kd">const</span> <span class="nx">newX</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">;</span>
      <span class="kd">const</span> <span class="nx">newY</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">;</span>
      
      <span class="c1">// 경계 체크</span>
      <span class="k">if </span><span class="p">(</span><span class="nx">newX</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">newX</span> <span class="o">&lt;</span> <span class="nx">cols</span> <span class="o">&amp;&amp;</span> <span class="nx">newY</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">newY</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// 새로운 위치가 벽이면 통로로 만들기</span>
          <span class="k">if </span><span class="p">(</span><span class="nx">map</span><span class="p">[</span><span class="nx">newY</span><span class="p">][</span><span class="nx">newX</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">map</span><span class="p">[</span><span class="nx">newY</span><span class="p">][</span><span class="nx">newX</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
              <span class="nf">drawCell</span><span class="p">(</span><span class="nx">newX</span><span class="p">,</span> <span class="nx">newY</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
              <span class="nx">visitedCells</span><span class="o">++</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="nx">x</span> <span class="o">=</span> <span class="nx">newX</span><span class="p">;</span>
          <span class="nx">y</span> <span class="o">=</span> <span class="nx">newY</span><span class="p">;</span>
      <span class="p">}</span>
      
      <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="nf">generateEntrance</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="4-cellular-automata-알고리즘">4. Cellular Automata 알고리즘</h5>

<p>셀의 상태를 바탕으로 다음 상태를 결정해 갱신하는 알고리즘이다.</p>

<p>규칙은 어떻게 정하느냐에 따라 다르겠지마는<br />
초기에 랜덤하게 벽을 뚫어두고 4번에 거쳐 다듬어나간다.<br />
규칙은 아래와 같이 정했다.</p>
<ul>
  <li>현재 셀이 벽인데 주변 벽이 4개 이상이면 벽 유지, 그렇지 않으면 통로로 변경</li>
  <li>현재 셀이 통로인데 주변 벽이 5개 이상이변 벽으로 변경, 그렇지 않으면 통로 유지</li>
</ul>

<p>위 과정을 거쳐 자연스러운 동굴 형태의 맵이 완성된다.<br />
엄격한 규칙을 기반으로 다듬어나가기 때문에 뭔가 틀에 박힌 BSP와 자유롭게 칠렐레 팔렐레 뻗은 Random Walk보다 보기 좋다.</p>

<p>이 알고리즘도 고립된 공간이 생길 수 있는데 이는 추가적인 알고리즘을 통해 고립된 방과 통로로 연결하거나 제거하면 된다.<br />
하지만 이번 구현에서 그 부분은 패스.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nf">startCellularAutomata</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">initMap</span><span class="p">();</span>
  
  <span class="c1">// 초기 랜덤 상태 생성 (약 45%의 벽)</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// 테두리는 벽으로 설정</span>
          <span class="k">if </span><span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">x</span> <span class="o">===</span> <span class="nx">cols</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">===</span> <span class="nx">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">map</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
              <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span><span class="p">);</span>
          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
              <span class="nx">map</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.45</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
              <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">map</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
  
  <span class="c1">// Cellular Automata 규칙 적용 (4회 반복)</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">generation</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">generation</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="nx">generation</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">newMap</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">({</span> <span class="na">length</span><span class="p">:</span> <span class="nx">rows</span> <span class="p">},</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nc">Array</span><span class="p">(</span><span class="nx">cols</span><span class="p">).</span><span class="nf">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
      
      <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// 테두리는 벽 유지</span>
              <span class="k">if </span><span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">x</span> <span class="o">===</span> <span class="nx">cols</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">===</span> <span class="nx">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">newMap</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                  <span class="k">continue</span><span class="p">;</span>
              <span class="p">}</span>
              
              <span class="c1">// 주변 8칸의 벽 개수 세기</span>
              <span class="kd">let</span> <span class="nx">wallCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
              <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">dy</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">dy</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">dy</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">dx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">dx</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">dx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">if </span><span class="p">(</span><span class="nx">dx</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">dy</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
                      <span class="k">if </span><span class="p">(</span><span class="nx">map</span><span class="p">[</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">][</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="nx">wallCount</span><span class="o">++</span><span class="p">;</span>
                  <span class="p">}</span>
              <span class="p">}</span>
              
              <span class="c1">//현재 셀이 벽인데 주변 벽이 4개 이상이면 벽 유지, 그렇지 않으면 통로로 변경</span>
              <span class="c1">//현재 셀이 통로인데 주변 벽이 5개 이상이변 벽으로 변경, 그렇지 않으면 통로 유지</span>
              <span class="k">if </span><span class="p">(</span><span class="nx">map</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">newMap</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nx">wallCount</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
              <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                  <span class="nx">newMap</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nx">wallCount</span> <span class="o">&gt;=</span> <span class="mi">5</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
              <span class="p">}</span>
              
              <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">newMap</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
              <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">}</span>
      
      <span class="nx">map</span> <span class="o">=</span> <span class="nx">newMap</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="nf">generateEntrance</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="완성">완성</h4>
  <hr />
</blockquote>

<p>BSP<br />
<img src="/assets/images/posts/one-pan/JavaScript/2025-05-27-Dungeon Generator 01/img01.gif" alt="img01" /></p>

<p>Random Walk<br />
<img src="/assets/images/posts/one-pan/JavaScript/2025-05-27-Dungeon Generator 01/img02.gif" alt="img02" /></p>

<p>Cellular Automata<br />
<img src="/assets/images/posts/one-pan/JavaScript/2025-05-27-Dungeon Generator 01/img03.gif" alt="img03" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>Random Walk 알고리즘과 Cellular Automata 알고리즘을 구현하며 즐거워졌다.<br />
오래된 피쳐폰게임의 작은 미니맵을 보는 기분이다.<br />
아 마음이 충만해진다…</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="/play/Dungeon%20Generator.html" target="_blank" rel="noopener noreferrer">
  직접 해보기
</a></p>

<p>BSP<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-27-BSP.js">Link to GitHub</a></p>

<p>Random Walk<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-27-RandomWalk.js">Link to GitHub</a></p>

<p>Cellular Automata<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-27-CellularAutomata.js">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="one-pan/JavaScript/" /><summary type="html"><![CDATA[개요 신나는 던전 맵 생성기 5종 알고리즘과 함께 구현 1. 설계 던전 맵 생성 관련 대표 알고리즘에 대해 찾아보았다. 알고리즘 스타일 특징 용도 BSP (Binary Space Partitioning) 직사각형 방 + 복도 공간을 재귀적으로 분할, 각 방을 연결 방 중심의 던전, 구조적 배치 Random Walk (Drunkard’s Walk) 유기적 경로, 비정형 무작위 방향 이동, 비선형 구조 자연 동굴, 탐험 중심 던전 Cellular Automata 자연 동굴 형태, 굴곡 많음 셀 규칙 반복으로 패턴 정제 동굴 스타일 던전, 유기적 형태 Delaunay Triangulation + MST 방 중심 + 경로 연결 무작위 방 &gt; 삼각분할 &gt; 최소 연결 모든 방 연결 보장, 전략적 맵 Wave Function Collapse (WFC) 타일 기반, 정교한 제약 타일 제약 기반 패턴 구성 정교한 던전, 룰 기반 구조 맵을 그릴 캔버스가 있는 html은 이전 미로 생성기의 것을 그대로 가져와서 사용한다. 2. BSP 알고리즘 BSP 알고리즘을 공간을 재귀적으로 분할한다. 분할 과정이 이진트리 형태로 표현되며 방 설정을 통해 크기와 개수를 쉽게 조절 가능하다. 통로는 각 방의 중심을 직선 또는 L자로 적당히 연결한다. 방이 완전히 랜덤한 위치에 생성되기 때문에 방의 중심을 연결하는 통로의 특성 상 통로가 겹치기도 하고 두껍게 이어지기도 한다. 또 현재 입구 생성을 [0, 0]에서 가장 가까운 셀로 해두었는데 랜덤하게 생성되어 이어지는 구조 특성 상 통로가 가장 가까운 경우 통로에 입구가 생길 수도 있다. 강제로 가까운 셀을 껴서 생성시키기에는 BSP의 취지에 맞지 않은 것 같고 방과 통로를 구분할 수 있게 방 데이터를 가져오려면 공통함수로 쓰기 애매하다. 그냥 복도에 입구가 생기면 운이 나쁜걸로… // 방 클래스 정의 class Room { constructor(x, y, w, h) { this.x = x; this.y = y; this.w = w; this.h = h; } // 방의 중심 좌표 center() { return [ Math.floor(this.x + this.w / 2), Math.floor(this.y + this.h / 2) ]; } // 다른 방과 겹치는지 판정 intersects(other) { return ( this.x &lt; other.x + other.w &amp;&amp; this.x + this.w &gt; other.x &amp;&amp; this.y &lt; other.y + other.h &amp;&amp; this.y + this.h &gt; other.y ); } } async function startBSP() { const MIN_SIZE = 4; // 방 최소 크기 const MAX_SIZE = 6; // 방 최대 크기 const partitions = [{ x: 0, y: 0, w: cols, h: rows }]; const rooms = []; // 생성된 방 목록 // 공간을 재귀적으로 분할 async function splitSpace(space) { const { x, y, w, h } = space; const horizontal = Math.random() &lt; 0.5; // 분할 방향 랜덤(수평/수직) // 더 이상 분할이 불가능할 때(최소 크기 이하) if ((horizontal &amp;&amp; h &lt;= 2 * MIN_SIZE) || (!horizontal &amp;&amp; w &lt;= 2 * MIN_SIZE)) { // 방 생성 시도 (겹쳐서 실패할 경우 10회까지 재시도) let tryCount = 0; let room; let overlapped; do { if (w - 2 &lt; MIN_SIZE || h - 2 &lt; MIN_SIZE) break; // 공간이 너무 작으면 중단 // 방 크기 랜덤 (MIN_SIZE~MAX_SIZE), 위치도 랜덤(테두리와 1칸 이상 띄움) const rw = Math.min( Math.floor(Math.random() * (w - 2 - MIN_SIZE + 1)) + MIN_SIZE, MAX_SIZE ); const rh = Math.min( Math.floor(Math.random() * (h - 2 - MIN_SIZE + 1)) + MIN_SIZE, MAX_SIZE ); const rx = Math.floor(Math.random() * (w - 2 - rw + 1)) + x + 1; const ry = Math.floor(Math.random() * (h - 2 - rh + 1)) + y + 1; room = new Room(rx, ry, rw, rh); overlapped = rooms.some(r =&gt; room.intersects(r)); tryCount++; } while (overlapped &amp;&amp; tryCount &lt; 10); // 겹치지 않는 방만 생성 if (!overlapped &amp;&amp; room) { rooms.push(room); // 방 내부를 흰색칠 for (let i = room.y; i &lt; room.y + room.h; i++) { for (let j = room.x; j &lt; room.x + room.w; j++) { map[i][j] = 0; drawCell(j, i, 'white'); await sleep(1); } } } return; } // 분할: 수평 또는 수직으로 영역을 나눔 if (horizontal) { // 수평 분할 const split = Math.floor(Math.random() * (h - MIN_SIZE * 2) + MIN_SIZE); const top = { x, y, w, h: split }; const bottom = { x, y: y + split, w, h: h - split }; await splitSpace(top); await splitSpace(bottom); } else { // 수직 분할 const split = Math.floor(Math.random() * (w - MIN_SIZE * 2) + MIN_SIZE); const left = { x, y, w: split, h }; const right = { x: x + split, y, w: w - split, h }; await splitSpace(left); await splitSpace(right); } } // 터널 뚫는 함수 async function tunneling(x1, y1, x2, y2) { const dx = Math.sign(x2 - x1); const dy = Math.sign(y2 - y1); // x축 방향으로 먼저 이동 while (x1 !== x2) { map[y1][x1] = 0; drawCell(x1, y1, 'white'); x1 += dx; await sleep(1); } // y축 방향으로 이동 while (y1 !== y2) { map[y1][x1] = 0; drawCell(x1, y1, 'white'); y1 += dy; await sleep(1); } } await splitSpace(partitions[0]); // 생성된 방들의 중심을 순서대로 복도로 연결 for (let i = 1; i &lt; rooms.length; i++) { const [x1, y1] = rooms[i - 1].center(); const [x2, y2] = rooms[i].center(); if (Math.random() &lt; 0.5) { await tunneling(x1, y1, x2, y1); await tunneling(x2, y1, x2, y2); } else { await tunneling(x1, y1, x1, y2); await tunneling(x1, y2, x2, y2); } } // 입출구 생성 generateEntrance(); } 3. Random Walk 알고리즘 굉장히 간단한 알고리즘이다. 이름에서 볼 수 있듯 방향을 랜덤으로 움직이며 길을 채우고 정해둔 만큼 맵을 채우면 종료한다. 통로나 방이 곡선형으로 잘 생성되는데 랜덤으로 여기저기 쑤시다보니 통로가 너무 좁을 수 있고 전체적인 구조를 제어하기 힙들다. async function startRandomWalk() { initMap(); // 시작점 (중앙) let x = Math.floor(cols / 2); let y = Math.floor(rows / 2); // 방문한 셀 수를 추적 let visitedCells = 0; const targetCells = Math.floor((cols * rows) * 0.4); // 전체 셀의 40% 채우면 종료 // 4방향 이동 const directions = [ [0, -1], [1, 0], [0, 1], [-1, 0] ]; // 현재 위치를 통로로 만들고 방문 표시 map[y][x] = 0; drawCell(x, y, 'white'); visitedCells++; while (visitedCells &lt; targetCells) { // 랜덤한 방향 선택 const [dx, dy] = directions[Math.floor(Math.random() * 4)]; const newX = x + dx; const newY = y + dy; // 경계 체크 if (newX &gt;= 0 &amp;&amp; newX &lt; cols &amp;&amp; newY &gt;= 0 &amp;&amp; newY &lt; rows) { // 새로운 위치가 벽이면 통로로 만들기 if (map[newY][newX] === 1) { map[newY][newX] = 0; drawCell(newX, newY, 'white'); visitedCells++; } x = newX; y = newY; } await sleep(1); } generateEntrance(); } 4. Cellular Automata 알고리즘 셀의 상태를 바탕으로 다음 상태를 결정해 갱신하는 알고리즘이다. 규칙은 어떻게 정하느냐에 따라 다르겠지마는 초기에 랜덤하게 벽을 뚫어두고 4번에 거쳐 다듬어나간다. 규칙은 아래와 같이 정했다. 현재 셀이 벽인데 주변 벽이 4개 이상이면 벽 유지, 그렇지 않으면 통로로 변경 현재 셀이 통로인데 주변 벽이 5개 이상이변 벽으로 변경, 그렇지 않으면 통로 유지 위 과정을 거쳐 자연스러운 동굴 형태의 맵이 완성된다. 엄격한 규칙을 기반으로 다듬어나가기 때문에 뭔가 틀에 박힌 BSP와 자유롭게 칠렐레 팔렐레 뻗은 Random Walk보다 보기 좋다. 이 알고리즘도 고립된 공간이 생길 수 있는데 이는 추가적인 알고리즘을 통해 고립된 방과 통로로 연결하거나 제거하면 된다. 하지만 이번 구현에서 그 부분은 패스. async function startCellularAutomata() { initMap(); // 초기 랜덤 상태 생성 (약 45%의 벽) for (let y = 0; y &lt; rows; y++) { for (let x = 0; x &lt; cols; x++) { // 테두리는 벽으로 설정 if (x === 0 || x === cols - 1 || y === 0 || y === rows - 1) { map[y][x] = 1; drawCell(x, y, 'black'); } else { map[y][x] = Math.random() &lt; 0.45 ? 1 : 0; drawCell(x, y, map[y][x] === 1 ? 'black' : 'white'); } await sleep(1); } } // Cellular Automata 규칙 적용 (4회 반복) for (let generation = 0; generation &lt; 4; generation++) { const newMap = Array.from({ length: rows }, () =&gt; Array(cols).fill(0)); for (let y = 0; y &lt; rows; y++) { for (let x = 0; x &lt; cols; x++) { // 테두리는 벽 유지 if (x === 0 || x === cols - 1 || y === 0 || y === rows - 1) { newMap[y][x] = 1; continue; } // 주변 8칸의 벽 개수 세기 let wallCount = 0; for (let dy = -1; dy &lt;= 1; dy++) { for (let dx = -1; dx &lt;= 1; dx++) { if (dx === 0 &amp;&amp; dy === 0) continue; if (map[y + dy][x + dx] === 1) wallCount++; } } //현재 셀이 벽인데 주변 벽이 4개 이상이면 벽 유지, 그렇지 않으면 통로로 변경 //현재 셀이 통로인데 주변 벽이 5개 이상이변 벽으로 변경, 그렇지 않으면 통로 유지 if (map[y][x] === 1) { newMap[y][x] = wallCount &gt;= 4 ? 1 : 0; } else { newMap[y][x] = wallCount &gt;= 5 ? 1 : 0; } drawCell(x, y, newMap[y][x] === 1 ? 'black' : 'white'); await sleep(1); } } map = newMap; } generateEntrance(); } 완성 BSP Random Walk Cellular Automata 반성 Random Walk 알고리즘과 Cellular Automata 알고리즘을 구현하며 즐거워졌다. 오래된 피쳐폰게임의 작은 미니맵을 보는 기분이다. 아 마음이 충만해진다… 코드 확인 직접 해보기 BSP Link to GitHub Random Walk Link to GitHub Cellular Automata Link to GitHub]]></summary></entry><entry><title type="html">5101번 Sequences</title><link href="https://movingwoo.com/random-solve/python/2025/05/23/5101.html" rel="alternate" type="text/html" title="5101번 Sequences" /><published>2025-05-23T07:00:00+00:00</published><updated>2025-05-23T07:00:00+00:00</updated><id>https://movingwoo.com/random-solve/python/2025/05/23/5101</id><content type="html" xml:base="https://movingwoo.com/random-solve/python/2025/05/23/5101.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Python/2025-05-23-5101/img01.jpg" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/5101">5101번 Sequences - 백준</a></p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>음 쉬운 문제<br />
하루의 마무리로 딱이다.</p>

<p>시작 숫자와 차이가 주어지고 다음 숫자가 수열의 항인지 판단하는 문제이다.</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<p>단순 덧셈 반복해도 문제없지만 조금 더 스마트하게 해봐야지.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">());</span>

    <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">break</span>

    <span class="c1"># b가 0이면 예외처리
</span>    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">c</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">X</span><span class="sh">"</span><span class="p">)</span>
    <span class="c1"># 음수 고려
</span>    <span class="nf">elif </span><span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">%</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">//</span> <span class="n">b</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">((</span><span class="n">c</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">//</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">X</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Python/2025-05-23-5101/img02.jpg" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>아무래도 랜덤 돌려서 브론즈 문제 나오면 좀 거르는게 좋겠다.<br />
이것도 일종의 탄소 과잉배출로 볼 수 있지 않나?</p>

<p>앞으로 랜덤백준디펜스의 브론즈 문제가 걸리면 다 거르는 것으로 해야겠다.<br />
이건 뭐 깃에 코드 올리기도 뭐하고</p>]]></content><author><name>movingwoo</name></author><category term="random-solve/Python/" /><summary type="html"><![CDATA[문제 5101번 Sequences - 백준 설계 음 쉬운 문제 하루의 마무리로 딱이다. 시작 숫자와 차이가 주어지고 다음 숫자가 수열의 항인지 판단하는 문제이다. 구현 단순 덧셈 반복해도 문제없지만 조금 더 스마트하게 해봐야지. while True: a, b, c = map(int, input().split()); if a == 0 and b == 0 and c == 0: break # b가 0이면 예외처리 if b == 0: if a == c: print(1) else: print("X") # 음수 고려 elif (c - a) % b == 0 and (c - a) // b &gt;= 0: print((c - a) // b + 1) else: print("X") 채점 반성 아무래도 랜덤 돌려서 브론즈 문제 나오면 좀 거르는게 좋겠다. 이것도 일종의 탄소 과잉배출로 볼 수 있지 않나? 앞으로 랜덤백준디펜스의 브론즈 문제가 걸리면 다 거르는 것으로 해야겠다. 이건 뭐 깃에 코드 올리기도 뭐하고]]></summary></entry><entry><title type="html">27391번 Platform Placing</title><link href="https://movingwoo.com/random-solve/java/2025/05/23/27391.html" rel="alternate" type="text/html" title="27391번 Platform Placing" /><published>2025-05-23T06:00:00+00:00</published><updated>2025-05-23T06:00:00+00:00</updated><id>https://movingwoo.com/random-solve/java/2025/05/23/27391</id><content type="html" xml:base="https://movingwoo.com/random-solve/java/2025/05/23/27391.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Java/2025-05-23-27391/img01.jpg" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/27391">27391번 Platform Placing - 백준</a></p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>한글 문제 언제 나오나?</p>

<p>플랫폼을 설치하는데 x-l/2, x+l/2 크기를 차지한다.<br />
양쪽으로 펼쳐진다는 뜻.<br />
최소값과 최대값이 정해져 있고 플랫폼 사이의 공간이 있어도 되고 딱 붙어도 되지만 겹치는건 안된다.<br />
모든 고정지점마다 플랫폼 하나 설치가 가능하다.<br />
이때 플랫폼 길이의 총합이 최대가 되도록 하시오.</p>

<p>대충 그리디 알고리즘 ㄱㄱ</p>

<p>당연히 각 위치마다 최대 길이를 설치하는 것이 좋을 것이다.<br />
고정 지점들을 정렬해 순차적으로 길이를 할당하되<br />
이전 플랫폼과 겹치지 않는 한에서 가장 큰 값을 선택해 할당한다.</p>

<p>해결 불가능 시 -1 출력인데 두 지점 간격이 s보다 작을 경우 불가능 처리하면 되겠다.</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-입력-받기">1. 입력 받기</h5>

<p>제한시간은 항상 두려우니 버퍼로 입력받고<br />
플랫폼 배열은 오름차순 정렬, 길이 배열은 최대값으로 채워둔다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    	
    	<span class="k">try</span><span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
	        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
	        
	        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">(),</span> <span class="s">" "</span><span class="o">);</span>
	        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
	        <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
	        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
	        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	        
	        <span class="kt">int</span><span class="o">[]</span> <span class="n">platforms</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
	        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
	        	<span class="n">platforms</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
	        <span class="o">}</span>
	        <span class="c1">// 오름차순</span>
	        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">platforms</span><span class="o">);</span>
	        
	        <span class="kt">int</span><span class="o">[]</span> <span class="n">lengths</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
	        <span class="c1">// 최대길이로 일단 채우고 시작</span>
	        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">lengths</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
	        
	    <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
	        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
	    <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<h5 id="2-플랫폼-배열-탐색">2. 플랫폼 배열 탐색</h5>

<p>플랫폼은 양쪽으로 펼쳐지므로 최대 길이는 2를 곱해서 봐야한다.<br />
배치 불가능하면 -1을 즉시 출력하고<br />
가능하면 현재길이를 우선적으로 조정, 현재길이를 최대로 줄여도 안되면 이전 플랫폼 길이를 줄인다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">platforms</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">platforms</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
    <span class="c1">// 플랫폼이 양쪽으로 펼쳐짐</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dist</span><span class="o">;</span>

    <span class="c1">// 불가능한 경우</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">max</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"-1"</span><span class="o">);</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 이전 길이와 현재 길이의 합이 max를 넘지 않도록 조정</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">lengths</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">lengths</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">lengths</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">lengths</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">max</span> <span class="o">-</span> <span class="n">lengths</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]));</span>

        <span class="c1">// 여전히 안 되면 lengths[i]를 최대한 줄여서 해결 안되면 length[i-1] 조절을 해야함</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">lengths</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">lengths</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">lengths</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">max</span> <span class="o">-</span> <span class="n">lengths</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">length</span> <span class="o">:</span> <span class="n">lengths</span><span class="o">)</span> <span class="n">result</span> <span class="o">+=</span> <span class="n">length</span><span class="o">;</span>
<span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">result</span><span class="o">));</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Java/2025-05-23-27391/img02.jpg" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>기분좋게 잘 해결되었다.<br />
C++ 하다가 Java 하니 잘쳐지는 것도 있고 그리디 알고리즘도 재밌고</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/random-solve/Java/2025-05-23-27391.java">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="random-solve/Java/" /><summary type="html"><![CDATA[문제 27391번 Platform Placing - 백준 설계 한글 문제 언제 나오나? 플랫폼을 설치하는데 x-l/2, x+l/2 크기를 차지한다. 양쪽으로 펼쳐진다는 뜻. 최소값과 최대값이 정해져 있고 플랫폼 사이의 공간이 있어도 되고 딱 붙어도 되지만 겹치는건 안된다. 모든 고정지점마다 플랫폼 하나 설치가 가능하다. 이때 플랫폼 길이의 총합이 최대가 되도록 하시오. 대충 그리디 알고리즘 ㄱㄱ 당연히 각 위치마다 최대 길이를 설치하는 것이 좋을 것이다. 고정 지점들을 정렬해 순차적으로 길이를 할당하되 이전 플랫폼과 겹치지 않는 한에서 가장 큰 값을 선택해 할당한다. 해결 불가능 시 -1 출력인데 두 지점 간격이 s보다 작을 경우 불가능 처리하면 되겠다. 구현 1. 입력 받기 제한시간은 항상 두려우니 버퍼로 입력받고 플랫폼 배열은 오름차순 정렬, 길이 배열은 최대값으로 채워둔다. public static void main(String[] args) { try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out))) { StringTokenizer st = new StringTokenizer(br.readLine(), " "); int n = Integer.parseInt(st.nextToken()); int s = Integer.parseInt(st.nextToken()); int k = Integer.parseInt(st.nextToken()); int result = 0; int[] platforms = new int[n]; for(int i = 0 ; i &lt; n ; i++) { platforms[i] = Integer.parseInt(br.readLine()); } // 오름차순 Arrays.sort(platforms); int[] lengths = new int[n]; // 최대길이로 일단 채우고 시작 Arrays.fill(lengths, k); }catch(IOException e) { e.printStackTrace(); } } 2. 플랫폼 배열 탐색 플랫폼은 양쪽으로 펼쳐지므로 최대 길이는 2를 곱해서 봐야한다. 배치 불가능하면 -1을 즉시 출력하고 가능하면 현재길이를 우선적으로 조정, 현재길이를 최대로 줄여도 안되면 이전 플랫폼 길이를 줄인다. for (int i = 1 ; i &lt; n ; i++) { int dist = platforms[i] - platforms[i - 1]; // 플랫폼이 양쪽으로 펼쳐짐 int max = 2 * dist; // 불가능한 경우 if (max &lt; 2 * s) { bw.write("-1"); return; } // 이전 길이와 현재 길이의 합이 max를 넘지 않도록 조정 if (lengths[i - 1] + lengths[i] &gt; max) { lengths[i] = Math.max(s, Math.min(lengths[i], max - lengths[i - 1])); // 여전히 안 되면 lengths[i]를 최대한 줄여서 해결 안되면 length[i-1] 조절을 해야함 if (lengths[i - 1] + lengths[i] &gt; max) { lengths[i - 1] = Math.max(s, max - lengths[i]); } } } for (int length : lengths) result += length; bw.write(String.valueOf(result)); 채점 반성 기분좋게 잘 해결되었다. C++ 하다가 Java 하니 잘쳐지는 것도 있고 그리디 알고리즘도 재밌고 코드 확인 Link to GitHub]]></summary></entry><entry><title type="html">25245번 Amusement Arcade</title><link href="https://movingwoo.com/random-solve/c++/2025/05/23/25245.html" rel="alternate" type="text/html" title="25245번 Amusement Arcade" /><published>2025-05-23T05:00:00+00:00</published><updated>0225-05-23T05:00:00+00:00</updated><id>https://movingwoo.com/random-solve/c++/2025/05/23/25245</id><content type="html" xml:base="https://movingwoo.com/random-solve/c++/2025/05/23/25245.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/C++/2025-05-23-25245/img01.jpg" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/25245">25245번 Amusement Arcade - 백준</a></p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>n개의 오락기가 있다.(n은 홀수)<br />
사람이 앉아야하는데 반드시 오락기에 한 칸씩 비우고 앉아야한다.<br />
도착하는 사람은 사람이 있는 곳에서 가장 멀리 떨어진 자리를 고르며, 여러개라면 무작위로 선택한다.</p>

<p>이때 줄리아가 가장 먼저 앉을 적절한 위치를 고르시오.</p>

<p>n은 반드시 홀수고 한 칸씩 비우면 최대 인원은 (n + 1) / 2 이다.<br />
줄리아가 대충 n / 2 + 1 위치인 중앙에 앉으면 impossible이 나올 조건은 없어보이는데…<br />
예제에서는 15를 넣을 시 impossible이 나온다.</p>

<p><span style="color: orange;"><strong>사람에서 최대한 멀리 떨어진 곳에 앉으려는 좋지 않은 습성</strong></span> 때문인데…<br />
실제 15를 받아 줄리아를 8번에 앉힐 경우<br />
[1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1]
이 상황에서 정확히 한 칸 조건이 깨져버린다!</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-시뮬레이션">1. 시뮬레이션</h5>

<p>제한시간이 빡빡해서 단순 시뮬레이션은 아닌 것 같다.<br />
일단 대충 코드짜서 순열 규칙 확인 ㄱㄱ</p>

<p>줄리아의 자리는 모든 홀수 자리를 탐색해서 앉혀본다.<br />
단순히 n / 2 + 1 에만 앉을 경우 7을 넣으면 4에 앉아야 하는데 그러면 오답이 나온다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">simulate</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">where</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">;</span> <span class="n">k</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">seats</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
        <span class="c1">// 줄리아가 앉을 자리</span>
        <span class="n">seats</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">people</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">people</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 현재 가능한 자리들 중 가장 큰 최소 거리</span>
            <span class="kt">int</span> <span class="n">max_dist</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">candidates</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">seats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="kt">int</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>

                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">seats</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                        <span class="c1">// 가장 가까운 사람과의 거리</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">abs</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">));</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="c1">// 현재 자리가 이전보다 더 멀리 떨어져 있다면 새로운 후보, 같으면 추가</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&gt;</span> <span class="n">max_dist</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">max_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">;</span>
                    <span class="n">candidates</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
                    <span class="n">candidates</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">==</span> <span class="n">max_dist</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">candidates</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="c1">// 후보자리가 없으면 끝</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">candidates</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">candidates</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// 홀수 자리에 앉지 못하면 의미 없음</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
                    <span class="n">seats</span><span class="p">[</span><span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            
            <span class="n">people</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 최종 상태가 x . x . x ... 패턴인지 확인</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">seats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">seats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">where</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">where</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">31</span> <span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" : "</span> <span class="o">&lt;&lt;</span> <span class="n">simulate</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>시뮬레이션 결과는 아래와 같다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">n</th>
      <th style="text-align: center">줄리아</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">7</td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center">9</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">11</td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center">13</td>
      <td style="text-align: center">5</td>
    </tr>
    <tr>
      <td style="text-align: center">15</td>
      <td style="text-align: center">impossible</td>
    </tr>
    <tr>
      <td style="text-align: center">17</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">19</td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center">21</td>
      <td style="text-align: center">5</td>
    </tr>
    <tr>
      <td style="text-align: center">23</td>
      <td style="text-align: center">impossible</td>
    </tr>
    <tr>
      <td style="text-align: center">25</td>
      <td style="text-align: center">9</td>
    </tr>
    <tr>
      <td style="text-align: center">27</td>
      <td style="text-align: center">impossible</td>
    </tr>
    <tr>
      <td style="text-align: center">29</td>
      <td style="text-align: center">impossible</td>
    </tr>
    <tr>
      <td style="text-align: center">31</td>
      <td style="text-align: center">impossible</td>
    </tr>
  </tbody>
</table>

<p>예제는 다 맞는다.</p>

<h5 id="2-규칙-찾기">2. 규칙 찾기</h5>

<p>가설 1: <span style="color: orange;"><strong>n = 2^k + 1 (k &gt; 0)</strong></span> 인 경우 답은 반드시 1이다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">n</th>
      <th style="text-align: center">줄리아</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">9</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">17</td>
      <td style="text-align: center">1</td>
    </tr>
  </tbody>
</table>

<p>가설 2: <span style="color: orange;"><strong>n != 2^a + 2^b + 1</strong></span> 인 경우 배치가 불가능하다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">n</th>
      <th style="text-align: center">줄리아</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">15</td>
      <td style="text-align: center">impossible</td>
    </tr>
    <tr>
      <td style="text-align: center">23</td>
      <td style="text-align: center">impossible</td>
    </tr>
    <tr>
      <td style="text-align: center">27</td>
      <td style="text-align: center">impossible</td>
    </tr>
    <tr>
      <td style="text-align: center">29</td>
      <td style="text-align: center">impossible</td>
    </tr>
    <tr>
      <td style="text-align: center">31</td>
      <td style="text-align: center">impossible</td>
    </tr>
  </tbody>
</table>

<p>이부분은 <span style="color: orange;"><strong>n + 1의 이진수 1의 개수가 3 이상이면 불가능</strong></span>으로 처리할 수 있다.</p>

<p>가설 3: 그 외의 경우는 시뮬레이션을 하되, 2^k + 1 인 자리만 대상으로 한다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">n</th>
      <th style="text-align: center">줄리아</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">7</td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center">11</td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center">13</td>
      <td style="text-align: center">5</td>
    </tr>
    <tr>
      <td style="text-align: center">19</td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center">21</td>
      <td style="text-align: center">5</td>
    </tr>
    <tr>
      <td style="text-align: center">25</td>
      <td style="text-align: center">9</td>
    </tr>
  </tbody>
</table>

<h5 id="2-구현">2. 구현</h5>

<p>가설 1, 2를 넘었을 경우 시뮬레이션을 해야하는데<br />
n이 10^18까지 있으므로 평범하게 하면 바로 시간초과다.<br />
어차피 꽉 채워 앉으면 완전 이진트리 구조가 되므로 줄리아 배치 기준 양쪽을 반으로 계속 나눌 수 있는지만 확인하면 된다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 가설 1: n == 2^k + 1 이면 반드시 줄리아는 1번 자리에 앉으면 됨</span>
<span class="kt">bool</span> <span class="nf">hypothesis_1</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 가설 2: n == 2^a + 2^b + 1 형태인지 확인</span>
<span class="c1">// n - 1 == 2^a + 2^b 라면 가능성 있음</span>
<span class="kt">bool</span> <span class="nf">hypothesis_2</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int64_t</span> <span class="n">x</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// 균등분할이 가능할지</span>
<span class="kt">bool</span> <span class="nf">can_seat</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">can_seat</span><span class="p">((</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int64_t</span> <span class="nf">solve</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 짝수일 경우 패스</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 가설 1</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hypothesis_1</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 가설 2</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hypothesis_2</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 가설 3</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">64</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="kt">int64_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1LL</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">can_seat</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">can_seat</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/C++/2025-05-23-25245/img02.jpg" alt="img02" /></p>

<p>허허 정답비율 나 혼자 다깎아먹었넹</p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>반복문 조건도 잘 못잡고 균등분할 조건도 잘 못잡고<br />
제대로 했으면 덜 틀렸을걸 실컷 틀렸다.<br />
아주 고봉밥이다 어우 배불러</p>

<p>근데 분명 더 멋진 풀이가 있을거란 말이지<br />
맞힌 사람 보면 코드 길이가 심상치가 않다.</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/random-solve/C%2B%2B/2025-05-23-25245.cpp">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="random-solve/C++/" /><summary type="html"><![CDATA[문제 25245번 Amusement Arcade - 백준 설계 n개의 오락기가 있다.(n은 홀수) 사람이 앉아야하는데 반드시 오락기에 한 칸씩 비우고 앉아야한다. 도착하는 사람은 사람이 있는 곳에서 가장 멀리 떨어진 자리를 고르며, 여러개라면 무작위로 선택한다. 이때 줄리아가 가장 먼저 앉을 적절한 위치를 고르시오. n은 반드시 홀수고 한 칸씩 비우면 최대 인원은 (n + 1) / 2 이다. 줄리아가 대충 n / 2 + 1 위치인 중앙에 앉으면 impossible이 나올 조건은 없어보이는데… 예제에서는 15를 넣을 시 impossible이 나온다. 사람에서 최대한 멀리 떨어진 곳에 앉으려는 좋지 않은 습성 때문인데… 실제 15를 받아 줄리아를 8번에 앉힐 경우 [1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1] 이 상황에서 정확히 한 칸 조건이 깨져버린다! 구현 1. 시뮬레이션 제한시간이 빡빡해서 단순 시뮬레이션은 아닌 것 같다. 일단 대충 코드짜서 순열 규칙 확인 ㄱㄱ 줄리아의 자리는 모든 홀수 자리를 탐색해서 앉혀본다. 단순히 n / 2 + 1 에만 앉을 경우 7을 넣으면 4에 앉아야 하는데 그러면 오답이 나온다. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;limits&gt; using namespace std; int simulate(int n) { int max = (n + 1) / 2; int where = -1; for (int k = 0 ; k &lt; n ; k+=2) { bool result = true; vector&lt;int&gt; seats(n, 0); // 줄리아가 앉을 자리 seats[k] = 1; int people = 1; while (people &lt; max) { // 현재 가능한 자리들 중 가장 큰 최소 거리 int max_dist = -1; vector&lt;int&gt; candidates; for (int i = 0 ; i &lt; n ; i++) { if (seats[i] == 1) { continue; } int dist = numeric_limits&lt;int&gt;::max(); for (int j = 0 ; j &lt; n ; j++) { if (seats[j] == 1) { // 가장 가까운 사람과의 거리 dist = min(dist, abs(i - j)); } } // 현재 자리가 이전보다 더 멀리 떨어져 있다면 새로운 후보, 같으면 추가 if (dist &gt; max_dist) { max_dist = dist; candidates.clear(); candidates.push_back(i); } else if (dist == max_dist) { candidates.push_back(i); } } // 후보자리가 없으면 끝 if (candidates.empty()) { break; } for (int i = 0 ; i &lt; candidates.size() ; i++) { if (candidates[i] % 2 != 0) { // 홀수 자리에 앉지 못하면 의미 없음 continue; }else { seats[candidates[i]] = 1; break; } } people++; } // 최종 상태가 x . x . x ... 패턴인지 확인 for (int i = 0 ; i &lt; n ; i++) { if (i % 2 == 0) { if (seats[i] != 1) { result = false; break; } } else { if (seats[i] != 0) { result = false; break; } } } if (result) { where = k + 1; break; } } return where; } int main() { bool result = false; for (int i = 1 ; i &lt;= 31 ; i+=2) { cout &lt;&lt; i &lt;&lt; " : " &lt;&lt; simulate(i) &lt;&lt; endl; } return 0; } 시뮬레이션 결과는 아래와 같다. n 줄리아 1 1 3 1 5 1 7 3 9 1 11 3 13 5 15 impossible 17 1 19 3 21 5 23 impossible 25 9 27 impossible 29 impossible 31 impossible 예제는 다 맞는다. 2. 규칙 찾기 가설 1: n = 2^k + 1 (k &gt; 0) 인 경우 답은 반드시 1이다. n 줄리아 3 1 5 1 9 1 17 1 가설 2: n != 2^a + 2^b + 1 인 경우 배치가 불가능하다. n 줄리아 15 impossible 23 impossible 27 impossible 29 impossible 31 impossible 이부분은 n + 1의 이진수 1의 개수가 3 이상이면 불가능으로 처리할 수 있다. 가설 3: 그 외의 경우는 시뮬레이션을 하되, 2^k + 1 인 자리만 대상으로 한다. n 줄리아 7 3 11 3 13 5 19 3 21 5 25 9 2. 구현 가설 1, 2를 넘었을 경우 시뮬레이션을 해야하는데 n이 10^18까지 있으므로 평범하게 하면 바로 시간초과다. 어차피 꽉 채워 앉으면 완전 이진트리 구조가 되므로 줄리아 배치 기준 양쪽을 반으로 계속 나눌 수 있는지만 확인하면 된다. // 가설 1: n == 2^k + 1 이면 반드시 줄리아는 1번 자리에 앉으면 됨 bool hypothesis_1(int64_t n) { return (n &gt; 1) &amp;&amp; ((n - 1) &amp; (n - 2)) == 0; } // 가설 2: n == 2^a + 2^b + 1 형태인지 확인 // n - 1 == 2^a + 2^b 라면 가능성 있음 bool hypothesis_2(int64_t n) { int64_t x = n - 1; int count = 0; while (x &gt; 0) { if (x &amp; 1) count++; if (count &gt; 2) return false; x &gt;&gt;= 1; } return count == 2; } // 균등분할이 가능할지 bool can_seat(int64_t len) { if (len &lt; 2) return true; if (len % 2 == 0) return false; return can_seat((len - 1) / 2); } int64_t solve(int64_t n) { // 짝수일 경우 패스 if (n % 2 == 0) { return -1; } // 가설 1 if (hypothesis_1(n)) { return 1; } // 가설 2 if (!hypothesis_2(n)) { return -1; } // 가설 3 for (int i = 0 ; i &lt; 64 ; i++){ int64_t pos = (1LL &lt;&lt; i) + 1; if (pos &gt; n) { break; } if (can_seat(pos - 2) &amp;&amp; can_seat(n - pos - 1)) { return pos; } } return -1; } 채점 허허 정답비율 나 혼자 다깎아먹었넹 반성 반복문 조건도 잘 못잡고 균등분할 조건도 잘 못잡고 제대로 했으면 덜 틀렸을걸 실컷 틀렸다. 아주 고봉밥이다 어우 배불러 근데 분명 더 멋진 풀이가 있을거란 말이지 맞힌 사람 보면 코드 길이가 심상치가 않다. 코드 확인 Link to GitHub]]></summary></entry><entry><title type="html">미로 생성기 03</title><link href="https://movingwoo.com/one-pan/javascript/2025/05/23/Maze-Generator-03.html" rel="alternate" type="text/html" title="미로 생성기 03" /><published>2025-05-23T01:00:00+00:00</published><updated>2025-05-23T01:00:00+00:00</updated><id>https://movingwoo.com/one-pan/javascript/2025/05/23/Maze%20Generator%2003</id><content type="html" xml:base="https://movingwoo.com/one-pan/javascript/2025/05/23/Maze-Generator-03.html"><![CDATA[<blockquote>
  <h4 id="개요">개요</h4>
  <hr />
</blockquote>

<p>남은 알고리즘 미로 추가하여 미로 생성기 완성하기.</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<p>시작 전에 길찾고 그리는 부분이 중복되기 때문에 공통 함수로 옮겨줬다.</p>

<h5 id="1-binary-tree-알고리즘과-sidewinder-알고리즘">1. Binary Tree 알고리즘과 Sidewinder 알고리즘</h5>

<p>두 알고리즘의 미로 생성 과정이나 결과물은 상당히 유사해보인다.<br />
셀에서 방향을 무작위로 선택해 벽을 제거하고 나아가는 방식이다.</p>

<p>차이점을 정리해보면</p>
<ul>
  <li>Binary Tree
    <ul>
      <li>각 셀마다 독립적으로 결정을 내림</li>
      <li>대각선 방향의 경향</li>
    </ul>
  </li>
  <li>Sidewinder
    <ul>
      <li>연속된 동쪽 경로인 run이라는 개념을 활용, 동쪽으로 진행</li>
      <li>현재 run에서 무작위 셀을 남쪽으로 연결하며 run 종료</li>
      <li>이전 셀들의 선택이 다음 셀 선택에 영향을 줌</li>
      <li>수평 방향의 경향</li>
    </ul>
  </li>
</ul>

<p>실제 입구 출구를 이어보면 이는 더 명확하게 드러난다.<br />
전통적인 Sidewinder 알고리즘 사용시 동쪽과 북쪽을 선택하는데<br />
시작 좌표를 [0, 0] 으로 잡기 때문에 동쪽과 남쪽으로 진행하게 방향을 잡았다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Binary Tree 알고리즘</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">generateBinaryTree</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 모든 셀을 벽으로 초기화</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 각 셀에 대해</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 현재 셀을 통로로 만들기</span>
            <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>

            <span class="c1">// 동쪽과 남쪽 중 하나를 무작위로 선택</span>
            <span class="kd">const</span> <span class="nx">canGoEast</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span>
            <span class="kd">const</span> <span class="nx">canGoSouth</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span>

            <span class="k">if </span><span class="p">(</span><span class="nx">canGoEast</span> <span class="o">&amp;&amp;</span> <span class="nx">canGoSouth</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 둘 다 가능하면 무작위로 선택</span>
                <span class="k">if </span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// 동쪽으로</span>
                    <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="c1">// 남쪽으로</span>
                    <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">canGoEast</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 동쪽만 가능</span>
                <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">canGoSouth</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 남쪽만 가능</span>
                <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Sidewinder 알고리즘</span>
<span class="c1">// 전통적인 Sidewinder 알고리즘은 북쪽으로 길을 파는데 입구가 0,0이라 남쪽으로 파는 것으로 변경</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">generateSidewinder</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 모든 셀을 벽으로 초기화</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 각 행을 처리</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">run</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// 현재 실행 중인 경로 (연속된 동쪽 경로)</span>

        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 현재 셀을 통로로 만들기</span>
            <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
            <span class="nx">run</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">]);</span> <span class="c1">// 현재 셀을 run에 추가</span>

            <span class="c1">// 동쪽으로 갈 수 있는지 확인</span>
            <span class="kd">const</span> <span class="nx">canGoEast</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span>
            <span class="c1">// 남쪽으로 갈 수 있는지 확인</span>
            <span class="kd">const</span> <span class="nx">canGoSouth</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span>

            <span class="c1">// 동쪽으로 계속 진행할지, 남쪽으로 연결할지 결정</span>
            <span class="c1">// 1. 동쪽으로 갈 수 없거나</span>
            <span class="c1">// 2. 남쪽으로 갈 수 있고 50% 확률로 run을 종료</span>
            <span class="kd">const</span> <span class="nx">shouldCloseOut</span> <span class="o">=</span> <span class="o">!</span><span class="nx">canGoEast</span> <span class="o">||</span> <span class="p">(</span><span class="nx">canGoSouth</span> <span class="o">&amp;&amp;</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">);</span>

            <span class="k">if </span><span class="p">(</span><span class="nx">shouldCloseOut</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 현재 run에서 무작위로 선택된 셀을 남쪽과 연결</span>
                <span class="kd">const</span> <span class="p">[</span><span class="nx">rx</span><span class="p">,</span> <span class="nx">ry</span><span class="p">]</span> <span class="o">=</span> <span class="nx">run</span><span class="p">[</span><span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">run</span><span class="p">.</span><span class="nx">length</span><span class="p">)];</span>
                <span class="k">if </span><span class="p">(</span><span class="nx">canGoSouth</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">maze</span><span class="p">[</span><span class="nx">ry</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="nx">rx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">rx</span><span class="p">,</span> <span class="nx">ry</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="nx">run</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// run 초기화</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// 동쪽으로 계속 진행 (run 확장)</span>
                <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="2-recursive-division-알고리즘">2. Recursive Division 알고리즘</h5>

<p>Resursive Division 알고리즘으로 생성된 미로를 보면 다른 미로들과 비교해 상당히 이질적이다.<br />
마치 던전 맵 같은 방 구조로 되어있으며 <span style="color: orange;"><strong>접근할 수 없는 갇힌 방</strong></span>도 만들어진다.</p>

<p>공간을 분할하며 한 줄짜리 벽을 만들고 벽에 단 하나의 통로만 뚫는다.<br />
이 과정이 반복되며 어떤 영역은 한 통로만 생기고 나머지는 벽으로 막혀버릴 수 있다.</p>

<p>모든 칸이 연결된 완전 미로를 만들기 위해 코드를 약간 수정했다.<br />
벽을 만들 때 이미 통로가 있는지 확인하고 막히게 된다면 추가로 통로를 더 뚫어주는 로직을 넣어주었다.<br />
그래도 막힌 방이 생성됨… 좀 벽을 더 뚫어줘야할 것 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Recursive Division 알고리즘</span>
<span class="c1">// 완전 미로를 만들기 위한 커스텀</span>
<span class="c1">// 분할선 크기 조정 시 방 크기 조정</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">generateRecursiveDivision</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">,</span> <span class="nx">orientation</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 방이 너무 작으면 중단</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">x2</span> <span class="o">-</span> <span class="nx">x1</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">||</span> <span class="nx">y2</span> <span class="o">-</span> <span class="nx">y1</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 수평</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">orientation</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">horizontal</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 분할선 후보(짝수)</span>
        <span class="kd">const</span> <span class="nx">possibleYs</span> <span class="o">=</span> <span class="p">[];</span>
        
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">y1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">y2</span><span class="p">;</span> <span class="nx">y</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">possibleYs</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if </span><span class="p">(</span><span class="nx">possibleYs</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 분할선 후보가 없으면 중단</span>
            <span class="k">return</span><span class="p">;</span> 
        <span class="p">}</span>
        <span class="kd">const</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">possibleYs</span><span class="p">[</span><span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">possibleYs</span><span class="p">.</span><span class="nx">length</span><span class="p">)];</span>

        <span class="c1">// 통로 후보(홀수)</span>
        <span class="kd">const</span> <span class="nx">possiblePassages</span> <span class="o">=</span> <span class="p">[];</span>
        
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">x1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">x2</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">possiblePassages</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="k">if </span><span class="p">(</span><span class="nx">possiblePassages</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 통로 후보가 없으면 중단</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 반드시 하나는 통로로 만들고, 추가로 통로를 더 만들 확률도 부여</span>
        <span class="kd">const</span> <span class="nx">passageCount</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">possiblePassages</span><span class="p">.</span><span class="nx">length</span> <span class="o">/</span> <span class="mi">3</span><span class="p">));</span>
        <span class="kd">const</span> <span class="nx">passages</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="kd">const</span> <span class="nx">passageCandidates</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">possiblePassages</span><span class="p">];</span>
        <span class="k">while </span><span class="p">(</span><span class="nx">passages</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="nx">passageCount</span> <span class="o">&amp;&amp;</span> <span class="nx">passageCandidates</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">idx</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">passageCandidates</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
            <span class="kd">const</span> <span class="nx">px</span> <span class="o">=</span> <span class="nx">passageCandidates</span><span class="p">.</span><span class="nf">splice</span><span class="p">(</span><span class="nx">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
            <span class="nx">passages</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">px</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// 벽 생성 (통로 제외)</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">x1</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;=</span> <span class="nx">x2</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">passages</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span> <span class="p">{</span>
                <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

        <span class="c1">// 위/아래 영역 재귀 호출</span>
        <span class="k">await</span> <span class="nf">generateRecursiveDivision</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">vertical</span><span class="dl">'</span><span class="p">);</span>
        <span class="k">await</span> <span class="nf">generateRecursiveDivision</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">,</span> <span class="dl">'</span><span class="s1">vertical</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// 수직</span>
        <span class="c1">// 분할선 후보(짝수)</span>
        <span class="kd">const</span> <span class="nx">possibleXs</span> <span class="o">=</span> <span class="p">[];</span>
        
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">x1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">x2</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">possibleXs</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if </span><span class="p">(</span><span class="nx">possibleXs</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 분할선 후보가 없으면 중단</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">possibleXs</span><span class="p">[</span><span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">possibleXs</span><span class="p">.</span><span class="nx">length</span><span class="p">)];</span>

        <span class="c1">// 통로 후보(홀수)</span>
        <span class="kd">const</span> <span class="nx">possiblePassages</span> <span class="o">=</span> <span class="p">[];</span>

        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">y1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">y2</span><span class="p">;</span> <span class="nx">y</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">possiblePassages</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if </span><span class="p">(</span><span class="nx">possiblePassages</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 통로 후보가 없으면 중단</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 반드시 하나는 통로로 만들고, 추가로 통로를 더 만들 확률도 부여</span>
        <span class="kd">const</span> <span class="nx">passageCount</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">possiblePassages</span><span class="p">.</span><span class="nx">length</span> <span class="o">/</span> <span class="mi">3</span><span class="p">));</span>
        <span class="kd">const</span> <span class="nx">passages</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="kd">const</span> <span class="nx">passageCandidates</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">possiblePassages</span><span class="p">];</span>
        <span class="k">while </span><span class="p">(</span><span class="nx">passages</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="nx">passageCount</span> <span class="o">&amp;&amp;</span> <span class="nx">passageCandidates</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">idx</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">passageCandidates</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
            <span class="kd">const</span> <span class="nx">py</span> <span class="o">=</span> <span class="nx">passageCandidates</span><span class="p">.</span><span class="nf">splice</span><span class="p">(</span><span class="nx">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
            <span class="nx">passages</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">py</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// 벽 생성 (통로 제외)</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">y1</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;=</span> <span class="nx">y2</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">passages</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="nx">y</span><span class="p">))</span> <span class="p">{</span>
                <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

        <span class="c1">// 좌/우 영역 재귀 호출</span>
        <span class="k">await</span> <span class="nf">generateRecursiveDivision</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y2</span><span class="p">,</span> <span class="dl">'</span><span class="s1">horizontal</span><span class="dl">'</span><span class="p">);</span>
        <span class="k">await</span> <span class="nf">generateRecursiveDivision</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">,</span> <span class="dl">'</span><span class="s1">horizontal</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="3-ellers-알고리즘">3. Eller’s 알고리즘</h5>

<p>Eller’s 알고리즘은 각 행마다 집합을 관리하며 벽을 뚫을 때 집합을 병합하거나 새로 부여한다.<br />
한 줄씩 처리하며 집합 연산과 벽 뚫기만 하고 복잡한 경로 탐색이 없어서 <span style="color: orange;"><strong>메모리 접근이 효율적이고 엄청나게 빠르다.</strong></span></p>

<p>실제로 시뮬레이션 돌리면 혼자서 미로를 호다닥 생성해버린다.</p>

<p>엄청나게 빠른게 장점이라면 단점으로는 무작위성이 떨어지며 수평으로 편향되어 있다는 점 정도? 
좀 숭숭 뚫려있는 느낌도 받는다.<br />
수직으로 한 칸 짜리 벽 생성을 지양해야하는데 수평으로 한 줄씩 처리하기 때문에 수직 처리하기 곤란하다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Eller's Algorithm 미로 생성</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">generateEller</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 모든 셀을 벽으로 초기화</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 각 셀의 집합 번호를 저장할 배열</span>
    <span class="kd">let</span> <span class="nx">sets</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">let</span> <span class="nx">nextSet</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// 첫 번째 행 초기화</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">sets</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nextSet</span><span class="o">++</span><span class="p">;</span>
        <span class="nx">maze</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 각 행을 처리</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 1. 오른쪽으로 벽을 뚫을지 결정</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 같은 집합이 아니고, 랜덤하게 벽을 뚫기로 결정하면</span>
            <span class="k">if </span><span class="p">(</span><span class="nx">sets</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">!==</span> <span class="nx">sets</span><span class="p">[</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 벽 뚫기</span>
                <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
                <span class="c1">// 집합 병합</span>
                <span class="kd">const</span> <span class="nx">oldSet</span> <span class="o">=</span> <span class="nx">sets</span><span class="p">[</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
                <span class="kd">const</span> <span class="nx">newSet</span> <span class="o">=</span> <span class="nx">sets</span><span class="p">[</span><span class="nx">x</span><span class="p">];</span>
                <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">if </span><span class="p">(</span><span class="nx">sets</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="nx">oldSet</span><span class="p">)</span> <span class="nx">sets</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">newSet</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 마지막 행이 아니면 아래로 벽을 뚫기</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 각 집합별로 아래로 연결할 셀을 최소 1개 이상 선택</span>
            <span class="kd">const</span> <span class="nx">setCells</span> <span class="o">=</span> <span class="p">{};</span>
            <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">setCells</span><span class="p">[</span><span class="nx">sets</span><span class="p">[</span><span class="nx">x</span><span class="p">]])</span> <span class="nx">setCells</span><span class="p">[</span><span class="nx">sets</span><span class="p">[</span><span class="nx">x</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[];</span>
                <span class="nx">setCells</span><span class="p">[</span><span class="nx">sets</span><span class="p">[</span><span class="nx">x</span><span class="p">]].</span><span class="nf">push</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="c1">// 아래로 연결</span>
            <span class="kd">let</span> <span class="nx">newSets</span> <span class="o">=</span> <span class="p">[];</span>
            <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="kd">set</span> <span class="k">in</span> <span class="nx">setCells</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 반드시 하나는 아래로 연결</span>
                <span class="kd">const</span> <span class="nx">cells</span> <span class="o">=</span> <span class="nx">setCells</span><span class="p">[</span><span class="kd">set</span><span class="p">];</span>
                <span class="kd">const</span> <span class="nx">shuffled</span> <span class="o">=</span> <span class="nx">cells</span><span class="p">.</span><span class="nf">slice</span><span class="p">().</span><span class="nf">sort</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">);</span>
                <span class="kd">const</span> <span class="nx">downCount</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">cells</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
                <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">downCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">shuffled</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
                    <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
                    <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
                    <span class="nx">newSets</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nextSet</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="c1">// 나머지 셀은 새로운 집합 번호 부여</span>
            <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">newSets</span><span class="p">[</span><span class="nx">x</span><span class="p">])</span> <span class="p">{</span>
                    <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
                    <span class="nx">newSets</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nextSet</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nx">sets</span> <span class="o">=</span> <span class="nx">newSets</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="완성">완성</h4>
  <hr />
</blockquote>

<p>Binary Tree 알고리즘 미로</p>

<p><img src="/assets/images/posts/one-pan/JavaScript/2025-05-23-Maze Generator 03/img01.gif" alt="img01" /></p>

<p>Sidewinder 알고리즘 미로</p>

<p><img src="/assets/images/posts/one-pan/JavaScript/2025-05-23-Maze Generator 03/img02.gif" alt="img02" /></p>

<p>Recursive Division 알고리즘 미로</p>

<p><img src="/assets/images/posts/one-pan/JavaScript/2025-05-23-Maze Generator 03/img03.gif" alt="img03" /></p>

<p>Eller’s 알고리즘 미로</p>

<p><img src="/assets/images/posts/one-pan/JavaScript/2025-05-23-Maze Generator 03/img04.gif" alt="img04" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>7종 알고리즘 미로를 완성했다.<br />
그 외 몇가지 알고리즘이 더 있긴한데, 대표적으로 이 7종이면 더 맛 볼 필요는 없다고 한다.</p>

<p>그리고 미로 알고리즘 짜다가 알게 되었는데 던전 맵 만드는 알고리즘과 미로 알고리즘은 또 다르다고 한다…<br />
정리 되면 던전 맵 시뮬레이터도 만들어봐야겠다.</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="/play/Maze%20Generator.html" target="_blank" rel="noopener noreferrer">
  직접 해보기
</a></p>

<p>Binary Tree<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-23-BinaryTree.js">Link to GitHub</a></p>

<p>Sidewinder<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-23-Sidewinder.js">Link to GitHub</a></p>

<p>Recursive Division<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-23-RecursiveDivision.js">Link to GitHub</a></p>

<p>Eller’s<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-23-Eller.js">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="one-pan/JavaScript/" /><summary type="html"><![CDATA[개요 남은 알고리즘 미로 추가하여 미로 생성기 완성하기. 구현 시작 전에 길찾고 그리는 부분이 중복되기 때문에 공통 함수로 옮겨줬다. 1. Binary Tree 알고리즘과 Sidewinder 알고리즘 두 알고리즘의 미로 생성 과정이나 결과물은 상당히 유사해보인다. 셀에서 방향을 무작위로 선택해 벽을 제거하고 나아가는 방식이다. 차이점을 정리해보면 Binary Tree 각 셀마다 독립적으로 결정을 내림 대각선 방향의 경향 Sidewinder 연속된 동쪽 경로인 run이라는 개념을 활용, 동쪽으로 진행 현재 run에서 무작위 셀을 남쪽으로 연결하며 run 종료 이전 셀들의 선택이 다음 셀 선택에 영향을 줌 수평 방향의 경향 실제 입구 출구를 이어보면 이는 더 명확하게 드러난다. 전통적인 Sidewinder 알고리즘 사용시 동쪽과 북쪽을 선택하는데 시작 좌표를 [0, 0] 으로 잡기 때문에 동쪽과 남쪽으로 진행하게 방향을 잡았다. // Binary Tree 알고리즘 async function generateBinaryTree() { // 모든 셀을 벽으로 초기화 for (let y = 0; y &lt; rows; y++) { for (let x = 0; x &lt; cols; x++) { maze[y][x] = 1; drawCell(x, y, 'black'); } } // 각 셀에 대해 for (let y = 0; y &lt; rows; y += 2) { for (let x = 0; x &lt; cols; x += 2) { // 현재 셀을 통로로 만들기 maze[y][x] = 0; drawCell(x, y, 'white'); // 동쪽과 남쪽 중 하나를 무작위로 선택 const canGoEast = x + 2 &lt; cols; const canGoSouth = y + 2 &lt; rows; if (canGoEast &amp;&amp; canGoSouth) { // 둘 다 가능하면 무작위로 선택 if (Math.random() &lt; 0.5) { // 동쪽으로 maze[y][x + 1] = 0; drawCell(x + 1, y, 'white'); } else { // 남쪽으로 maze[y + 1][x] = 0; drawCell(x, y + 1, 'white'); } } else if (canGoEast) { // 동쪽만 가능 maze[y][x + 1] = 0; drawCell(x + 1, y, 'white'); } else if (canGoSouth) { // 남쪽만 가능 maze[y + 1][x] = 0; drawCell(x, y + 1, 'white'); } await sleep(5); } } } // Sidewinder 알고리즘 // 전통적인 Sidewinder 알고리즘은 북쪽으로 길을 파는데 입구가 0,0이라 남쪽으로 파는 것으로 변경 async function generateSidewinder() { // 모든 셀을 벽으로 초기화 for (let y = 0; y &lt; rows; y++) { for (let x = 0; x &lt; cols; x++) { maze[y][x] = 1; drawCell(x, y, 'black'); } } // 각 행을 처리 for (let y = 0; y &lt; rows; y += 2) { let run = []; // 현재 실행 중인 경로 (연속된 동쪽 경로) for (let x = 0; x &lt; cols; x += 2) { // 현재 셀을 통로로 만들기 maze[y][x] = 0; drawCell(x, y, 'white'); run.push([x, y]); // 현재 셀을 run에 추가 // 동쪽으로 갈 수 있는지 확인 const canGoEast = x + 2 &lt; cols; // 남쪽으로 갈 수 있는지 확인 const canGoSouth = y + 2 &lt; rows; // 동쪽으로 계속 진행할지, 남쪽으로 연결할지 결정 // 1. 동쪽으로 갈 수 없거나 // 2. 남쪽으로 갈 수 있고 50% 확률로 run을 종료 const shouldCloseOut = !canGoEast || (canGoSouth &amp;&amp; Math.random() &lt; 0.5); if (shouldCloseOut) { // 현재 run에서 무작위로 선택된 셀을 남쪽과 연결 const [rx, ry] = run[Math.floor(Math.random() * run.length)]; if (canGoSouth) { maze[ry + 1][rx] = 0; drawCell(rx, ry + 1, 'white'); } run = []; // run 초기화 } else { // 동쪽으로 계속 진행 (run 확장) maze[y][x + 1] = 0; drawCell(x + 1, y, 'white'); } await sleep(5); } } } 2. Recursive Division 알고리즘 Resursive Division 알고리즘으로 생성된 미로를 보면 다른 미로들과 비교해 상당히 이질적이다. 마치 던전 맵 같은 방 구조로 되어있으며 접근할 수 없는 갇힌 방도 만들어진다. 공간을 분할하며 한 줄짜리 벽을 만들고 벽에 단 하나의 통로만 뚫는다. 이 과정이 반복되며 어떤 영역은 한 통로만 생기고 나머지는 벽으로 막혀버릴 수 있다. 모든 칸이 연결된 완전 미로를 만들기 위해 코드를 약간 수정했다. 벽을 만들 때 이미 통로가 있는지 확인하고 막히게 된다면 추가로 통로를 더 뚫어주는 로직을 넣어주었다. 그래도 막힌 방이 생성됨… 좀 벽을 더 뚫어줘야할 것 같다. // Recursive Division 알고리즘 // 완전 미로를 만들기 위한 커스텀 // 분할선 크기 조정 시 방 크기 조정 async function generateRecursiveDivision(x1, y1, x2, y2, orientation) { // 방이 너무 작으면 중단 if (x2 - x1 &lt; 2 || y2 - y1 &lt; 2) { return; } // 수평 if (orientation === 'horizontal') { // 분할선 후보(짝수) const possibleYs = []; for (let y = y1 + 2; y &lt; y2; y += 2) { possibleYs.push(y); } if (possibleYs.length === 0) { // 분할선 후보가 없으면 중단 return; } const y = possibleYs[Math.floor(Math.random() * possibleYs.length)]; // 통로 후보(홀수) const possiblePassages = []; for (let x = x1 + 1; x &lt; x2; x += 2) { possiblePassages.push(x); } if (possiblePassages.length === 0) { // 통로 후보가 없으면 중단 return; } // 반드시 하나는 통로로 만들고, 추가로 통로를 더 만들 확률도 부여 const passageCount = 1 + Math.floor(Math.random() * Math.max(1, possiblePassages.length / 3)); const passages = []; const passageCandidates = [...possiblePassages]; while (passages.length &lt; passageCount &amp;&amp; passageCandidates.length &gt; 0) { const idx = Math.floor(Math.random() * passageCandidates.length); const px = passageCandidates.splice(idx, 1)[0]; passages.push(px); } // 벽 생성 (통로 제외) for (let x = x1; x &lt;= x2; x++) { if (!passages.includes(x)) { maze[y][x] = 1; drawCell(x, y, 'black'); } } await sleep(5); // 위/아래 영역 재귀 호출 await generateRecursiveDivision(x1, y1, x2, y - 1, 'vertical'); await generateRecursiveDivision(x1, y + 1, x2, y2, 'vertical'); } else { // 수직 // 분할선 후보(짝수) const possibleXs = []; for (let x = x1 + 2; x &lt; x2; x += 2) { possibleXs.push(x); } if (possibleXs.length === 0) { // 분할선 후보가 없으면 중단 return; } const x = possibleXs[Math.floor(Math.random() * possibleXs.length)]; // 통로 후보(홀수) const possiblePassages = []; for (let y = y1 + 1; y &lt; y2; y += 2) { possiblePassages.push(y); } if (possiblePassages.length === 0) { // 통로 후보가 없으면 중단 return; } // 반드시 하나는 통로로 만들고, 추가로 통로를 더 만들 확률도 부여 const passageCount = 1 + Math.floor(Math.random() * Math.max(1, possiblePassages.length / 3)); const passages = []; const passageCandidates = [...possiblePassages]; while (passages.length &lt; passageCount &amp;&amp; passageCandidates.length &gt; 0) { const idx = Math.floor(Math.random() * passageCandidates.length); const py = passageCandidates.splice(idx, 1)[0]; passages.push(py); } // 벽 생성 (통로 제외) for (let y = y1; y &lt;= y2; y++) { if (!passages.includes(y)) { maze[y][x] = 1; drawCell(x, y, 'black'); } } await sleep(5); // 좌/우 영역 재귀 호출 await generateRecursiveDivision(x1, y1, x - 1, y2, 'horizontal'); await generateRecursiveDivision(x + 1, y1, x2, y2, 'horizontal'); } } 3. Eller’s 알고리즘 Eller’s 알고리즘은 각 행마다 집합을 관리하며 벽을 뚫을 때 집합을 병합하거나 새로 부여한다. 한 줄씩 처리하며 집합 연산과 벽 뚫기만 하고 복잡한 경로 탐색이 없어서 메모리 접근이 효율적이고 엄청나게 빠르다. 실제로 시뮬레이션 돌리면 혼자서 미로를 호다닥 생성해버린다. 엄청나게 빠른게 장점이라면 단점으로는 무작위성이 떨어지며 수평으로 편향되어 있다는 점 정도? 좀 숭숭 뚫려있는 느낌도 받는다. 수직으로 한 칸 짜리 벽 생성을 지양해야하는데 수평으로 한 줄씩 처리하기 때문에 수직 처리하기 곤란하다. // Eller's Algorithm 미로 생성 async function generateEller() { // 모든 셀을 벽으로 초기화 for (let y = 0; y &lt; rows; y++) { for (let x = 0; x &lt; cols; x++) { maze[y][x] = 1; drawCell(x, y, 'black'); } } // 각 셀의 집합 번호를 저장할 배열 let sets = []; let nextSet = 1; // 첫 번째 행 초기화 for (let x = 0; x &lt; cols; x += 2) { sets[x] = nextSet++; maze[0][x] = 0; drawCell(x, 0, 'white'); } // 각 행을 처리 for (let y = 0; y &lt; rows; y += 2) { // 1. 오른쪽으로 벽을 뚫을지 결정 for (let x = 0; x &lt; cols - 2; x += 2) { // 같은 집합이 아니고, 랜덤하게 벽을 뚫기로 결정하면 if (sets[x] !== sets[x + 2] &amp;&amp; Math.random() &lt; 0.5) { // 벽 뚫기 maze[y][x + 1] = 0; drawCell(x + 1, y, 'white'); // 집합 병합 const oldSet = sets[x + 2]; const newSet = sets[x]; for (let i = 0; i &lt; cols; i += 2) { if (sets[i] === oldSet) sets[i] = newSet; } } } // 마지막 행이 아니면 아래로 벽을 뚫기 if (y + 2 &lt; rows) { // 각 집합별로 아래로 연결할 셀을 최소 1개 이상 선택 const setCells = {}; for (let x = 0; x &lt; cols; x += 2) { if (!setCells[sets[x]]) setCells[sets[x]] = []; setCells[sets[x]].push(x); } // 아래로 연결 let newSets = []; for (const set in setCells) { // 반드시 하나는 아래로 연결 const cells = setCells[set]; const shuffled = cells.slice().sort(() =&gt; Math.random() - 0.5); const downCount = 1 + Math.floor(Math.random() * cells.length); for (let i = 0; i &lt; downCount; i++) { const x = shuffled[i]; maze[y + 1][x] = 0; drawCell(x, y + 1, 'white'); maze[y + 2][x] = 0; drawCell(x, y + 2, 'white'); newSets[x] = nextSet++; } } // 나머지 셀은 새로운 집합 번호 부여 for (let x = 0; x &lt; cols; x += 2) { if (!newSets[x]) { maze[y + 2][x] = 0; drawCell(x, y + 2, 'white'); newSets[x] = nextSet++; } } sets = newSets; } await sleep(10); } } 완성 Binary Tree 알고리즘 미로 Sidewinder 알고리즘 미로 Recursive Division 알고리즘 미로 Eller’s 알고리즘 미로 반성 7종 알고리즘 미로를 완성했다. 그 외 몇가지 알고리즘이 더 있긴한데, 대표적으로 이 7종이면 더 맛 볼 필요는 없다고 한다. 그리고 미로 알고리즘 짜다가 알게 되었는데 던전 맵 만드는 알고리즘과 미로 알고리즘은 또 다르다고 한다… 정리 되면 던전 맵 시뮬레이터도 만들어봐야겠다. 코드 확인 직접 해보기 Binary Tree Link to GitHub Sidewinder Link to GitHub Recursive Division Link to GitHub Eller’s Link to GitHub]]></summary></entry><entry><title type="html">26489번 Gum Gum for Jay Jay</title><link href="https://movingwoo.com/random-solve/python/2025/05/22/26489.html" rel="alternate" type="text/html" title="26489번 Gum Gum for Jay Jay" /><published>2025-05-22T02:00:00+00:00</published><updated>2025-05-22T02:00:00+00:00</updated><id>https://movingwoo.com/random-solve/python/2025/05/22/26489</id><content type="html" xml:base="https://movingwoo.com/random-solve/python/2025/05/22/26489.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Python/2025-05-22-26489/img01.jpg" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/26489">26489번 Gum Gum for Jay Jay - 백준</a></p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>엌ㅋㅋㅋㅋㅋ 개날먹 문제 ㅋㅋㅋㅋㅋ<br />
좋아좋아 이런 날도 있어야지.</p>

<p>입력 들어오는 라인 수를 세기만 하면 되는 개꿀문제다.</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">try</span><span class="p">:</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="nf">input</span><span class="p">()</span>
        <span class="n">n</span><span class="o">+=</span><span class="mi">1</span>
<span class="k">except</span> <span class="nb">EOFError</span><span class="p">:</span>
    <span class="k">pass</span> 

<span class="nf">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</code></pre></div></div>

<p>끝이다.<br />
<span style="color: red;"><strong>아니 내 컨텐츠가!!!!!!!</strong></span><br />
너무 쉬운 문제는 이런게 문제구나.</p>

<p>이왕 이렇게 된 것, C++과 Java로도 처리하자.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>자바는 스캐너로 EOF 판단하는게 낫다.<br />
어차피 속도가 중요한 문제도 아니니</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">Scanner</span> <span class="n">sc</span><span class="o">=</span><span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
		<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>

		<span class="k">while</span><span class="o">(</span><span class="n">sc</span><span class="o">.</span><span class="na">hasNextLine</span><span class="o">())</span> <span class="o">{</span>
			<span class="n">sc</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span>
			<span class="n">n</span><span class="o">++;</span>
		<span class="o">}</span>

		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Python/2025-05-22-26489/img02.jpg" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p><span style="color: red;"><strong>뭐???? 파이썬에서 틀렸습니다가 발생했다고???????</strong></span><br />
파이썬은 ++n이 없고 n+=1을 해야하는데 자연스럽게 ++n한 나의 실수다.<br />
이렇게 개꿀문제에서도 반성할 점은 있는 법.</p>

<p>날먹 날먹 신나는 날먹</p>]]></content><author><name>movingwoo</name></author><category term="random-solve/Python/" /><summary type="html"><![CDATA[문제 26489번 Gum Gum for Jay Jay - 백준 설계 엌ㅋㅋㅋㅋㅋ 개날먹 문제 ㅋㅋㅋㅋㅋ 좋아좋아 이런 날도 있어야지. 입력 들어오는 라인 수를 세기만 하면 되는 개꿀문제다. 구현 n = 0 try: while True: input() n+=1 except EOFError: pass print(n) 끝이다. 아니 내 컨텐츠가!!!!!!! 너무 쉬운 문제는 이런게 문제구나. 이왕 이렇게 된 것, C++과 Java로도 처리하자. #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { int n = 0; string s; while (getline(cin, s)) { ++n; } cout &lt;&lt; n; return 0; } 자바는 스캐너로 EOF 판단하는게 낫다. 어차피 속도가 중요한 문제도 아니니 import java.util.*; public class Main { public static void main(String[] args) { Scanner sc=new Scanner(System.in); int n=0; while(sc.hasNextLine()) { sc.nextLine(); n++; } System.out.print(n); } } 채점 반성 뭐???? 파이썬에서 틀렸습니다가 발생했다고??????? 파이썬은 ++n이 없고 n+=1을 해야하는데 자연스럽게 ++n한 나의 실수다. 이렇게 개꿀문제에서도 반성할 점은 있는 법. 날먹 날먹 신나는 날먹]]></summary></entry><entry><title type="html">미로 생성기 02</title><link href="https://movingwoo.com/one-pan/javascript/2025/05/21/Maze-Generator-02.html" rel="alternate" type="text/html" title="미로 생성기 02" /><published>2025-05-21T23:00:00+00:00</published><updated>2025-05-21T23:00:00+00:00</updated><id>https://movingwoo.com/one-pan/javascript/2025/05/21/Maze%20Generator%2002</id><content type="html" xml:base="https://movingwoo.com/one-pan/javascript/2025/05/21/Maze-Generator-02.html"><![CDATA[<blockquote>
  <h4 id="개요">개요</h4>
  <hr />
</blockquote>

<p>Prim’s 알고리즘과 Kruskal’s 알고리즘의 미로를 추가하기</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<p>시작 전에 공통으로 사용할 함수를 index로 몰아준다.</p>

<h5 id="1-prims-알고리즘">1. Prim’s 알고리즘</h5>

<p>DFS와 Prim의 미로는 겉으로는 제법 유사해보이는데 Prim은 탈출 경로가 훨씬 단순해진다.<br />
DFS는 한 방향으로 쭈욱 파다가 막히면 돌아가서 새로운 길을 찾는데,<br />
Prim은 미로의 경계에서 새로운 길을 만들기 때문이다.</p>

<p>느낌으로 비교하자면 DFS는 <span style="color: orange;"><strong>‘길을 파는 것’</strong></span>이고 Prim은 <span style="color: orange;"><strong>‘벽을 뚫는 것’</strong></span>이다.<br />
벽을 뚫는 것이기 때문에 인접한 벽(여기서는 프론티어)을 모아두고 랜덤으로 선택해서 뚫어나간다.</p>

<p>DFS와 마찬가지로 js를 작성하고 기존 html에 스크립트를 추가한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Prim's 알고리즘</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">generatePrim</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 시작점 (0,0)</span>
    <span class="kd">const</span> <span class="nx">startX</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">startY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">maze</span><span class="p">[</span><span class="nx">startY</span><span class="p">][</span><span class="nx">startX</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">startX</span><span class="p">,</span> <span class="nx">startY</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>

    <span class="c1">// 프론티어 셀</span>
    <span class="kd">const</span> <span class="nx">frontiers</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">const</span> <span class="nx">frontierSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">();</span>
    <span class="nf">addFrontiers</span><span class="p">(</span><span class="nx">startX</span><span class="p">,</span> <span class="nx">startY</span><span class="p">,</span> <span class="nx">frontiers</span><span class="p">,</span> <span class="nx">frontierSet</span><span class="p">);</span>

    <span class="k">while </span><span class="p">(</span><span class="nx">frontiers</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 무작위 프론티어 선택</span>
        <span class="kd">const</span> <span class="nx">randomIndex</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">frontiers</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
        <span class="kd">const</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">]</span> <span class="o">=</span> <span class="nx">frontiers</span><span class="p">.</span><span class="nf">splice</span><span class="p">(</span><span class="nx">randomIndex</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
        <span class="nx">frontierSet</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">x</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">y</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>

        <span class="c1">// 인접한 통로 찾기 (경계 포함)</span>
        <span class="kd">const</span> <span class="nx">neighbors</span> <span class="o">=</span> <span class="nf">getNeighbors</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>

        <span class="k">if </span><span class="p">(</span><span class="nx">neighbors</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 인접 통로 없으면 무시</span>
            <span class="k">continue</span><span class="p">;</span> 
        <span class="p">}</span>

        <span class="c1">// 무작위 인접 통로 선택</span>
        <span class="kd">const</span> <span class="p">[</span><span class="nx">nx</span><span class="p">,</span> <span class="nx">ny</span><span class="p">]</span> <span class="o">=</span> <span class="nx">neighbors</span><span class="p">[</span><span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">neighbors</span><span class="p">.</span><span class="nx">length</span><span class="p">)];</span>

        <span class="c1">// 벽 뚫기</span>
        <span class="kd">const</span> <span class="nx">wallX</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">nx</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">wallY</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">ny</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="nx">maze</span><span class="p">[</span><span class="nx">wallY</span><span class="p">][</span><span class="nx">wallX</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        
        <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
        <span class="nf">drawCell</span><span class="p">(</span><span class="nx">wallX</span><span class="p">,</span> <span class="nx">wallY</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>

        <span class="c1">// 새로운 프론티어 추가</span>
        <span class="nf">addFrontiers</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">frontiers</span><span class="p">,</span> <span class="nx">frontierSet</span><span class="p">);</span>
        <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 프론티어 셀 추가 (중복 방지, 경계 포함)</span>
<span class="kd">function</span> <span class="nf">addFrontiers</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">frontiers</span><span class="p">,</span> <span class="nx">frontierSet</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">dirs</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]];</span>

    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">]</span> <span class="k">of</span> <span class="nx">dirs</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">nx</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">ny</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">nx</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">ny</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>

        <span class="k">if </span><span class="p">(</span><span class="nx">nx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nx</span> <span class="o">&lt;</span> <span class="nx">cols</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&lt;</span> <span class="nx">rows</span> <span class="o">&amp;&amp;</span> <span class="nx">maze</span><span class="p">[</span><span class="nx">ny</span><span class="p">][</span><span class="nx">nx</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">frontierSet</span><span class="p">.</span><span class="nf">has</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">frontiers</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">nx</span><span class="p">,</span> <span class="nx">ny</span><span class="p">]);</span>
            <span class="nx">frontierSet</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 인접한 통로 찾기 (경계 포함)</span>
<span class="kd">function</span> <span class="nf">getNeighbors</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">neighbors</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">const</span> <span class="nx">dirs</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]];</span>

    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">]</span> <span class="k">of</span> <span class="nx">dirs</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">nx</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">ny</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">;</span>

        <span class="k">if </span><span class="p">(</span><span class="nx">nx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nx</span> <span class="o">&lt;</span> <span class="nx">cols</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&lt;</span> <span class="nx">rows</span> <span class="o">&amp;&amp;</span> <span class="nx">maze</span><span class="p">[</span><span class="nx">ny</span><span class="p">][</span><span class="nx">nx</span><span class="p">]</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">neighbors</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">nx</span><span class="p">,</span> <span class="nx">ny</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">neighbors</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">async</span> <span class="kd">function</span> <span class="nf">startPrim</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">initMaze</span><span class="p">();</span>
    <span class="k">await</span> <span class="nf">generatePrim</span><span class="p">();</span>
    <span class="c1">// 입구 표시</span>
    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">entrance</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">entrance</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="dl">'</span><span class="s1">lime</span><span class="dl">'</span><span class="p">);</span>

    <span class="c1">// 가장 먼 곳이 출구</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">ex</span><span class="p">,</span> <span class="nx">ey</span><span class="p">]</span> <span class="o">=</span> <span class="nf">findFurthestCell</span><span class="p">(</span><span class="nx">entrance</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">entrance</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="nx">exit</span> <span class="o">=</span> <span class="p">[</span><span class="nx">ex</span><span class="p">,</span> <span class="nx">ey</span><span class="p">];</span>
    <span class="c1">// 출구 표시</span>
    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">exit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">exit</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="dl">'</span><span class="s1">blue</span><span class="dl">'</span><span class="p">);</span>

    <span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nf">findPathBFS</span><span class="p">(</span><span class="nx">entrance</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">entrance</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">exit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">exit</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">await</span> <span class="nf">drawPathAnimated</span><span class="p">(</span><span class="nx">path</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="2-kruskals-알고리즘">2. Kruskal’s 알고리즘</h5>

<p>Kruskal 미로는 벽에 갇힌 통로를 생성해두고 무작위로 벽을 뚫어 통로를 연결하는 방식이다.<br />
복잡도로 따지면 Prim 보다는 복잡하고 DFS보다는 덜 복잡한 느낌이다.</p>

<p>Prim도 벽을 뚫고 Kruskal도 벽을 뚫는데 차이가 있다면<br />
Prim은 현재 통로와 인접한 벽만 뚫어서 확장해 나가는 것이고<br />
Kruskal은 <span style="color: oragne;"><strong>미로 전체 벽에서 무작위로 통로가 합쳐지도록 뚫는 것</strong></span>이다.<br />
그러니 Prim보다 더 복잡해 보일 수 밖에.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Kruskal's 알고리즘</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">generateKruskal</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">sets</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Map</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">walls</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="c1">// 짝수 좌표만 통로로 초기화, 집합 생성</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;=</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;=</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
            <span class="nx">sets</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">x</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">y</span><span class="p">}</span><span class="s2">`</span><span class="p">,</span> <span class="s2">`</span><span class="p">${</span><span class="nx">x</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">y</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 통로 사이의 벽만 벽 리스트에 추가</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;=</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;=</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if </span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 수평 벽</span>
                <span class="nx">walls</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">y</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="k">if </span><span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 수직 벽</span>
                <span class="nx">walls</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 벽을 무작위로 섞기</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">walls</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">j</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
        <span class="p">[</span><span class="nx">walls</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">walls</span><span class="p">[</span><span class="nx">j</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">walls</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">walls</span><span class="p">[</span><span class="nx">i</span><span class="p">]];</span>
    <span class="p">}</span>

    <span class="c1">// 하나씩 꺼내서 뚫기</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">wx</span><span class="p">,</span> <span class="nx">wy</span><span class="p">,</span> <span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">]</span> <span class="k">of</span> <span class="nx">walls</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">set1</span> <span class="o">=</span> <span class="nf">findSet</span><span class="p">(</span><span class="nx">sets</span><span class="p">,</span> <span class="s2">`</span><span class="p">${</span><span class="nx">x1</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">y1</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">set2</span> <span class="o">=</span> <span class="nf">findSet</span><span class="p">(</span><span class="nx">sets</span><span class="p">,</span> <span class="s2">`</span><span class="p">${</span><span class="nx">x2</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">y2</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>

        <span class="k">if </span><span class="p">(</span><span class="nx">set1</span> <span class="o">!==</span> <span class="nx">set2</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">maze</span><span class="p">[</span><span class="nx">wy</span><span class="p">][</span><span class="nx">wx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="nf">drawCell</span><span class="p">(</span><span class="nx">wx</span><span class="p">,</span> <span class="nx">wy</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
            <span class="nf">union</span><span class="p">(</span><span class="nx">sets</span><span class="p">,</span> <span class="nx">set1</span><span class="p">,</span> <span class="nx">set2</span><span class="p">);</span>
            <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 경로 압축을 위한 집합 찾기</span>
<span class="kd">function</span> <span class="nf">findSet</span><span class="p">(</span><span class="nx">sets</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">sets</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="o">!==</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">sets</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nf">findSet</span><span class="p">(</span><span class="nx">sets</span><span class="p">,</span> <span class="nx">sets</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">key</span><span class="p">)));</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">sets</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 집합 합치기</span>
<span class="kd">function</span> <span class="nf">union</span><span class="p">(</span><span class="nx">sets</span><span class="p">,</span> <span class="nx">set1</span><span class="p">,</span> <span class="nx">set2</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sets</span><span class="p">.</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">v</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">v</span> <span class="o">===</span> <span class="nx">set2</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">sets</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">set1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="k">async</span> <span class="kd">function</span> <span class="nf">startKruskal</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">initMaze</span><span class="p">();</span>
    <span class="k">await</span> <span class="nf">generateKruskal</span><span class="p">();</span>
    
    <span class="c1">// 입구 표시</span>
    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">entrance</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">entrance</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="dl">'</span><span class="s1">lime</span><span class="dl">'</span><span class="p">);</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">ex</span><span class="p">,</span> <span class="nx">ey</span><span class="p">]</span> <span class="o">=</span> <span class="nf">findFurthestCell</span><span class="p">(</span><span class="nx">entrance</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">entrance</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="nx">exit</span> <span class="o">=</span> <span class="p">[</span><span class="nx">ex</span><span class="p">,</span> <span class="nx">ey</span><span class="p">];</span>
    <span class="c1">// 출구 표시</span>
    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">exit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">exit</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="dl">'</span><span class="s1">blue</span><span class="dl">'</span><span class="p">);</span>
    
    <span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nf">findPathBFS</span><span class="p">(</span><span class="nx">entrance</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">entrance</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">exit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">exit</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">await</span> <span class="nf">drawPathAnimated</span><span class="p">(</span><span class="nx">path</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="완성">완성</h4>
  <hr />
</blockquote>

<p>Prim’s 알고리즘 미로</p>

<p><img src="/assets/images/posts/one-pan/JavaScript/2025-05-22-Maze Generator 02/img01.gif" alt="img01" /></p>

<p>Kruskal’s 알고리즘 미로</p>

<p><img src="/assets/images/posts/one-pan/JavaScript/2025-05-22-Maze Generator 02/img02.gif" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>미로 그려지는게 예쁘다.<br />
가만히 보고 있으면 기분이 좋아진다.</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="/play/Maze%20Generator.html" target="_blank" rel="noopener noreferrer">
  직접 해보기
</a></p>

<p>Prim’s<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-22-Prim.js">Link to GitHub</a></p>

<p>Kruskal’s<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-22-Kruskal.js">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="one-pan/JavaScript/" /><summary type="html"><![CDATA[개요 Prim’s 알고리즘과 Kruskal’s 알고리즘의 미로를 추가하기 구현 시작 전에 공통으로 사용할 함수를 index로 몰아준다. 1. Prim’s 알고리즘 DFS와 Prim의 미로는 겉으로는 제법 유사해보이는데 Prim은 탈출 경로가 훨씬 단순해진다. DFS는 한 방향으로 쭈욱 파다가 막히면 돌아가서 새로운 길을 찾는데, Prim은 미로의 경계에서 새로운 길을 만들기 때문이다. 느낌으로 비교하자면 DFS는 ‘길을 파는 것’이고 Prim은 ‘벽을 뚫는 것’이다. 벽을 뚫는 것이기 때문에 인접한 벽(여기서는 프론티어)을 모아두고 랜덤으로 선택해서 뚫어나간다. DFS와 마찬가지로 js를 작성하고 기존 html에 스크립트를 추가한다. // Prim's 알고리즘 async function generatePrim() { // 시작점 (0,0) const startX = 0; const startY = 0; maze[startY][startX] = 0; drawCell(startX, startY, 'white'); // 프론티어 셀 const frontiers = []; const frontierSet = new Set(); addFrontiers(startX, startY, frontiers, frontierSet); while (frontiers.length &gt; 0) { // 무작위 프론티어 선택 const randomIndex = Math.floor(Math.random() * frontiers.length); const [x, y] = frontiers.splice(randomIndex, 1)[0]; frontierSet.delete(`${x},${y}`); // 인접한 통로 찾기 (경계 포함) const neighbors = getNeighbors(x, y); if (neighbors.length === 0) { // 인접 통로 없으면 무시 continue; } // 무작위 인접 통로 선택 const [nx, ny] = neighbors[Math.floor(Math.random() * neighbors.length)]; // 벽 뚫기 const wallX = (x + nx) / 2; const wallY = (y + ny) / 2; maze[y][x] = 0; maze[wallY][wallX] = 0; drawCell(x, y, 'white'); drawCell(wallX, wallY, 'white'); // 새로운 프론티어 추가 addFrontiers(x, y, frontiers, frontierSet); await sleep(5); } } // 프론티어 셀 추가 (중복 방지, 경계 포함) function addFrontiers(x, y, frontiers, frontierSet) { const dirs = [[0, -2], [2, 0], [0, 2], [-2, 0]]; for (let [dx, dy] of dirs) { const nx = x + dx; const ny = y + dy; const key = `${nx},${ny}`; if (nx &gt;= 0 &amp;&amp; nx &lt; cols &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; rows &amp;&amp; maze[ny][nx] === 1 &amp;&amp; !frontierSet.has(key)) { frontiers.push([nx, ny]); frontierSet.add(key); } } } // 인접한 통로 찾기 (경계 포함) function getNeighbors(x, y) { const neighbors = []; const dirs = [[0, -2], [2, 0], [0, 2], [-2, 0]]; for (let [dx, dy] of dirs) { const nx = x + dx; const ny = y + dy; if (nx &gt;= 0 &amp;&amp; nx &lt; cols &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; rows &amp;&amp; maze[ny][nx] === 0) { neighbors.push([nx, ny]); } } return neighbors; } async function startPrim() { initMaze(); await generatePrim(); // 입구 표시 drawCell(entrance[0], entrance[1], 'lime'); // 가장 먼 곳이 출구 const [ex, ey] = findFurthestCell(entrance[0], entrance[1]); exit = [ex, ey]; // 출구 표시 drawCell(exit[0], exit[1], 'blue'); const path = findPathBFS(entrance[0], entrance[1], exit[0], exit[1]); await drawPathAnimated(path); } 2. Kruskal’s 알고리즘 Kruskal 미로는 벽에 갇힌 통로를 생성해두고 무작위로 벽을 뚫어 통로를 연결하는 방식이다. 복잡도로 따지면 Prim 보다는 복잡하고 DFS보다는 덜 복잡한 느낌이다. Prim도 벽을 뚫고 Kruskal도 벽을 뚫는데 차이가 있다면 Prim은 현재 통로와 인접한 벽만 뚫어서 확장해 나가는 것이고 Kruskal은 미로 전체 벽에서 무작위로 통로가 합쳐지도록 뚫는 것이다. 그러니 Prim보다 더 복잡해 보일 수 밖에. // Kruskal's 알고리즘 async function generateKruskal() { const sets = new Map(); const walls = []; // 짝수 좌표만 통로로 초기화, 집합 생성 for (let y = 0; y &lt;= rows; y += 2) { for (let x = 0; x &lt;= cols; x += 2) { maze[y][x] = 0; drawCell(x, y, 'white'); sets.set(`${x},${y}`, `${x},${y}`); } } // 통로 사이의 벽만 벽 리스트에 추가 for (let y = 0; y &lt;= rows; y += 2) { for (let x = 0; x &lt;= cols; x += 2) { if (x + 2 &lt; cols) { // 수평 벽 walls.push([x + 1, y, x, y, x + 2, y]); } if (y + 2 &lt; rows) { // 수직 벽 walls.push([x, y + 1, x, y, x, y + 2]); } } } // 벽을 무작위로 섞기 for (let i = walls.length - 1; i &gt; 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [walls[i], walls[j]] = [walls[j], walls[i]]; } // 하나씩 꺼내서 뚫기 for (let [wx, wy, x1, y1, x2, y2] of walls) { const set1 = findSet(sets, `${x1},${y1}`); const set2 = findSet(sets, `${x2},${y2}`); if (set1 !== set2) { maze[wy][wx] = 0; drawCell(wx, wy, 'white'); union(sets, set1, set2); await sleep(5); } } } // 경로 압축을 위한 집합 찾기 function findSet(sets, key) { if (sets.get(key) !== key) { sets.set(key, findSet(sets, sets.get(key))); } return sets.get(key); } // 집합 합치기 function union(sets, set1, set2) { sets.forEach((v, k) =&gt; { if (v === set2) { sets.set(k, set1); } }); } async function startKruskal() { initMaze(); await generateKruskal(); // 입구 표시 drawCell(entrance[0], entrance[1], 'lime'); const [ex, ey] = findFurthestCell(entrance[0], entrance[1]); exit = [ex, ey]; // 출구 표시 drawCell(exit[0], exit[1], 'blue'); const path = findPathBFS(entrance[0], entrance[1], exit[0], exit[1]); await drawPathAnimated(path); } 완성 Prim’s 알고리즘 미로 Kruskal’s 알고리즘 미로 반성 미로 그려지는게 예쁘다. 가만히 보고 있으면 기분이 좋아진다. 코드 확인 직접 해보기 Prim’s Link to GitHub Kruskal’s Link to GitHub]]></summary></entry><entry><title type="html">26226번 Autocomplete</title><link href="https://movingwoo.com/random-solve/c++/2025/05/21/26226.html" rel="alternate" type="text/html" title="26226번 Autocomplete" /><published>2025-05-21T06:00:00+00:00</published><updated>2025-05-21T06:00:00+00:00</updated><id>https://movingwoo.com/random-solve/c++/2025/05/21/26226</id><content type="html" xml:base="https://movingwoo.com/random-solve/c++/2025/05/21/26226.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/C++/2025-05-21-26226/img01.jpg" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/26226">26226번 Autocomplete - 백준</a></p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>앗 영어 문제</p>

<p>단어를 비교하는 문제이다.<br />
두 단어가 “비슷하다”고 말하는 조건은 다음과 같다.</p>
<ul>
  <li>대소문자 구분 없이 비교했을 때 완전히 같음</li>
  <li>대소문자를 구분하면 서로 다른 문자의 위치가 K개 이하</li>
</ul>

<p>단어의 길이 최대 2000, 단어 사전 1000개, 질의 1000개다.<br />
생각보다 숫자가 좀 크다?</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-시간-초과의-역사">1. 시간 초과의 역사</h5>

<p><span style="color: orange;"><strong>2000 * 1000 * 1000 = 2000000000</strong></span><br />
<span style="color: red;"><strong>이런 미친 숫자가!</strong></span></p>

<p>문제의 제한시간은 1초다.<br />
탐색범위를 최대한 줄여야한다.<br />
K는 최대 5기 때문에 빠른 탈출 트리거로 사용할 수 있는데<br />
나머지 숫자는 커서 잘 생각해야한다.</p>

<p>아래는 시간 초과난 경우</p>
<ol>
  <li>문자열 전체 비교하면 터져서 소문자 변환 후 별도 저장했지만 터짐</li>
  <li>마스킹 처리 후 비트기반 xor 연산했지만 터짐</li>
  <li>K가 작기 때문에 가능한 모든 마스크 조합을 만들어봤지만 터짐</li>
  <li>bitset 구조로 바꿨는데 터짐</li>
  <li>다 때려치우고 소문자 정렬 후 이진탐색했는데 터짐</li>
</ol>

<p>결국 초심으로 돌아가 단순하게 후보군 필터링 후 해시 기반 탐색하니 통과되었다.</p>

<h5 id="2-입력-받아-필터링-후-탐색">2. 입력 받아 필터링 후 탐색</h5>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
    <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">K</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">Q</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">K</span> <span class="o">&gt;&gt;</span> <span class="n">W</span><span class="p">;</span>

    <span class="c1">// 소문자 + 길이 기준</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;&gt;</span> <span class="n">words</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">W</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">word</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">word</span><span class="p">;</span>

        <span class="n">string</span> <span class="n">lower</span> <span class="o">=</span> <span class="n">toLower</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">word</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

        <span class="n">words</span><span class="p">[</span><span class="n">lower</span><span class="p">][</span><span class="n">length</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">Q</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Q</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">query</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">query</span><span class="p">;</span>

        <span class="n">string</span> <span class="n">lowerQuery</span> <span class="o">=</span> <span class="n">toLower</span><span class="p">(</span><span class="n">query</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">query</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="c1">// 소문자 + 길이 일치하는 단어만 대상으로 필터링</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">lowerQuery</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">words</span><span class="p">[</span><span class="n">lowerQuery</span><span class="p">].</span><span class="n">count</span><span class="p">(</span><span class="n">length</span><span class="p">))</span> <span class="p">{</span>

            <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="n">lowerQuery</span><span class="p">][</span><span class="n">length</span><span class="p">];</span>

            <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">target</span> <span class="o">:</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">caseDifference</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;=</span> <span class="n">K</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">result</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/C++/2025-05-21-26226/img02.jpg" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>괜시리 머리 굴려서 살 붙이며 비대해지는 것 보다 가끔은 초심으로 돌아갈 필요가 있다.</p>

<p>그건 그렇고 왜 쉬운 문제는 안나오지?<br />
처음에 조건보고 할만한데? 하고 덤볐다가 피봤다.</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/random-solve/C%2B%2B/2025-05-21-26226.cpp">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="random-solve/C++/" /><summary type="html"><![CDATA[문제 26226번 Autocomplete - 백준 설계 앗 영어 문제 단어를 비교하는 문제이다. 두 단어가 “비슷하다”고 말하는 조건은 다음과 같다. 대소문자 구분 없이 비교했을 때 완전히 같음 대소문자를 구분하면 서로 다른 문자의 위치가 K개 이하 단어의 길이 최대 2000, 단어 사전 1000개, 질의 1000개다. 생각보다 숫자가 좀 크다? 구현 1. 시간 초과의 역사 2000 * 1000 * 1000 = 2000000000 이런 미친 숫자가! 문제의 제한시간은 1초다. 탐색범위를 최대한 줄여야한다. K는 최대 5기 때문에 빠른 탈출 트리거로 사용할 수 있는데 나머지 숫자는 커서 잘 생각해야한다. 아래는 시간 초과난 경우 문자열 전체 비교하면 터져서 소문자 변환 후 별도 저장했지만 터짐 마스킹 처리 후 비트기반 xor 연산했지만 터짐 K가 작기 때문에 가능한 모든 마스크 조합을 만들어봤지만 터짐 bitset 구조로 바꿨는데 터짐 다 때려치우고 소문자 정렬 후 이진탐색했는데 터짐 결국 초심으로 돌아가 단순하게 후보군 필터링 후 해시 기반 탐색하니 통과되었다. 2. 입력 받아 필터링 후 탐색 int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int K, W, Q; cin &gt;&gt; K &gt;&gt; W; // 소문자 + 길이 기준 unordered_map&lt;string, unordered_map&lt;int, vector&lt;string&gt;&gt;&gt; words; for (int i = 0; i &lt; W; ++i) { string word; cin &gt;&gt; word; string lower = toLower(word); int length = word.size(); words[lower][length].push_back(word); } cin &gt;&gt; Q; for (int i = 0; i &lt; Q; ++i) { string query; cin &gt;&gt; query; string lowerQuery = toLower(query); int length = query.size(); int result = 0; // 소문자 + 길이 일치하는 단어만 대상으로 필터링 if (words.count(lowerQuery) &amp;&amp; words[lowerQuery].count(length)) { const vector&lt;string&gt;&amp; list = words[lowerQuery][length]; for (const string&amp; target : list) { int cnt = caseDifference(query, target, K); if (cnt &lt;= K) { result++; } } } cout &lt;&lt; result &lt;&lt; '\n'; } return 0; } 채점 반성 괜시리 머리 굴려서 살 붙이며 비대해지는 것 보다 가끔은 초심으로 돌아갈 필요가 있다. 그건 그렇고 왜 쉬운 문제는 안나오지? 처음에 조건보고 할만한데? 하고 덤볐다가 피봤다. 코드 확인 Link to GitHub]]></summary></entry><entry><title type="html">미로 생성기 01</title><link href="https://movingwoo.com/one-pan/javascript/2025/05/20/Maze-Generator-01.html" rel="alternate" type="text/html" title="미로 생성기 01" /><published>2025-05-20T23:00:00+00:00</published><updated>2025-05-20T23:00:00+00:00</updated><id>https://movingwoo.com/one-pan/javascript/2025/05/20/Maze%20Generator%2001</id><content type="html" xml:base="https://movingwoo.com/one-pan/javascript/2025/05/20/Maze-Generator-01.html"><![CDATA[<blockquote>
  <h4 id="개요">개요</h4>
  <hr />
</blockquote>

<p>이전에 DFS 공부한걸 찾아서 미로 만드는데 써봄.<br />
캔버스로 미로를 자동으로 그리고 추가로 미로를 만들 수 있는 다른 알고리즘도 써보기로 함.</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-설계">1. 설계</h5>

<p>미로 생성할 수 있는 대표 알고리즘 7종에 대하여 찾아보았다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">알고리즘</th>
      <th style="text-align: left">스타일</th>
      <th style="text-align: left">특징</th>
      <th style="text-align: left">용도</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">DFS</td>
      <td style="text-align: left">꼬불꼬불한 한 줄기 통로, 가지치기 많음</td>
      <td style="text-align: left">재귀 기반, 한 방향으로 깊게 파고들며 되돌아오며 생성</td>
      <td style="text-align: left">일반적인 퍼즐형 미로</td>
    </tr>
    <tr>
      <td style="text-align: left">Prim’s</td>
      <td style="text-align: left">불규칙한 가지 형태, 길이 자연스럽게 분산</td>
      <td style="text-align: left">Queue 또는 set을 이용, 인접 벽 중 하나씩 랜덤 제거</td>
      <td style="text-align: left">일반적인 퍼즐형 미로</td>
    </tr>
    <tr>
      <td style="text-align: left">Kruskal’s</td>
      <td style="text-align: left">큰 방, 높은 통로 복잡도</td>
      <td style="text-align: left">Union find 기반, 모든 칸을 연결하되 사이클 제거</td>
      <td style="text-align: left">랜덤하고 복잡한 퍼즐 미로</td>
    </tr>
    <tr>
      <td style="text-align: left">Binary Tree</td>
      <td style="text-align: left">매우 단순하며 위 또는 오른쪽만 뚫음</td>
      <td style="text-align: left">단순하기에 성능이 좋지만 구조가 예측 가능</td>
      <td style="text-align: left">빠른 생성, 규칙적 패턴</td>
    </tr>
    <tr>
      <td style="text-align: left">Sidewinder</td>
      <td style="text-align: left">줄 단위, 수평 위주 통로</td>
      <td style="text-align: left">행 단위로 생성, 각 줄마다 위로 하나 연결하며 수평으로 길어짐</td>
      <td style="text-align: left">빠른 렌더링, 제한된 방향성</td>
    </tr>
    <tr>
      <td style="text-align: left">Recursive Division</td>
      <td style="text-align: left">벽 많은 구조, 사각형 영역</td>
      <td style="text-align: left">전체를 벽으로 채우고 구멍을 뚫어 나눔, 방처럼 보이는 구조</td>
      <td style="text-align: left">방 구성, 던전 형태</td>
    </tr>
    <tr>
      <td style="text-align: left">Eller’s</td>
      <td style="text-align: left">일정한 패턴, 세로로 잘 연결됨</td>
      <td style="text-align: left">행 단위로 생성하며 집합 유지, 메모리 효율적</td>
      <td style="text-align: left">모바일, 웹에서 실시간 생성</td>
    </tr>
  </tbody>
</table>

<p>목표는 7종 알고리즘을 전부 시뮬레이션해보는 것인데 우선은 DFS만 시뮬레이션 해본다.<br />
한 html 파일에 몰아넣으면 보기 힘들어지므로, html 파일에는 뼈대와 공통함수만 몰아두고 DFS는 js로 별도 생성한다.<br />
이후 알고리즘 추가 시 js만 추가해서 바로 사용할 수 있도록 한다.</p>

<h5 id="2-뼈대-작성">2. 뼈대 작성</h5>

<p>Generate 버튼 클릭 시 미로를 생성하는 과정을 애니메이션으로 보여준다.<br />
그리고 입구부터 출구까지의 경로를 빨간색으로 표시한다.<br />
그러기 위한 공통변수와 함수를 이곳에 작성.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"ko"</span><span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;</span>
  <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"UTF-8"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;title&gt;</span>Maze Generator<span class="nt">&lt;/title&gt;</span>
  <span class="nt">&lt;style&gt;</span>
    <span class="nt">body</span> <span class="p">{</span>
      <span class="nl">font-family</span><span class="p">:</span> <span class="nb">sans-serif</span><span class="p">;</span>
      <span class="nl">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">;</span>
      <span class="nl">flex-direction</span><span class="p">:</span> <span class="n">column</span><span class="p">;</span>
      <span class="nl">align-items</span><span class="p">:</span> <span class="nb">center</span><span class="p">;</span>
      <span class="nl">background</span><span class="p">:</span> <span class="m">#f2f2f2</span><span class="p">;</span>
      <span class="nl">margin</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
      <span class="nl">padding</span><span class="p">:</span> <span class="m">20px</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nt">button</span> <span class="p">{</span>
      <span class="nl">padding</span><span class="p">:</span> <span class="m">8px</span> <span class="m">16px</span><span class="p">;</span>
      <span class="nl">margin-bottom</span><span class="p">:</span> <span class="m">10px</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nf">#canvas</span> <span class="p">{</span>
      <span class="nl">border</span><span class="p">:</span> <span class="m">2px</span> <span class="nb">solid</span> <span class="m">#333</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="nt">&lt;/style&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>

  <span class="c">&lt;!-- DFS 기반 미로 버튼 --&gt;</span>
  <span class="nt">&lt;button</span> <span class="na">onclick=</span><span class="s">"startDFS()"</span><span class="nt">&gt;</span>DFS Generate<span class="nt">&lt;/button&gt;</span>
  <span class="c">&lt;!-- 이후 버튼 추가 --&gt;</span>

  <span class="c">&lt;!-- 미로 캔버스 --&gt;</span>
  <span class="nt">&lt;canvas</span> <span class="na">id=</span><span class="s">"canvas"</span> <span class="na">width=</span><span class="s">"1020"</span> <span class="na">height=</span><span class="s">"620"</span><span class="nt">&gt;&lt;/canvas&gt;</span>

  <span class="nt">&lt;script&gt;</span>
    <span class="c1">// 공통 변수와 함수</span>
    <span class="kd">const</span> <span class="nx">canvas</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">#canvas</span><span class="dl">'</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nf">getContext</span><span class="p">(</span><span class="dl">'</span><span class="s1">2d</span><span class="dl">'</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">size</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">cols</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span> <span class="o">/</span> <span class="nx">size</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">rows</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span> <span class="o">/</span> <span class="nx">size</span><span class="p">;</span>

    <span class="c1">// 미로 상태</span>
    <span class="kd">let</span> <span class="nx">maze</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">let</span> <span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">();</span> <span class="c1">// 방문한 셀 저장용</span>
    <span class="kd">let</span> <span class="nx">entrance</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">];</span> <span class="c1">// 입구</span>
    <span class="kd">let</span> <span class="nx">exit</span> <span class="o">=</span> <span class="p">[</span><span class="nx">cols</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">rows</span> <span class="o">-</span> <span class="mi">2</span><span class="p">];</span> <span class="c1">// 출구(정의만 해두고 실제 출구는 나중에)</span>

    <span class="c1">// 시간 지연 함수 (애니메이션용)</span>
    <span class="kd">function</span> <span class="nf">sleep</span><span class="p">(</span><span class="nx">ms</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="o">=&gt;</span> <span class="nf">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">ms</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="c1">// 셀 색칠</span>
    <span class="kd">function</span> <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">color</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">ctx</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="nx">color</span><span class="p">;</span>
      <span class="nx">ctx</span><span class="p">.</span><span class="nf">fillRect</span><span class="p">(</span><span class="nx">x</span> <span class="o">*</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">y</span> <span class="o">*</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">size</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 미로 초기화</span>
    <span class="kd">function</span> <span class="nf">initMaze</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">maze</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">({</span> <span class="na">length</span><span class="p">:</span> <span class="nx">rows</span> <span class="p">},</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nc">Array</span><span class="p">(</span><span class="nx">cols</span><span class="p">).</span><span class="nf">fill</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span> <span class="c1">// 전부 벽</span>
      <span class="nx">visited</span><span class="p">.</span><span class="nf">clear</span><span class="p">();</span>
      <span class="nx">ctx</span><span class="p">.</span><span class="nf">clearRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="p">);</span>

      <span class="c1">// 캔버스 전체를 벽으로 색칠</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">initMaze</span><span class="p">();</span>
  <span class="nt">&lt;/script&gt;</span>

  <span class="c">&lt;!-- DFS 미로 스크립트 --&gt;</span>
  <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"./js/DFS.js"</span><span class="nt">&gt;&lt;/script&gt;</span>

<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<h5 id="3-dfs-스크립트-작성">3. DFS 스크립트 작성</h5>

<p>DFS 미로 생성하고 길 찾는 부분은 BFS로 구현.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 배열 섞기</span>
<span class="kd">function</span> <span class="nf">shuffle</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">j</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]];</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
<span class="p">}</span>
  
<span class="c1">// 미로 생성(DFS)</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">generateDFS</span><span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">entrance</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">entrance</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">x</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">y</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
  <span class="nx">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
  <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 흰색 길</span>

  <span class="c1">// 이동 방향 무작위</span>
  <span class="kd">const</span> <span class="nx">dirs</span> <span class="o">=</span> <span class="nf">shuffle</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]);</span>

  <span class="c1">// forEach 사용시 동기화 문제있어서 for of 사용</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">]</span> <span class="k">of</span> <span class="nx">dirs</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">nx</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">ny</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">betweenX</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">betweenY</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">neighborKey</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">nx</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">ny</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>

    <span class="c1">// 방문하지 않은 셀을 통로로 만들기</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">nx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nx</span> <span class="o">&lt;</span> <span class="nx">cols</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&lt;</span> <span class="nx">rows</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">visited</span><span class="p">.</span><span class="nf">has</span><span class="p">(</span><span class="nx">neighborKey</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">maze</span><span class="p">[</span><span class="nx">ny</span><span class="p">][</span><span class="nx">nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 다음 셀도 통로</span>
      <span class="nx">maze</span><span class="p">[</span><span class="nx">betweenY</span><span class="p">][</span><span class="nx">betweenX</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 중간 벽 없애기</span>
      <span class="nf">drawCell</span><span class="p">(</span><span class="nx">betweenX</span><span class="p">,</span> <span class="nx">betweenY</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>

      <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
      <span class="k">await</span> <span class="nf">generateDFS</span><span class="p">(</span><span class="nx">nx</span><span class="p">,</span> <span class="nx">ny</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
  
<span class="c1">// 가장 멀리 떨어진 셀을 출구로 지정(BFS)</span>
<span class="kd">function</span> <span class="nf">findFurthestCell</span><span class="p">(</span><span class="nx">sx</span><span class="p">,</span> <span class="nx">sy</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">que</span> <span class="o">=</span> <span class="p">[[</span><span class="nx">sx</span><span class="p">,</span> <span class="nx">sy</span><span class="p">,</span> <span class="mi">0</span><span class="p">]];</span>
  <span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">();</span>
  <span class="kd">let</span> <span class="nx">maxDist</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">furthest</span> <span class="o">=</span> <span class="p">[</span><span class="nx">sx</span><span class="p">,</span> <span class="nx">sy</span><span class="p">];</span>

  <span class="k">while </span><span class="p">(</span><span class="nx">que</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">dist</span><span class="p">]</span> <span class="o">=</span> <span class="nx">que</span><span class="p">.</span><span class="nf">shift</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">x</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">y</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>

    <span class="k">if </span><span class="p">(</span><span class="nx">visited</span><span class="p">.</span><span class="nf">has</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>

    <span class="k">if </span><span class="p">(</span><span class="nx">dist</span> <span class="o">&gt;</span> <span class="nx">maxDist</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">maxDist</span> <span class="o">=</span> <span class="nx">dist</span><span class="p">;</span>
      <span class="nx">furthest</span> <span class="o">=</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">]</span> <span class="k">of</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">nx</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">,</span> <span class="nx">ny</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">;</span>
      <span class="k">if </span><span class="p">(</span><span class="nx">nx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nx</span> <span class="o">&lt;</span> <span class="nx">cols</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&lt;</span> <span class="nx">rows</span> <span class="o">&amp;&amp;</span> <span class="nx">maze</span><span class="p">[</span><span class="nx">ny</span><span class="p">][</span><span class="nx">nx</span><span class="p">]</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">que</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">nx</span><span class="p">,</span> <span class="nx">ny</span><span class="p">,</span> <span class="nx">dist</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">furthest</span><span class="p">;</span>
<span class="p">}</span>
  
  <span class="c1">// 탈출 경로 찾기(BFS)</span>
<span class="kd">function</span> <span class="nf">findPathBFS</span><span class="p">(</span><span class="nx">sx</span><span class="p">,</span> <span class="nx">sy</span><span class="p">,</span> <span class="nx">ex</span><span class="p">,</span> <span class="nx">ey</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">que</span> <span class="o">=</span> <span class="p">[[</span><span class="nx">sx</span><span class="p">,</span> <span class="nx">sy</span><span class="p">]];</span>
  <span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">();</span>
  <span class="kd">const</span> <span class="nx">parent</span> <span class="o">=</span> <span class="p">{};</span>

  <span class="k">while </span><span class="p">(</span><span class="nx">que</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">]</span> <span class="o">=</span> <span class="nx">que</span><span class="p">.</span><span class="nf">shift</span><span class="p">();</span>

    <span class="k">if </span><span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="nx">ex</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="o">===</span> <span class="nx">ey</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">x</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">y</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>

    <span class="nx">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>

    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">]</span> <span class="k">of</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">nx</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">,</span> <span class="nx">ny</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">;</span>
      <span class="kd">const</span> <span class="nx">nextKey</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">nx</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">ny</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>

      <span class="c1">// 벽이 아니고 방문하지 않은 길</span>
      <span class="k">if </span><span class="p">(</span><span class="nx">nx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nx</span> <span class="o">&lt;</span> <span class="nx">cols</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&lt;</span> <span class="nx">rows</span> <span class="o">&amp;&amp;</span> <span class="nx">maze</span><span class="p">[</span><span class="nx">ny</span><span class="p">][</span><span class="nx">nx</span><span class="p">]</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">visited</span><span class="p">.</span><span class="nf">has</span><span class="p">(</span><span class="nx">nextKey</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">que</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">nx</span><span class="p">,</span> <span class="nx">ny</span><span class="p">]);</span>
        <span class="nx">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">nextKey</span><span class="p">);</span>
        <span class="nx">parent</span><span class="p">[</span><span class="nx">nextKey</span><span class="p">]</span> <span class="o">=</span> <span class="nx">key</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 출구에서 역으로 경로 추적</span>
  <span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">let</span> <span class="nx">curr</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">ex</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">ey</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>

  <span class="k">while </span><span class="p">(</span><span class="nx">curr</span> <span class="o">!==</span> <span class="s2">`</span><span class="p">${</span><span class="nx">sx</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">sy</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">]</span> <span class="o">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">,</span><span class="dl">'</span><span class="p">).</span><span class="nf">map</span><span class="p">(</span><span class="nb">Number</span><span class="p">);</span>
    <span class="nx">path</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">]);</span>
    <span class="nx">curr</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">[</span><span class="nx">curr</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="nx">path</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">sx</span><span class="p">,</span> <span class="nx">sy</span><span class="p">]);</span>

  <span class="k">return</span> <span class="nx">path</span><span class="p">.</span><span class="nf">reverse</span><span class="p">();</span>
<span class="p">}</span>
  
<span class="c1">// 미로 탈출 경로 그리기</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">drawPathAnimated</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">]</span> <span class="k">of</span> <span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">((</span><span class="nx">x</span> <span class="o">===</span> <span class="nx">entrance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="o">===</span> <span class="nx">entrance</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">||</span> <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="nx">exit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="o">===</span> <span class="nx">exit</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="p">{</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 빨강으로 색칠</span>
    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">red</span><span class="dl">'</span><span class="p">);</span>
    <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
  
<span class="c1">// 전체 실행 </span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">startDFS</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">initMaze</span><span class="p">();</span> 
  <span class="k">await</span> <span class="nf">generateDFS</span><span class="p">();</span>

  <span class="c1">// 입구 표시</span>
  <span class="nf">drawCell</span><span class="p">(</span><span class="nx">entrance</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">entrance</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="dl">'</span><span class="s1">lime</span><span class="dl">'</span><span class="p">);</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">ex</span><span class="p">,</span> <span class="nx">ey</span><span class="p">]</span> <span class="o">=</span> <span class="nf">findFurthestCell</span><span class="p">(</span><span class="nx">entrance</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">entrance</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
  <span class="nx">exit</span> <span class="o">=</span> <span class="p">[</span><span class="nx">ex</span><span class="p">,</span> <span class="nx">ey</span><span class="p">];</span>
  <span class="c1">// 출구 표시</span>
  <span class="nf">drawCell</span><span class="p">(</span><span class="nx">exit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">exit</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="dl">'</span><span class="s1">blue</span><span class="dl">'</span><span class="p">)</span>
  
  <span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nf">findPathBFS</span><span class="p">(</span><span class="nx">entrance</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">entrance</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">exit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">exit</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="k">await</span> <span class="nf">drawPathAnimated</span><span class="p">(</span><span class="nx">path</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="완성">완성</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/one-pan/JavaScript/2025-05-21-Maze Generator 01/img01.gif" alt="img01" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>async와 await에 대해 새롭게 배웠다.<br />
Promise 체인보다 코드가 엄청나게 깔끔해진다.<br />
좋아좋아 오늘도 하나 배웠어 일일신우일신</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="/play/Maze%20Generator.html" target="_blank" rel="noopener noreferrer">
  직접 해보기
</a></p>

<p>HTML<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-21-Maze%20Generator%2001.html">Link to GitHub</a></p>

<p>JavaScript<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-21-DFS.js">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="one-pan/JavaScript/" /><summary type="html"><![CDATA[개요 이전에 DFS 공부한걸 찾아서 미로 만드는데 써봄. 캔버스로 미로를 자동으로 그리고 추가로 미로를 만들 수 있는 다른 알고리즘도 써보기로 함. 구현 1. 설계 미로 생성할 수 있는 대표 알고리즘 7종에 대하여 찾아보았다. 알고리즘 스타일 특징 용도 DFS 꼬불꼬불한 한 줄기 통로, 가지치기 많음 재귀 기반, 한 방향으로 깊게 파고들며 되돌아오며 생성 일반적인 퍼즐형 미로 Prim’s 불규칙한 가지 형태, 길이 자연스럽게 분산 Queue 또는 set을 이용, 인접 벽 중 하나씩 랜덤 제거 일반적인 퍼즐형 미로 Kruskal’s 큰 방, 높은 통로 복잡도 Union find 기반, 모든 칸을 연결하되 사이클 제거 랜덤하고 복잡한 퍼즐 미로 Binary Tree 매우 단순하며 위 또는 오른쪽만 뚫음 단순하기에 성능이 좋지만 구조가 예측 가능 빠른 생성, 규칙적 패턴 Sidewinder 줄 단위, 수평 위주 통로 행 단위로 생성, 각 줄마다 위로 하나 연결하며 수평으로 길어짐 빠른 렌더링, 제한된 방향성 Recursive Division 벽 많은 구조, 사각형 영역 전체를 벽으로 채우고 구멍을 뚫어 나눔, 방처럼 보이는 구조 방 구성, 던전 형태 Eller’s 일정한 패턴, 세로로 잘 연결됨 행 단위로 생성하며 집합 유지, 메모리 효율적 모바일, 웹에서 실시간 생성 목표는 7종 알고리즘을 전부 시뮬레이션해보는 것인데 우선은 DFS만 시뮬레이션 해본다. 한 html 파일에 몰아넣으면 보기 힘들어지므로, html 파일에는 뼈대와 공통함수만 몰아두고 DFS는 js로 별도 생성한다. 이후 알고리즘 추가 시 js만 추가해서 바로 사용할 수 있도록 한다. 2. 뼈대 작성 Generate 버튼 클릭 시 미로를 생성하는 과정을 애니메이션으로 보여준다. 그리고 입구부터 출구까지의 경로를 빨간색으로 표시한다. 그러기 위한 공통변수와 함수를 이곳에 작성. &lt;!DOCTYPE html&gt; &lt;html lang="ko"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Maze Generator&lt;/title&gt; &lt;style&gt; body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background: #f2f2f2; margin: 0; padding: 20px; } button { padding: 8px 16px; margin-bottom: 10px; } #canvas { border: 2px solid #333; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- DFS 기반 미로 버튼 --&gt; &lt;button onclick="startDFS()"&gt;DFS Generate&lt;/button&gt; &lt;!-- 이후 버튼 추가 --&gt; &lt;!-- 미로 캔버스 --&gt; &lt;canvas id="canvas" width="1020" height="620"&gt;&lt;/canvas&gt; &lt;script&gt; // 공통 변수와 함수 const canvas = document.querySelector('#canvas'); const ctx = canvas.getContext('2d'); const size = 20; const cols = canvas.width / size; const rows = canvas.height / size; // 미로 상태 let maze = []; let visited = new Set(); // 방문한 셀 저장용 let entrance = [0, 0]; // 입구 let exit = [cols - 2, rows - 2]; // 출구(정의만 해두고 실제 출구는 나중에) // 시간 지연 함수 (애니메이션용) function sleep(ms) { return new Promise(resolve =&gt; setTimeout(resolve, ms)); } // 셀 색칠 function drawCell(x, y, color) { ctx.fillStyle = color; ctx.fillRect(x * size, y * size, size, size); } // 미로 초기화 function initMaze() { maze = Array.from({ length: rows }, () =&gt; Array(cols).fill(1)); // 전부 벽 visited.clear(); ctx.clearRect(0, 0, canvas.width, canvas.height); // 캔버스 전체를 벽으로 색칠 for (let y = 0; y &lt; rows; y++) { for (let x = 0; x &lt; cols; x++) { drawCell(x, y, 'black'); } } } initMaze(); &lt;/script&gt; &lt;!-- DFS 미로 스크립트 --&gt; &lt;script src="./js/DFS.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 3. DFS 스크립트 작성 DFS 미로 생성하고 길 찾는 부분은 BFS로 구현. // 배열 섞기 function shuffle(arr) { for (let i = arr.length - 1; i &gt; 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } return arr; } // 미로 생성(DFS) async function generateDFS(x = entrance[0], y = entrance[1]) { const key = `${x},${y}`; visited.add(key); maze[y][x] = 0; drawCell(x, y, 'white'); // 흰색 길 // 이동 방향 무작위 const dirs = shuffle([[0, -2], [2, 0], [0, 2], [-2, 0]]); // forEach 사용시 동기화 문제있어서 for of 사용 for (let [dx, dy] of dirs) { const nx = x + dx; const ny = y + dy; const betweenX = x + dx / 2; const betweenY = y + dy / 2; const neighborKey = `${nx},${ny}`; // 방문하지 않은 셀을 통로로 만들기 if (nx &gt;= 0 &amp;&amp; nx &lt; cols &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; rows &amp;&amp; !visited.has(neighborKey)) { maze[ny][nx] = 0; // 다음 셀도 통로 maze[betweenY][betweenX] = 0; // 중간 벽 없애기 drawCell(betweenX, betweenY, 'white'); await sleep(5); await generateDFS(nx, ny); } } } // 가장 멀리 떨어진 셀을 출구로 지정(BFS) function findFurthestCell(sx, sy) { const que = [[sx, sy, 0]]; const visited = new Set(); let maxDist = -1; let furthest = [sx, sy]; while (que.length) { const [x, y, dist] = que.shift(); const key = `${x},${y}`; if (visited.has(key)) { continue; } visited.add(key); if (dist &gt; maxDist) { maxDist = dist; furthest = [x, y]; } for (let [dx, dy] of [[0,1],[1,0],[0,-1],[-1,0]]) { const nx = x + dx, ny = y + dy; if (nx &gt;= 0 &amp;&amp; nx &lt; cols &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; rows &amp;&amp; maze[ny][nx] === 0) { que.push([nx, ny, dist + 1]); } } } return furthest; } // 탈출 경로 찾기(BFS) function findPathBFS(sx, sy, ex, ey) { const que = [[sx, sy]]; const visited = new Set(); const parent = {}; while (que.length) { const [x, y] = que.shift(); if (x === ex &amp;&amp; y === ey) { break; } const key = `${x},${y}`; visited.add(key); for (let [dx, dy] of [[0,1],[1,0],[0,-1],[-1,0]]) { const nx = x + dx, ny = y + dy; const nextKey = `${nx},${ny}`; // 벽이 아니고 방문하지 않은 길 if (nx &gt;= 0 &amp;&amp; nx &lt; cols &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; rows &amp;&amp; maze[ny][nx] === 0 &amp;&amp; !visited.has(nextKey)) { que.push([nx, ny]); visited.add(nextKey); parent[nextKey] = key; } } } // 출구에서 역으로 경로 추적 const path = []; let curr = `${ex},${ey}`; while (curr !== `${sx},${sy}`) { const [x, y] = curr.split(',').map(Number); path.push([x, y]); curr = parent[curr]; } path.push([sx, sy]); return path.reverse(); } // 미로 탈출 경로 그리기 async function drawPathAnimated(path) { for (let [x, y] of path) { if ((x === entrance[0] &amp;&amp; y === entrance[1]) || (x === exit[0] &amp;&amp; y === exit[1])) { continue; } // 빨강으로 색칠 drawCell(x, y, 'red'); await sleep(10); } } // 전체 실행 async function startDFS() { initMaze(); await generateDFS(); // 입구 표시 drawCell(entrance[0], entrance[1], 'lime'); const [ex, ey] = findFurthestCell(entrance[0], entrance[1]) exit = [ex, ey]; // 출구 표시 drawCell(exit[0], exit[1], 'blue') const path = findPathBFS(entrance[0], entrance[1], exit[0], exit[1]); await drawPathAnimated(path); } 완성 반성 async와 await에 대해 새롭게 배웠다. Promise 체인보다 코드가 엄청나게 깔끔해진다. 좋아좋아 오늘도 하나 배웠어 일일신우일신 코드 확인 직접 해보기 HTML Link to GitHub JavaScript Link to GitHub]]></summary></entry><entry><title type="html">15936번 Hypercube</title><link href="https://movingwoo.com/random-solve/java/2025/05/20/15936.html" rel="alternate" type="text/html" title="15936번 Hypercube" /><published>2025-05-20T00:00:00+00:00</published><updated>2025-05-20T00:00:00+00:00</updated><id>https://movingwoo.com/random-solve/java/2025/05/20/15936</id><content type="html" xml:base="https://movingwoo.com/random-solve/java/2025/05/20/15936.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Java/2025-05-20-15936/img01.jpg" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/15936">15936번 Hypercube - 백준</a></p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>앗 영어문제<br />
아니 진짜 뭔 이딴문제만 걸리냐?</p>

<p>시간제한이 0.2초인데 이거 자바로 되나 싶었는데 푼 사람 목록보니 파이썬도 있다.<br />
알고리즘 잘 짜면 자바도 되겠지 뭐…</p>

<p>입력으로 N, M, K를 준다.</p>
<ul>
  <li>N: N차원 하이퍼 큐브</li>
  <li>M: 노드 번호</li>
  <li>K: 경로 길이</li>
</ul>

<p>하이퍼 큐브가 머에여???<br />
<a href="https://namu.wiki/w/%EC%B4%88%EC%9E%85%EB%B0%A9%EC%B2%B4">초입방체 - 나무위키</a></p>

<p>2^N개의 노드를 가지며 x에서 y로 가려면 x &lt; y 이고 xor 연산 시 2^p가 되어야 한다.(비트가 하나 다르다.)<br />
라고 문제에서 말해줌.</p>

<p>문제가 요구하는 건 3가지인데<br />
a. M 번 노드로 향하는 간선이 시작하는 노드 번호의 최댓값<br />
b. M 번 노드에서 시작하는 간선이 향하는 노드 번호의 최소값<br />
c. 찾을 수 있는 K-길이의(K개의 간선을 포함하는) 경로의 개수. 100003 나머지 연산.</p>

<p>허허 이게 국어가 맞나</p>

<p>딱 봐도 하이퍼 큐브를 구현하면 제한 시간에 걸려 터진다.<br />
더 좋은 수학실력이 필요하다는 뜻임…</p>

<p>구글링으로 수학 고수들을 통해 문제 해결 공식을 얻은 다음 구현은 내가 하는 쪽으로 한다.<br />
나 혼자서는 풀 수 없음…</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-입력-받기">1. 입력 받기</h5>

<p>Scanner 사용하면 터질 것 같으니 버퍼로 입력 받는다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span><span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
        
        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">(),</span> <span class="s">" "</span><span class="o">);</span>
        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="kt">int</span> <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="kt">int</span> <span class="no">K</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        
    <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h5 id="2-a번-문제">2. a번 문제</h5>

<p>a. M 번 노드로 향하는 간선이 시작하는 노드 번호의 최댓값</p>

<p>일단 M번 노드로 향하는 거니 M보다 작은 노드가 범인이다.<br />
어차피 모든 노드는 작은 수에서 큰 수로 이어지니 M번 노드보다 하나 작은, xor 연산에서 비트 하나 다른 놈을 찾아야한다.<br />
반복문으로 1인 비트를 반전시켜서 비교한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// a번: 이진수 M의 1을 반전시킨 수 중 최대값</span>
<span class="c1">// 최대값 저장용</span>
<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
<span class="c1">// 0번째 비트부터 올라감, 100,000,000는 27비트</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">27</span> <span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="c1">// M의 i번째 비트가 1인 경우</span>
    <span class="c1">// == 1 할 경우 0번째 비트만 체크해서 오류 발생</span>
    <span class="c1">//if ((M &amp; (1 &lt;&lt; i)) == 1) {</span>
    <span class="k">if</span> <span class="o">((</span><span class="no">M</span> <span class="o">&amp;</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="no">M</span> <span class="o">^</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">);</span> <span class="c1">// 반전</span>
        
        <span class="k">if</span> <span class="o">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="no">M</span> <span class="o">&amp;&amp;</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">m</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h5 id="3-b번-문제">3. b번 문제</h5>

<p>a번이랑 비슷한데, 각 비트를 반전시켜서 최소값을 찾으면 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// b번: M의 비트 하나를 반전시킨 수 중 M보다 큰 최소값 찾기</span>
<span class="c1">// 최소값 저장용</span>
<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">27</span> <span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="c1">// i번째 비트를 반전시킨 숫자</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="no">M</span> <span class="o">^</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="no">M</span> <span class="o">&amp;&amp;</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">m</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h5 id="4-c번-문제">4. c번 문제</h5>

<p>해밍 무게 변화에 따른 경로 수를 구하는 것.<br />
전이 관계를 행렬 형태로 표현한 뒤, 행렬 거듭제곱을 통해 빠르게 K 단계를 계산한다.<br />
즉, 전체 시스템을 크기 N+1의 전이 행렬로 보고, dpK = T^K * dp₀ 형태로 계산하는 것이다!</p>

<p>엄….</p>

<p><span style="color: orange;"><strong>좋아 완벽하게 이해했어!!</strong></span></p>

<p>일단 시간복잡도가 O(NK)면 절대 통과하지 못한다.<br />
O(N log K)로 바꾸면 통과가 가능하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// c번: 공식계산</span>
<span class="n">doFactorials</span><span class="o">(</span><span class="no">N</span><span class="o">);</span>

<span class="c1">// 초기 상태 dp0: 해밍 무게 w를 가진 노드 수 = C(N, w)</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">w</span> <span class="o">&lt;=</span> <span class="no">N</span><span class="o">;</span> <span class="n">w</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">dp</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="no">C</span><span class="o">(</span><span class="no">N</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 전이 행렬 생성 (희소 형태로)</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&gt;&gt;</span> <span class="no">T</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="no">T</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
<span class="o">}</span>

<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="n">w</span><span class="o">++)</span> <span class="o">{</span>
    <span class="c1">// 해밍 무게가 w인 노드에서 w+1로 갈 수 있는 경우만 존재</span>
    <span class="no">T</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="no">N</span> <span class="o">-</span> <span class="n">w</span><span class="o">));</span>
<span class="o">}</span>

<span class="c1">// 희소 행렬 거듭제곱을 dp에 적용</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">dpK</span> <span class="o">=</span> <span class="n">sparseMatPowApply</span><span class="o">(</span><span class="no">T</span><span class="o">,</span> <span class="n">dp</span><span class="o">,</span> <span class="no">K</span><span class="o">,</span> <span class="no">N</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

<span class="c1">// 모든 해밍 무게에서 끝나는 경로 수 합</span>
<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">w</span> <span class="o">&lt;=</span> <span class="no">N</span><span class="o">;</span> <span class="n">w</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="n">c</span> <span class="o">+</span> <span class="n">dpK</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">%</span> <span class="mi">100003</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// ... 중략 ...</span>

<span class="c1">// 거듭제곱 계산</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">P</span><span class="o">(</span><span class="kt">int</span> <span class="n">b</span><span class="o">,</span> <span class="kt">int</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">e</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 거듭제곱 계산</span>
            <span class="n">r</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)((</span><span class="mi">1L</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">b</span><span class="o">)</span> <span class="o">%</span> <span class="mi">100003</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">b</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)((</span><span class="mi">1L</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="o">)</span> <span class="o">%</span> <span class="mi">100003</span><span class="o">);</span>
        <span class="n">e</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">r</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 팩토리얼 및 역팩토리얼 계산 (페르마 소정리 활용)</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">doFactorials</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">factorial</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
    <span class="n">invFactorial</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
    <span class="n">factorial</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="c1">// 팩토리얼 계산</span>
        <span class="n">factorial</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)((</span><span class="mi">1L</span> <span class="o">*</span> <span class="n">factorial</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="n">i</span><span class="o">)</span> <span class="o">%</span> <span class="mi">100003</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 역팩토리얼 (페르마의 소정리)</span>
    <span class="n">invFactorial</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">=</span> <span class="no">P</span><span class="o">(</span><span class="n">factorial</span><span class="o">[</span><span class="no">N</span><span class="o">],</span> <span class="mi">100003</span> <span class="o">-</span> <span class="mi">2</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="no">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
        <span class="c1">// 역팩토리얼 누적 계산</span>
        <span class="n">invFactorial</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)((</span><span class="mi">1L</span> <span class="o">*</span> <span class="n">invFactorial</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">%</span> <span class="mi">100003</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 이항계수 계산</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">C</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">w</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// C(n, r) 계산</span>
    <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="mi">1L</span> <span class="o">*</span> <span class="n">factorial</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">*</span> <span class="n">invFactorial</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">%</span> <span class="mi">100003</span> <span class="o">*</span> <span class="n">invFactorial</span><span class="o">[</span><span class="no">N</span> <span class="o">-</span> <span class="n">w</span><span class="o">]</span> <span class="o">%</span> <span class="mi">100003</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 희소행렬 형태: 각 행마다 (열, 값) 쌍 저장</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Pair</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">col</span><span class="o">,</span> <span class="n">val</span><span class="o">;</span>
    <span class="nc">Pair</span><span class="o">(</span><span class="kt">int</span> <span class="n">col</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 희소 행렬 곱셈</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sparseMatVecMul</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&gt;&gt;</span> <span class="n">mat</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">vec</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Pair</span> <span class="n">p</span> <span class="o">:</span> <span class="n">mat</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)((</span><span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1L</span> <span class="o">*</span> <span class="n">p</span><span class="o">.</span><span class="na">val</span> <span class="o">*</span> <span class="n">vec</span><span class="o">[</span><span class="n">p</span><span class="o">.</span><span class="na">col</span><span class="o">])</span> <span class="o">%</span> <span class="mi">100003</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 희소 행렬 거듭제곱과 곱셈</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sparseMatPowApply</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&gt;&gt;</span> <span class="no">T</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">vec</span><span class="o">,</span> <span class="kt">int</span> <span class="n">exp</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 초기 단위 행렬 적용: vec는 dp로 시작</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">exp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">exp</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">sparseMatVecMul</span><span class="o">(</span><span class="no">T</span><span class="o">,</span> <span class="n">vec</span><span class="o">,</span> <span class="n">size</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// T = T * T (희소 곱)</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&gt;&gt;</span> <span class="n">newT</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">newT</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
        <span class="o">}</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Pair</span> <span class="n">kv1</span> <span class="o">:</span> <span class="no">T</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">Pair</span> <span class="n">kv2</span> <span class="o">:</span> <span class="no">T</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">kv1</span><span class="o">.</span><span class="na">col</span><span class="o">))</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)((</span><span class="mi">1L</span> <span class="o">*</span> <span class="n">kv1</span><span class="o">.</span><span class="na">val</span> <span class="o">*</span> <span class="n">kv2</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">%</span> <span class="mi">100003</span><span class="o">);</span>
                    <span class="n">newT</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">(</span><span class="n">kv2</span><span class="o">.</span><span class="na">col</span><span class="o">,</span> <span class="n">val</span><span class="o">));</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 중복 열 통합</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">newT</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">continue</span><span class="o">;</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&gt;</span> <span class="n">row</span> <span class="o">=</span> <span class="n">newT</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">row</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="nc">Comparator</span><span class="o">.</span><span class="na">comparingInt</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="na">col</span><span class="o">));</span>

            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&gt;</span> <span class="n">compressed</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="kt">int</span> <span class="n">lastCol</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Pair</span> <span class="n">p</span> <span class="o">:</span> <span class="n">row</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">col</span> <span class="o">==</span> <span class="n">lastCol</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">sum</span> <span class="o">=</span> <span class="o">(</span><span class="n">sum</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">%</span> <span class="mi">100003</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">lastCol</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="n">compressed</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">(</span><span class="n">lastCol</span><span class="o">,</span> <span class="n">sum</span><span class="o">));</span>
                    <span class="n">lastCol</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">col</span><span class="o">;</span>
                    <span class="n">sum</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">lastCol</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="n">compressed</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">(</span><span class="n">lastCol</span><span class="o">,</span> <span class="n">sum</span><span class="o">));</span>
            <span class="n">newT</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">compressed</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="no">T</span> <span class="o">=</span> <span class="n">newT</span><span class="o">;</span>
        <span class="n">exp</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">vec</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Java/2025-05-20-15936/img02.jpg" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>c번에서 계속 시간초과 나길래 C++로 돌려보고 로직 문제란걸 깨닫고 구글링했다.<br />
내 힘으로 풀 수 있는 문제가 아니었다.<br />
수학공부한 셈 쳐야지 뭐.</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/random-solve/Java/2025-05-20-15936.java">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="random-solve/Java/" /><summary type="html"><![CDATA[문제 15936번 Hypercube - 백준 설계 앗 영어문제 아니 진짜 뭔 이딴문제만 걸리냐? 시간제한이 0.2초인데 이거 자바로 되나 싶었는데 푼 사람 목록보니 파이썬도 있다. 알고리즘 잘 짜면 자바도 되겠지 뭐… 입력으로 N, M, K를 준다. N: N차원 하이퍼 큐브 M: 노드 번호 K: 경로 길이 하이퍼 큐브가 머에여??? 초입방체 - 나무위키 2^N개의 노드를 가지며 x에서 y로 가려면 x &lt; y 이고 xor 연산 시 2^p가 되어야 한다.(비트가 하나 다르다.) 라고 문제에서 말해줌. 문제가 요구하는 건 3가지인데 a. M 번 노드로 향하는 간선이 시작하는 노드 번호의 최댓값 b. M 번 노드에서 시작하는 간선이 향하는 노드 번호의 최소값 c. 찾을 수 있는 K-길이의(K개의 간선을 포함하는) 경로의 개수. 100003 나머지 연산. 허허 이게 국어가 맞나 딱 봐도 하이퍼 큐브를 구현하면 제한 시간에 걸려 터진다. 더 좋은 수학실력이 필요하다는 뜻임… 구글링으로 수학 고수들을 통해 문제 해결 공식을 얻은 다음 구현은 내가 하는 쪽으로 한다. 나 혼자서는 풀 수 없음… 구현 1. 입력 받기 Scanner 사용하면 터질 것 같으니 버퍼로 입력 받는다. public static void main(String[] args) { try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out))) { StringTokenizer st = new StringTokenizer(br.readLine(), " "); int N = Integer.parseInt(st.nextToken()); int M = Integer.parseInt(st.nextToken()); int K = Integer.parseInt(st.nextToken()); }catch(IOException e) { e.printStackTrace(); } } 2. a번 문제 a. M 번 노드로 향하는 간선이 시작하는 노드 번호의 최댓값 일단 M번 노드로 향하는 거니 M보다 작은 노드가 범인이다. 어차피 모든 노드는 작은 수에서 큰 수로 이어지니 M번 노드보다 하나 작은, xor 연산에서 비트 하나 다른 놈을 찾아야한다. 반복문으로 1인 비트를 반전시켜서 비교한다. // a번: 이진수 M의 1을 반전시킨 수 중 최대값 // 최대값 저장용 int a = Integer.MIN_VALUE; // 0번째 비트부터 올라감, 100,000,000는 27비트 for (int i = 0 ; i &lt; 27 ; i++){ // M의 i번째 비트가 1인 경우 // == 1 할 경우 0번째 비트만 체크해서 오류 발생 //if ((M &amp; (1 &lt;&lt; i)) == 1) { if ((M &amp; (1 &lt;&lt; i)) != 0) { int m = M ^ (1 &lt;&lt; i); // 반전 if (m &lt; M &amp;&amp; m &gt; a) { a = m; } } } 3. b번 문제 a번이랑 비슷한데, 각 비트를 반전시켜서 최소값을 찾으면 된다. // b번: M의 비트 하나를 반전시킨 수 중 M보다 큰 최소값 찾기 // 최소값 저장용 int b = Integer.MAX_VALUE; for (int i = 0 ; i &lt; 27 ; i++){ // i번째 비트를 반전시킨 숫자 int m = M ^ (1 &lt;&lt; i); if (m &gt; M &amp;&amp; b &gt; m) { b = m; } } 4. c번 문제 해밍 무게 변화에 따른 경로 수를 구하는 것. 전이 관계를 행렬 형태로 표현한 뒤, 행렬 거듭제곱을 통해 빠르게 K 단계를 계산한다. 즉, 전체 시스템을 크기 N+1의 전이 행렬로 보고, dpK = T^K * dp₀ 형태로 계산하는 것이다! 엄…. 좋아 완벽하게 이해했어!! 일단 시간복잡도가 O(NK)면 절대 통과하지 못한다. O(N log K)로 바꾸면 통과가 가능하다. // c번: 공식계산 doFactorials(N); // 초기 상태 dp0: 해밍 무게 w를 가진 노드 수 = C(N, w) int[] dp = new int[N + 1]; for (int w = 0; w &lt;= N; w++) { dp[w] = C(N, w); } // 전이 행렬 생성 (희소 형태로) List&lt;List&lt;Pair&gt;&gt; T = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;= N; i++) { T.add(new ArrayList&lt;&gt;()); } for (int w = 0; w &lt; N; w++) { // 해밍 무게가 w인 노드에서 w+1로 갈 수 있는 경우만 존재 T.get(w + 1).add(new Pair(w, N - w)); } // 희소 행렬 거듭제곱을 dp에 적용 int[] dpK = sparseMatPowApply(T, dp, K, N + 1); // 모든 해밍 무게에서 끝나는 경로 수 합 int c = 0; for (int w = 0; w &lt;= N; w++) { c = (c + dpK[w]) % 100003; } // ... 중략 ... // 거듭제곱 계산 public static int P(int b, int e) { int r = 1; while (e &gt; 0) { if ((e &amp; 1) == 1) { // 거듭제곱 계산 r = (int)((1L * r * b) % 100003); } b = (int)((1L * b * b) % 100003); e &gt;&gt;= 1; } return r; } // 팩토리얼 및 역팩토리얼 계산 (페르마 소정리 활용) public static void doFactorials(int N) { factorial = new int[N + 1]; invFactorial = new int[N + 1]; factorial[0] = 1; for (int i = 1; i &lt;= N; i++) { // 팩토리얼 계산 factorial[i] = (int)((1L * factorial[i - 1] * i) % 100003); } // 역팩토리얼 (페르마의 소정리) invFactorial[N] = P(factorial[N], 100003 - 2); for (int i = N - 1; i &gt;= 0; i--) { // 역팩토리얼 누적 계산 invFactorial[i] = (int)((1L * invFactorial[i + 1] * (i + 1)) % 100003); } } // 이항계수 계산 public static int C(int N, int w) { if (w &lt; 0 || w &gt; N) { return 0; } // C(n, r) 계산 return (int)(1L * factorial[N] * invFactorial[w] % 100003 * invFactorial[N - w] % 100003); } // 희소행렬 형태: 각 행마다 (열, 값) 쌍 저장 public static class Pair { int col, val; Pair(int col, int val) { this.col = col; this.val = val; } } // 희소 행렬 곱셈 public static int[] sparseMatVecMul(List&lt;List&lt;Pair&gt;&gt; mat, int[] vec, int size) { int[] res = new int[size]; for (int i = 0; i &lt; size; i++) { for (Pair p : mat.get(i)) { res[i] = (int)((res[i] + 1L * p.val * vec[p.col]) % 100003); } } return res; } // 희소 행렬 거듭제곱과 곱셈 public static int[] sparseMatPowApply(List&lt;List&lt;Pair&gt;&gt; T, int[] vec, int exp, int size) { // 초기 단위 행렬 적용: vec는 dp로 시작 while (exp &gt; 0) { if ((exp &amp; 1) == 1) { vec = sparseMatVecMul(T, vec, size); } // T = T * T (희소 곱) List&lt;List&lt;Pair&gt;&gt; newT = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; size; i++) { newT.add(new ArrayList&lt;&gt;()); } for (int i = 0; i &lt; size; i++) { for (Pair kv1 : T.get(i)) { for (Pair kv2 : T.get(kv1.col)) { int val = (int)((1L * kv1.val * kv2.val) % 100003); newT.get(i).add(new Pair(kv2.col, val)); } } } // 중복 열 통합 for (int i = 0; i &lt; size; i++) { if (newT.get(i).isEmpty()) continue; List&lt;Pair&gt; row = newT.get(i); row.sort(Comparator.comparingInt(p -&gt; p.col)); List&lt;Pair&gt; compressed = new ArrayList&lt;&gt;(); int lastCol = -1, sum = 0; for (Pair p : row) { if (p.col == lastCol) { sum = (sum + p.val) % 100003; } else { if (lastCol != -1) compressed.add(new Pair(lastCol, sum)); lastCol = p.col; sum = p.val; } } if (lastCol != -1) compressed.add(new Pair(lastCol, sum)); newT.set(i, compressed); } T = newT; exp &gt;&gt;= 1; } return vec; } 채점 반성 c번에서 계속 시간초과 나길래 C++로 돌려보고 로직 문제란걸 깨닫고 구글링했다. 내 힘으로 풀 수 있는 문제가 아니었다. 수학공부한 셈 쳐야지 뭐. 코드 확인 Link to GitHub]]></summary></entry></feed>