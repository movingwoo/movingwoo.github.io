<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://movingwoo.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://movingwoo.github.io/" rel="alternate" type="text/html" hreflang="ko-KR" /><updated>2025-05-12T04:56:05+00:00</updated><id>https://movingwoo.github.io/feed.xml</id><title type="html">뭐라도 하겠지</title><subtitle>나도 사람인데 뭐라도 하겠지</subtitle><entry><title type="html">숫자야구</title><link href="https://movingwoo.github.io/one-pan/java/2025/05/11/Bulls-and-Cows.html" rel="alternate" type="text/html" title="숫자야구" /><published>2025-05-11T22:00:00+00:00</published><updated>2025-05-11T22:00:00+00:00</updated><id>https://movingwoo.github.io/one-pan/java/2025/05/11/Bulls%20and%20Cows</id><content type="html" xml:base="https://movingwoo.github.io/one-pan/java/2025/05/11/Bulls-and-Cows.html"><![CDATA[<blockquote>
  <h4 id="탄생-비화">탄생 비화</h4>
  <hr />
</blockquote>

<p><span style="color: orange;"><strong>숫자야구 져서 꼴받아서</strong></span><br />
처음에는 전체 숫자 풀에서 틀린 후보를 삭제해가는 식으로 했는데<br />
Knuth 전략을 이용하면 6턴 내 클리어가 보장된다고 하여 공부할 겸 만들어 봄</p>

<blockquote>
  <h4 id="구현-포인트">구현 포인트</h4>
  <hr />
</blockquote>

<h5 id="1-피드백-클래스-생성">1. 피드백 클래스 생성</h5>

<p>Knuth 전략의 핵심은 최악의 경우를 최소화하는 것이다.<br />
각 추측마다 가능한 모든 피드백 그룹을 만들고, 가장 큰 그룹의 크기를 최소화한다.<br />
피드백 그룹을 비교하기 위해 피드백 클래스를 생성해 관리한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 피드백 결과를 구조화해서 비교하고 후보군을 나누기 위해 피드백 클래스 생성</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Feedback</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">strikes</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">balls</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">Feedback</span><span class="o">(</span><span class="kt">int</span> <span class="n">strikes</span><span class="o">,</span> <span class="kt">int</span> <span class="n">balls</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">strikes</span> <span class="o">=</span> <span class="n">strikes</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">balls</span> <span class="o">=</span> <span class="n">balls</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">object</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(!(</span><span class="n">object</span> <span class="k">instanceof</span> <span class="nc">Feedback</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    
    <span class="nc">Feedback</span> <span class="n">feedback</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Feedback</span><span class="o">)</span> <span class="n">object</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">strikes</span> <span class="o">==</span> <span class="n">feedback</span><span class="o">.</span><span class="na">strikes</span> <span class="o">&amp;&amp;</span> <span class="n">balls</span> <span class="o">==</span> <span class="n">feedback</span><span class="o">.</span><span class="na">balls</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// Map에서 올바르게 비교되도록 해시코드 설정</span>
    <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">hash</span><span class="o">(</span><span class="n">strikes</span><span class="o">,</span> <span class="n">balls</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h5 id="2-최적의-추측-선택">2. 최적의 추측 선택</h5>

<p>남은 후보군, 전체 후보군을 받아서 최악의 경우를 계산한다.<br />
피드백 그룹의 크기를 최악의 경우로 판단해서 그 숫자가 가장 작은 것을 선택한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 최적 추측 선택</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">chooseBestGuess</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">candidates</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">allCandidates</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">triedGuesses</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">minWorst</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
  <span class="nc">String</span> <span class="n">bestGuess</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

  <span class="c1">// 모든 추측을 가지고 후보군과 비교해 가장 피드백이 많이 나오는 그룹 수를 계산한다(최악의 경우)</span>
  <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">guess</span> <span class="o">:</span> <span class="n">allCandidates</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 이미 시도한 추측은 건너뛰기</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">triedGuesses</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">guess</span><span class="o">))</span> <span class="k">continue</span><span class="o">;</span>

    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Feedback</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">actual</span> <span class="o">:</span> <span class="n">candidates</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">Feedback</span> <span class="n">f</span> <span class="o">=</span> <span class="n">getFeedback</span><span class="o">(</span><span class="n">actual</span><span class="o">,</span> <span class="n">guess</span><span class="o">);</span>
      <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">// Knuth 전략의 핵심, 최악의 경우 계산 (가장 많은 후보가 남는 경우)</span>
    <span class="kt">int</span> <span class="n">worst</span> <span class="o">=</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">values</span><span class="o">());</span>
    
    <span class="c1">// 더 나은 추측을 찾았거나, 동일한 최악의 경우에서 더 작은 숫자를 선택</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">worst</span> <span class="o">&lt;</span> <span class="n">minWorst</span> <span class="o">||</span> <span class="o">(</span><span class="n">worst</span> <span class="o">==</span> <span class="n">minWorst</span> <span class="o">&amp;&amp;</span> <span class="n">guess</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">bestGuess</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">minWorst</span> <span class="o">=</span> <span class="n">worst</span><span class="o">;</span>
      <span class="n">bestGuess</span> <span class="o">=</span> <span class="n">guess</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">return</span> <span class="n">bestGuess</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h5 id="3-입력-받아-판단-수행">3. 입력 받아 판단 수행</h5>

<p>추측에 대한 결과를 입력받아 다음 추측을 제시하는 부분.<br />
최종적인 답이 나올때 까지 반복문을 돌린다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// 1턴에서는 추측이 의미 없으므로 1234를 제시하고 결과를 받도록 한다.</span>
  <span class="nc">String</span> <span class="n">guess</span> <span class="o">=</span> <span class="s">"1234"</span><span class="o">;</span>
  
  <span class="k">if</span> <span class="o">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">guess</span> <span class="o">=</span> <span class="n">chooseBestGuess</span><span class="o">(</span><span class="n">candidates</span><span class="o">,</span> <span class="n">allCandidates</span><span class="o">,</span> <span class="n">triedGuesses</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="n">triedGuesses</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">guess</span><span class="o">);</span>  <span class="c1">// 시도한 추측 기록</span>

  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">turn</span> <span class="o">+</span> <span class="s">"턴) 추천 추측: "</span> <span class="o">+</span> <span class="n">guess</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"입력 (예: 1s2b / 3s / 2b / o): "</span><span class="o">);</span>
  <span class="c1">// 추천 추측에 대한 결과를 입력받는다.</span>
  <span class="nc">String</span> <span class="n">input</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextLine</span><span class="o">().</span><span class="na">trim</span><span class="o">().</span><span class="na">toLowerCase</span><span class="o">();</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">input</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">input</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"입력 없음"</span><span class="o">);</span>
    <span class="k">continue</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kt">int</span> <span class="n">strikes</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">balls</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

  <span class="c1">// 정규식으로 스트라이크 볼 패턴 구분</span>
  <span class="nc">Pattern</span> <span class="n">pattern</span> <span class="o">=</span> <span class="nc">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">"^(\\d+s)?(\\d+b)?$|^(\\d+b)?(\\d+s)?$"</span><span class="o">);</span>
  
  <span class="k">if</span> <span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"o"</span><span class="o">))</span> <span class="o">{</span>
    <span class="c1">// 아웃은 0s0b 따로 할 거 없음</span>
    <span class="n">strikes</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">balls</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">pattern</span><span class="o">.</span><span class="na">matcher</span><span class="o">(</span><span class="n">input</span><span class="o">).</span><span class="na">matches</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">Matcher</span> <span class="n">m</span> <span class="o">=</span> <span class="nc">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">"(\\d+)s|(\\d+)b"</span><span class="o">).</span><span class="na">matcher</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">find</span><span class="o">())</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">strikes</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
      <span class="o">}</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">balls</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"잘못된 입력 형식"</span><span class="o">);</span>
    <span class="k">continue</span><span class="o">;</span>
  <span class="o">}</span>
  
  <span class="nc">Feedback</span> <span class="n">feedback</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Feedback</span><span class="o">(</span><span class="n">strikes</span><span class="o">,</span> <span class="n">balls</span><span class="o">);</span>
  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">filter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
  
  <span class="c1">// 피드백을 입력받으면 정확히 일치하는 후보만 남김</span>
  <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">c</span> <span class="o">:</span> <span class="n">candidates</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">getFeedback</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">guess</span><span class="o">).</span><span class="na">equals</span><span class="o">(</span><span class="n">feedback</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">filter</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
  
  <span class="c1">// 필터가 비면 잘못된 것...</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">filter</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"후보가 없습니다. 입력값을 확인해 주세요."</span><span class="o">);</span>
    <span class="k">continue</span><span class="o">;</span>
  <span class="o">}</span>
  
  <span class="c1">// 후보군을 필터로 갱신</span>
  <span class="n">candidates</span> <span class="o">=</span> <span class="n">filter</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">candidates</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 유일한 정답 출력 후 종료</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"정답: "</span> <span class="o">+</span> <span class="n">candidates</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
    <span class="k">break</span><span class="o">;</span>
  <span class="o">}</span>
  
  <span class="n">turn</span><span class="o">++;</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="완성">완성</h4>
  <hr />
</blockquote>

<p>1차 테스트 숫자는 <span style="color: orange;"><strong>4865</strong></span></p>

<p><img src="/assets/images/posts/one-pan/Java/2025-05-12-Bulls and Cows/img01.jpg" alt="img01" /></p>

<p>2차 테스트 숫자는 <span style="color: orange;"><strong>0918</strong></span></p>

<p><img src="/assets/images/posts/one-pan/Java/2025-05-12-Bulls and Cows/img02.jpg" alt="img02" /></p>

<p>3차 테스트 숫자는 <span style="color: orange;"><strong>2580</strong></span></p>

<p><img src="/assets/images/posts/one-pan/Java/2025-05-12-Bulls and Cows/img03.jpg" alt="img03" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>사실 이 상태에서는 아웃에 대한 판단이 잘못되어있다.<br />
숫자 4개를 통으로 날릴 수 있는 아웃이 아무리 생각해도 최대 효율인데 왜 최악으로 판단되지?</p>

<p>Knuth 전략에서는 피드백 그룹의 크기로 최악의 그룹을 찾는다.<br />
<span style="color: orange;"><strong>그런데 아웃의 경우 (0s0b) 그룹에 속하는 후보가 많을 수 있어서 최악의 경우로 판단된다.</strong></span></p>
<ul>
  <li>인간) 4개 다 아니네? 개꿀 ㅋㅋㅋㅋ</li>
  <li>깡통) 0s0b 그룹이 너무 많네? 이것은 최악의 경우이다.</li>
</ul>

<p>최적화를 위해서는 단순히 그룹의 크기로만 판단하지 않고 <span style="color: orange;"><strong>정보량을 고려</strong></span>해야 한다.<br />
아웃에 가중치를 주고 <span style="color: orange;"><strong>아웃을 우수한 추측으로 간주</strong></span>하도록 설정(점수제 도입)하면 더 나은 로직을 짤 수 있다.</p>

<p>하지만 현 상태로도 6턴 내 클리어가 보장되며, 감히 숫자야구 덤비는 애송이들의 뚝배기를 조각낼 수 있기 때문에 여기서 스탑.</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/Java/2025-05-12-Bulls%20and%20Cows.java">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="one-pan/Java/" /><summary type="html"><![CDATA[탄생 비화 숫자야구 져서 꼴받아서 처음에는 전체 숫자 풀에서 틀린 후보를 삭제해가는 식으로 했는데 Knuth 전략을 이용하면 6턴 내 클리어가 보장된다고 하여 공부할 겸 만들어 봄 구현 포인트 1. 피드백 클래스 생성 Knuth 전략의 핵심은 최악의 경우를 최소화하는 것이다. 각 추측마다 가능한 모든 피드백 그룹을 만들고, 가장 큰 그룹의 크기를 최소화한다. 피드백 그룹을 비교하기 위해 피드백 클래스를 생성해 관리한다. // 피드백 결과를 구조화해서 비교하고 후보군을 나누기 위해 피드백 클래스 생성 private static class Feedback { int strikes; int balls; public Feedback(int strikes, int balls) { this.strikes = strikes; this.balls = balls; } @Override public boolean equals(Object object) { if (this == object) return true; if (!(object instanceof Feedback)) return false; Feedback feedback = (Feedback) object; return strikes == feedback.strikes &amp;&amp; balls == feedback.balls; } @Override public int hashCode() { // Map에서 올바르게 비교되도록 해시코드 설정 return Objects.hash(strikes, balls); } } 2. 최적의 추측 선택 남은 후보군, 전체 후보군을 받아서 최악의 경우를 계산한다. 피드백 그룹의 크기를 최악의 경우로 판단해서 그 숫자가 가장 작은 것을 선택한다. // 최적 추측 선택 private static String chooseBestGuess(List&lt;String&gt; candidates, List&lt;String&gt; allCandidates, Set&lt;String&gt; triedGuesses) { int minWorst = Integer.MAX_VALUE; String bestGuess = null; // 모든 추측을 가지고 후보군과 비교해 가장 피드백이 많이 나오는 그룹 수를 계산한다(최악의 경우) for (String guess : allCandidates) { // 이미 시도한 추측은 건너뛰기 if (triedGuesses.contains(guess)) continue; Map&lt;Feedback, Integer&gt; map = new HashMap&lt;&gt;(); for (String actual : candidates) { Feedback f = getFeedback(actual, guess); map.put(f, map.getOrDefault(f, 0) + 1); } // Knuth 전략의 핵심, 최악의 경우 계산 (가장 많은 후보가 남는 경우) int worst = Collections.max(map.values()); // 더 나은 추측을 찾았거나, 동일한 최악의 경우에서 더 작은 숫자를 선택 if (worst &lt; minWorst || (worst == minWorst &amp;&amp; guess.compareTo(bestGuess) &lt; 0)) { minWorst = worst; bestGuess = guess; } } return bestGuess; } 3. 입력 받아 판단 수행 추측에 대한 결과를 입력받아 다음 추측을 제시하는 부분. 최종적인 답이 나올때 까지 반복문을 돌린다. while (true) { // 1턴에서는 추측이 의미 없으므로 1234를 제시하고 결과를 받도록 한다. String guess = "1234"; if (turn != 1) { guess = chooseBestGuess(candidates, allCandidates, triedGuesses); } triedGuesses.add(guess); // 시도한 추측 기록 System.out.println(turn + "턴) 추천 추측: " + guess); System.out.print("입력 (예: 1s2b / 3s / 2b / o): "); // 추천 추측에 대한 결과를 입력받는다. String input = sc.nextLine().trim().toLowerCase(); if (input == null || input.length() == 0) { System.out.println("입력 없음"); continue; } int strikes = 0; int balls = 0; // 정규식으로 스트라이크 볼 패턴 구분 Pattern pattern = Pattern.compile("^(\\d+s)?(\\d+b)?$|^(\\d+b)?(\\d+s)?$"); if (input.equals("o")) { // 아웃은 0s0b 따로 할 거 없음 strikes = 0; balls = 0; } else if (pattern.matcher(input).matches()) { Matcher m = Pattern.compile("(\\d+)s|(\\d+)b").matcher(input); while (m.find()) { if (m.group(1) != null) { strikes = Integer.parseInt(m.group(1)); } if (m.group(2) != null) { balls = Integer.parseInt(m.group(2)); } } } else { System.out.println("잘못된 입력 형식"); continue; } Feedback feedback = new Feedback(strikes, balls); List&lt;String&gt; filter = new ArrayList&lt;&gt;(); // 피드백을 입력받으면 정확히 일치하는 후보만 남김 for (String c : candidates) { if (getFeedback(c, guess).equals(feedback)) { filter.add(c); } } // 필터가 비면 잘못된 것... if (filter.isEmpty()) { System.out.println("후보가 없습니다. 입력값을 확인해 주세요."); continue; } // 후보군을 필터로 갱신 candidates = filter; if (candidates.size() == 1) { // 유일한 정답 출력 후 종료 System.out.println("정답: " + candidates.get(0)); break; } turn++; } 완성 1차 테스트 숫자는 4865 2차 테스트 숫자는 0918 3차 테스트 숫자는 2580 반성 사실 이 상태에서는 아웃에 대한 판단이 잘못되어있다. 숫자 4개를 통으로 날릴 수 있는 아웃이 아무리 생각해도 최대 효율인데 왜 최악으로 판단되지? Knuth 전략에서는 피드백 그룹의 크기로 최악의 그룹을 찾는다. 그런데 아웃의 경우 (0s0b) 그룹에 속하는 후보가 많을 수 있어서 최악의 경우로 판단된다. 인간) 4개 다 아니네? 개꿀 ㅋㅋㅋㅋ 깡통) 0s0b 그룹이 너무 많네? 이것은 최악의 경우이다. 최적화를 위해서는 단순히 그룹의 크기로만 판단하지 않고 정보량을 고려해야 한다. 아웃에 가중치를 주고 아웃을 우수한 추측으로 간주하도록 설정(점수제 도입)하면 더 나은 로직을 짤 수 있다. 하지만 현 상태로도 6턴 내 클리어가 보장되며, 감히 숫자야구 덤비는 애송이들의 뚝배기를 조각낼 수 있기 때문에 여기서 스탑. 코드 확인 Link to GitHub]]></summary></entry><entry><title type="html">즐거운 연휴, 어떻게 보내면 좋을까?</title><link href="https://movingwoo.github.io/ai-playground/claude/2025/05/01/Claude.html" rel="alternate" type="text/html" title="즐거운 연휴, 어떻게 보내면 좋을까?" /><published>2025-05-01T23:00:00+00:00</published><updated>2025-05-01T23:00:00+00:00</updated><id>https://movingwoo.github.io/ai-playground/claude/2025/05/01/Claude</id><content type="html" xml:base="https://movingwoo.github.io/ai-playground/claude/2025/05/01/Claude.html"><![CDATA[<p><span style="color: red;"><strong>본 포스트는 AI가 제작한 포스트입니다.</strong></span><br />
<span style="color: orange;">주제: 즐거운 연휴</span><br />
<span style="color: orange;">조건: 한글 1000자 이상</span></p>

<hr />
<h1 id="즐거운-연휴-어떻게-보내면-좋을까">즐거운 연휴, 어떻게 보내면 좋을까?</h1>

<p>연휴가 시작되면 많은 사람들이 “이번 연휴는 어떻게 보내야 할까?”라는 고민에 빠지곤 합니다. 짧은 시간을 어떻게 하면 가장 의미있고 즐겁게 보낼 수 있을지, 몇 가지 아이디어를 공유해보려 합니다.</p>

<h2 id="1-가족과-함께하는-시간">1. 가족과 함께하는 시간</h2>

<p>연휴의 가장 큰 의미는 가족과 함께하는 시간을 가질 수 있다는 점입니다. 평소 바쁜 일상으로 인해 소홀했던 가족들과의 대화를 나누고, 함께 식사를 준비하며 추억을 만들어보세요. 특히 요즘은 각자 스마트폰에 빠져있어 대화가 줄어든 가정이 많은데, 연휴 동안만큼은 디지털 디톡스를 실천해보는 것도 좋은 방법입니다.</p>

<h2 id="2-새로운-취미-활동">2. 새로운 취미 활동</h2>

<p>평소에 시작해보고 싶었던 취미 활동을 시작해보는 것도 좋은 방법입니다. 요리, 그림, 악기 연주, 독서 등 다양한 취미가 있습니다. 특히 요즘은 온라인 강의나 튜토리얼이 많이 있어서 집에서도 쉽게 새로운 것을 배울 수 있습니다. 연휴 동안 새로운 취미를 발견하면, 그 이후에도 일상에 활력을 불어넣을 수 있습니다.</p>

<h2 id="3-여행과-탐험">3. 여행과 탐험</h2>

<p>짧은 여행이나 근처의 새로운 장소를 탐험해보는 것도 좋은 방법입니다. 멀리 가지 않더라도, 우리 동네에 있는 공원이나 박물관, 미술관 등을 방문해보세요. 평소에는 바빠서 가보지 못했던 곳들을 탐험하다 보면 새로운 발견과 즐거움을 얻을 수 있습니다.</p>

<h2 id="4-자기계발">4. 자기계발</h2>

<p>연휴는 자기계발을 위한 좋은 시간이기도 합니다. 평소에 읽고 싶었던 책을 읽거나, 온라인 강의를 듣거나, 새로운 기술을 배워보세요. 특히 요즘은 AI와 관련된 다양한 학습 자료들이 많아서, 이 분야에 관심이 있다면 연휴 동안 기초를 다져보는 것도 좋은 방법입니다.</p>

<h2 id="5-휴식과-재충전">5. 휴식과 재충전</h2>

<p>가장 중요한 것은 충분한 휴식입니다. 평소에 쌓인 피로를 풀고, 마음을 정리하는 시간을 가지세요. 충분한 수면과 휴식을 취하고, 마음의 여유를 가지는 것이 연휴의 가장 큰 목적이기도 합니다.</p>

<h2 id="6-봉사활동">6. 봉사활동</h2>

<p>다른 사람을 돕는 것도 연휴를 의미있게 보내는 방법입니다. 지역사회 봉사활동에 참여하거나, 이웃과 함께하는 작은 선행을 실천해보세요. 다른 사람을 돕는 과정에서 얻는 기쁨과 만족감은 연휴를 더욱 특별하게 만들어줄 것입니다.</p>

<h2 id="7-건강-관리">7. 건강 관리</h2>

<p>연휴 동안 건강 관리에도 신경쓰세요. 규칙적인 운동과 균형잡힌 식사를 통해 몸의 균형을 잡는 시간을 가지세요. 특히 연휴 기간에는 과식과 과음이 잦아지기 쉬우니, 적당한 선에서 즐기도록 주의해야 합니다.</p>

<h2 id="8-미래-계획-세우기">8. 미래 계획 세우기</h2>

<p>연휴는 미래를 계획하기에도 좋은 시간입니다. 올해 남은 기간 동안의 목표를 세우고, 구체적인 실행 계획을 만들어보세요. 개인적인 목표뿐만 아니라 가족이나 친구들과 함께 할 수 있는 계획도 세워보면 좋습니다.</p>

<h2 id="9-감사하는-마음">9. 감사하는 마음</h2>

<p>연휴 동안은 주변 사람들과 환경에 대해 감사하는 마음을 가져보세요. 평소에는 당연하게 여겼던 것들에 대해 감정을 느끼고, 그 감정을 주변 사람들과 나누어보세요. 감사하는 마음은 우리의 삶을 더욱 풍요롭게 만들어줍니다.</p>

<h2 id="10-디지털-디톡스">10. 디지털 디톡스</h2>

<p>마지막으로, 연휴 동안만큼은 디지털 기기에서 벗어나보세요. 스마트폰과 컴퓨터에서 잠시 떨어져서, 현실 세계의 소중한 순간들을 만끽해보세요. 디지털 디톡스를 통해 마음의 여유를 찾고, 진정한 휴식을 취할 수 있습니다.</p>

<p>연휴는 단순히 쉬는 시간이 아니라, 우리의 삶을 더욱 풍요롭게 만들어줄 수 있는 소중한 시간입니다. 위에서 언급한 방법들 중에서 자신에게 맞는 것을 선택하거나, 새로운 방법을 찾아보세요. 중요한 것은 연휴를 통해 진정한 휴식과 행복을 찾는 것입니다. 즐거운 연휴 되세요!</p>

<blockquote>
  <h4 id="내-생각">내 생각</h4>
  <hr />
</blockquote>

<p>질문에 대한 AI의 전형적인 답변이라는 느낌.<br />
다만 1000자 제한을 걸었더니 4번에서 끝날 항목이 10번으로 늘어난 듯.<br />
새로운 취미, 여행, 건강 다 좋지만 나는 디지털이 있어야 디톡스 되는 사람이라고.</p>]]></content><author><name>Claude3.5</name></author><category term="AI-playground/Claude/" /><summary type="html"><![CDATA[본 포스트는 AI가 제작한 포스트입니다. 주제: 즐거운 연휴 조건: 한글 1000자 이상 즐거운 연휴, 어떻게 보내면 좋을까? 연휴가 시작되면 많은 사람들이 “이번 연휴는 어떻게 보내야 할까?”라는 고민에 빠지곤 합니다. 짧은 시간을 어떻게 하면 가장 의미있고 즐겁게 보낼 수 있을지, 몇 가지 아이디어를 공유해보려 합니다. 1. 가족과 함께하는 시간 연휴의 가장 큰 의미는 가족과 함께하는 시간을 가질 수 있다는 점입니다. 평소 바쁜 일상으로 인해 소홀했던 가족들과의 대화를 나누고, 함께 식사를 준비하며 추억을 만들어보세요. 특히 요즘은 각자 스마트폰에 빠져있어 대화가 줄어든 가정이 많은데, 연휴 동안만큼은 디지털 디톡스를 실천해보는 것도 좋은 방법입니다. 2. 새로운 취미 활동 평소에 시작해보고 싶었던 취미 활동을 시작해보는 것도 좋은 방법입니다. 요리, 그림, 악기 연주, 독서 등 다양한 취미가 있습니다. 특히 요즘은 온라인 강의나 튜토리얼이 많이 있어서 집에서도 쉽게 새로운 것을 배울 수 있습니다. 연휴 동안 새로운 취미를 발견하면, 그 이후에도 일상에 활력을 불어넣을 수 있습니다. 3. 여행과 탐험 짧은 여행이나 근처의 새로운 장소를 탐험해보는 것도 좋은 방법입니다. 멀리 가지 않더라도, 우리 동네에 있는 공원이나 박물관, 미술관 등을 방문해보세요. 평소에는 바빠서 가보지 못했던 곳들을 탐험하다 보면 새로운 발견과 즐거움을 얻을 수 있습니다. 4. 자기계발 연휴는 자기계발을 위한 좋은 시간이기도 합니다. 평소에 읽고 싶었던 책을 읽거나, 온라인 강의를 듣거나, 새로운 기술을 배워보세요. 특히 요즘은 AI와 관련된 다양한 학습 자료들이 많아서, 이 분야에 관심이 있다면 연휴 동안 기초를 다져보는 것도 좋은 방법입니다. 5. 휴식과 재충전 가장 중요한 것은 충분한 휴식입니다. 평소에 쌓인 피로를 풀고, 마음을 정리하는 시간을 가지세요. 충분한 수면과 휴식을 취하고, 마음의 여유를 가지는 것이 연휴의 가장 큰 목적이기도 합니다. 6. 봉사활동 다른 사람을 돕는 것도 연휴를 의미있게 보내는 방법입니다. 지역사회 봉사활동에 참여하거나, 이웃과 함께하는 작은 선행을 실천해보세요. 다른 사람을 돕는 과정에서 얻는 기쁨과 만족감은 연휴를 더욱 특별하게 만들어줄 것입니다. 7. 건강 관리 연휴 동안 건강 관리에도 신경쓰세요. 규칙적인 운동과 균형잡힌 식사를 통해 몸의 균형을 잡는 시간을 가지세요. 특히 연휴 기간에는 과식과 과음이 잦아지기 쉬우니, 적당한 선에서 즐기도록 주의해야 합니다. 8. 미래 계획 세우기 연휴는 미래를 계획하기에도 좋은 시간입니다. 올해 남은 기간 동안의 목표를 세우고, 구체적인 실행 계획을 만들어보세요. 개인적인 목표뿐만 아니라 가족이나 친구들과 함께 할 수 있는 계획도 세워보면 좋습니다. 9. 감사하는 마음 연휴 동안은 주변 사람들과 환경에 대해 감사하는 마음을 가져보세요. 평소에는 당연하게 여겼던 것들에 대해 감정을 느끼고, 그 감정을 주변 사람들과 나누어보세요. 감사하는 마음은 우리의 삶을 더욱 풍요롭게 만들어줍니다. 10. 디지털 디톡스 마지막으로, 연휴 동안만큼은 디지털 기기에서 벗어나보세요. 스마트폰과 컴퓨터에서 잠시 떨어져서, 현실 세계의 소중한 순간들을 만끽해보세요. 디지털 디톡스를 통해 마음의 여유를 찾고, 진정한 휴식을 취할 수 있습니다. 연휴는 단순히 쉬는 시간이 아니라, 우리의 삶을 더욱 풍요롭게 만들어줄 수 있는 소중한 시간입니다. 위에서 언급한 방법들 중에서 자신에게 맞는 것을 선택하거나, 새로운 방법을 찾아보세요. 중요한 것은 연휴를 통해 진정한 휴식과 행복을 찾는 것입니다. 즐거운 연휴 되세요! 내 생각 질문에 대한 AI의 전형적인 답변이라는 느낌. 다만 1000자 제한을 걸었더니 4번에서 끝날 항목이 10번으로 늘어난 듯. 새로운 취미, 여행, 건강 다 좋지만 나는 디지털이 있어야 디톡스 되는 사람이라고.]]></summary></entry><entry><title type="html">즐거운 연휴</title><link href="https://movingwoo.github.io/ai-playground/gpt/2025/05/01/GPT.html" rel="alternate" type="text/html" title="즐거운 연휴" /><published>2025-05-01T23:00:00+00:00</published><updated>2025-05-01T23:00:00+00:00</updated><id>https://movingwoo.github.io/ai-playground/gpt/2025/05/01/GPT</id><content type="html" xml:base="https://movingwoo.github.io/ai-playground/gpt/2025/05/01/GPT.html"><![CDATA[<p><span style="color: red;"><strong>본 포스트는 AI가 제작한 포스트입니다.</strong></span><br />
<span style="color: orange;">주제: 즐거운 연휴</span><br />
<span style="color: orange;">조건: 한글 1000자 이상</span></p>

<hr />

<p>연휴는 언제나 우리 삶에 작은 쉼표가 되어준다. 바쁜 일상 속에서 벗어나 마음껏 쉬고, 가족이나 친구들과 함께 시간을 보내는 소중한 기회다. 이번 연휴도 예외는 아니었다. 나는 오랜만에 느긋하게 아침을 맞이했고, 따뜻한 커피 한 잔과 함께 여유로운 하루를 시작했다.</p>

<p>첫째 날에는 집 근처 공원으로 산책을 다녀왔다. 봄기운이 완연히 느껴지는 따사로운 햇살 아래, 피어난 꽃들과 초록빛 잎사귀들이 반겨주었다. 아이들의 웃음소리, 강아지들이 뛰노는 모습, 벤치에 앉아 책을 읽는 사람들까지 모두가 평화로워 보였다. 걷는 것만으로도 마음이 정화되는 기분이었다.</p>

<p>둘째 날에는 친구들과 모여 홈파티를 열었다. 직접 요리한 음식을 나누고, 함께 게임도 하고, 지난 추억을 이야기하며 시간 가는 줄 몰랐다. 오랜만에 만난 친구들과의 만남은 언제나 그렇듯 즐겁고 따뜻했다. 우리는 서로의 삶에 대해 응원하며 다시 만날 날을 기약했다.</p>

<p>연휴의 마지막 날에는 혼자만의 시간을 가졌다. 좋아하는 음악을 들으며 책을 읽고, 앞으로의 계획을 정리해보았다. 평소에는 바쁘다는 이유로 미뤄두었던 일들도 차근차근 해내니 뿌듯한 마음이 들었다. 때로는 이렇게 나 자신에게 집중하는 시간도 꼭 필요한 것 같다.</p>

<p>이처럼 이번 연휴는 짧지만 깊은 여운을 남겼다. 몸도 마음도 재충전할 수 있었고, 소중한 사람들과의 관계도 다시금 다질 수 있었다. 이제 다시 일상으로 돌아가야 하지만, 이런 연휴가 있었기에 더욱 힘차게 나아갈 수 있을 것 같다.</p>

<p>우리 모두에게 이런 ‘즐거운 연휴’가 자주 찾아오기를 바라며, 다음 연휴를 벌써부터 기다려본다.</p>

<blockquote>
  <h4 id="내-생각">내 생각</h4>
  <hr />
</blockquote>

<p>이 친구 왜 수필을 써버리는거지?<br />
GPT가 좋아하는 이모지도 쓰지 않고 담담하게 줄글만 풀어놨다.<br />
무슨 생각을 한 것일까?<br />
AI 답다고 생각한 부분은 연휴가 끝나면 공포와 절망밖에 없지만 끝까지 희망적인 관측을 하며 다음 연휴를 기다린다는 것…</p>]]></content><author><name>GPT4o</name></author><category term="AI-playground/GPT/" /><summary type="html"><![CDATA[본 포스트는 AI가 제작한 포스트입니다. 주제: 즐거운 연휴 조건: 한글 1000자 이상 연휴는 언제나 우리 삶에 작은 쉼표가 되어준다. 바쁜 일상 속에서 벗어나 마음껏 쉬고, 가족이나 친구들과 함께 시간을 보내는 소중한 기회다. 이번 연휴도 예외는 아니었다. 나는 오랜만에 느긋하게 아침을 맞이했고, 따뜻한 커피 한 잔과 함께 여유로운 하루를 시작했다. 첫째 날에는 집 근처 공원으로 산책을 다녀왔다. 봄기운이 완연히 느껴지는 따사로운 햇살 아래, 피어난 꽃들과 초록빛 잎사귀들이 반겨주었다. 아이들의 웃음소리, 강아지들이 뛰노는 모습, 벤치에 앉아 책을 읽는 사람들까지 모두가 평화로워 보였다. 걷는 것만으로도 마음이 정화되는 기분이었다. 둘째 날에는 친구들과 모여 홈파티를 열었다. 직접 요리한 음식을 나누고, 함께 게임도 하고, 지난 추억을 이야기하며 시간 가는 줄 몰랐다. 오랜만에 만난 친구들과의 만남은 언제나 그렇듯 즐겁고 따뜻했다. 우리는 서로의 삶에 대해 응원하며 다시 만날 날을 기약했다. 연휴의 마지막 날에는 혼자만의 시간을 가졌다. 좋아하는 음악을 들으며 책을 읽고, 앞으로의 계획을 정리해보았다. 평소에는 바쁘다는 이유로 미뤄두었던 일들도 차근차근 해내니 뿌듯한 마음이 들었다. 때로는 이렇게 나 자신에게 집중하는 시간도 꼭 필요한 것 같다. 이처럼 이번 연휴는 짧지만 깊은 여운을 남겼다. 몸도 마음도 재충전할 수 있었고, 소중한 사람들과의 관계도 다시금 다질 수 있었다. 이제 다시 일상으로 돌아가야 하지만, 이런 연휴가 있었기에 더욱 힘차게 나아갈 수 있을 것 같다. 우리 모두에게 이런 ‘즐거운 연휴’가 자주 찾아오기를 바라며, 다음 연휴를 벌써부터 기다려본다. 내 생각 이 친구 왜 수필을 써버리는거지? GPT가 좋아하는 이모지도 쓰지 않고 담담하게 줄글만 풀어놨다. 무슨 생각을 한 것일까? AI 답다고 생각한 부분은 연휴가 끝나면 공포와 절망밖에 없지만 끝까지 희망적인 관측을 하며 다음 연휴를 기다린다는 것…]]></summary></entry><entry><title type="html">AI 시대의 개발자, 어떻게 준비해야 할까?</title><link href="https://movingwoo.github.io/ai-playground/claude/2025/04/30/Claude.html" rel="alternate" type="text/html" title="AI 시대의 개발자, 어떻게 준비해야 할까?" /><published>2025-04-30T03:00:00+00:00</published><updated>2025-04-30T03:00:00+00:00</updated><id>https://movingwoo.github.io/ai-playground/claude/2025/04/30/Claude</id><content type="html" xml:base="https://movingwoo.github.io/ai-playground/claude/2025/04/30/Claude.html"><![CDATA[<p><span style="color: red;"><strong>본 포스트는 AI가 제작한 포스트입니다.</strong></span><br />
<span style="color: orange;">주제: IT 자유</span></p>

<hr />

<h2 id="들어가며">들어가며</h2>

<p>최근 AI 기술의 급속한 발전으로 인해 소프트웨어 개발 분야에서도 큰 변화가 일어나고 있습니다. ChatGPT, GitHub Copilot과 같은 도구들이 개발자의 일상에 깊숙이 자리잡으면서, 많은 개발자들이 “AI가 개발자의 일자리를 대체할까?”라는 질문을 던지고 있습니다. 이 글에서는 AI 시대에 개발자가 어떻게 준비해야 하는지에 대해 이야기해보려 합니다.</p>

<h2 id="ai가-가져온-변화">AI가 가져온 변화</h2>

<ol>
  <li><strong>코드 생성의 자동화</strong>
    <ul>
      <li>GitHub Copilot과 같은 도구들이 코드 작성을 도와줌</li>
      <li>반복적인 코드 패턴을 자동으로 생성</li>
      <li>버그 수정 및 코드 최적화 지원</li>
    </ul>
  </li>
  <li><strong>개발 생산성 향상</strong>
    <ul>
      <li>문서 작성 및 검색 시간 단축</li>
      <li>문제 해결 시간 감소</li>
      <li>테스트 코드 자동 생성</li>
    </ul>
  </li>
</ol>

<h2 id="개발자가-준비해야-할-것들">개발자가 준비해야 할 것들</h2>

<h3 id="1-ai-도구-활용-능력">1. AI 도구 활용 능력</h3>
<ul>
  <li>다양한 AI 도구들의 장단점 이해</li>
  <li>적절한 상황에서 AI 도구 활용하기</li>
  <li>AI 생성 코드의 품질 검증 능력</li>
</ul>

<h3 id="2-문제-해결-능력-강화">2. 문제 해결 능력 강화</h3>
<ul>
  <li>복잡한 비즈니스 로직 설계</li>
  <li>시스템 아키텍처 설계</li>
  <li>성능 최적화 및 보안 고려</li>
</ul>

<h3 id="3-소프트-스킬-개발">3. 소프트 스킬 개발</h3>
<ul>
  <li>커뮤니케이션 능력</li>
  <li>팀워크</li>
  <li>프로젝트 관리</li>
</ul>

<h2 id="결론">결론</h2>

<p>AI는 개발자의 일자리를 대체하기보다는, 개발자의 생산성을 높이고 더 복잡한 문제에 집중할 수 있도록 도와주는 도구로 자리잡을 것입니다. 중요한 것은 AI를 두려워하기보다는, AI와 함께 일하는 방법을 배우고, AI가 할 수 없는 고차원적인 문제 해결 능력을 키우는 것입니다.</p>

<h2 id="참고-자료">참고 자료</h2>
<ul>
  <li><a href="https://docs.github.com/en/copilot">GitHub Copilot 공식 문서</a></li>
  <li><a href="https://platform.openai.com/docs">OpenAI API 문서</a></li>
  <li><a href="https://example.com/developer-skills">AI 시대의 개발자 역량</a></li>
</ul>

<blockquote>
  <h4 id="내-생각">내 생각</h4>
  <hr />
</blockquote>

<p>출처를 남겨주는 건 좋다.<br />
그런데 서두 이후 급하게 결론이 난 느낌…<br />
다음부터는 좀 길게 써달라 해야지.<br />
최소 글자 수 제한을 걸어봐야겠다.</p>]]></content><author><name>Claude3.5</name></author><category term="AI-playground/Claude/" /><summary type="html"><![CDATA[본 포스트는 AI가 제작한 포스트입니다. 주제: IT 자유 들어가며 최근 AI 기술의 급속한 발전으로 인해 소프트웨어 개발 분야에서도 큰 변화가 일어나고 있습니다. ChatGPT, GitHub Copilot과 같은 도구들이 개발자의 일상에 깊숙이 자리잡으면서, 많은 개발자들이 “AI가 개발자의 일자리를 대체할까?”라는 질문을 던지고 있습니다. 이 글에서는 AI 시대에 개발자가 어떻게 준비해야 하는지에 대해 이야기해보려 합니다. AI가 가져온 변화 코드 생성의 자동화 GitHub Copilot과 같은 도구들이 코드 작성을 도와줌 반복적인 코드 패턴을 자동으로 생성 버그 수정 및 코드 최적화 지원 개발 생산성 향상 문서 작성 및 검색 시간 단축 문제 해결 시간 감소 테스트 코드 자동 생성 개발자가 준비해야 할 것들 1. AI 도구 활용 능력 다양한 AI 도구들의 장단점 이해 적절한 상황에서 AI 도구 활용하기 AI 생성 코드의 품질 검증 능력 2. 문제 해결 능력 강화 복잡한 비즈니스 로직 설계 시스템 아키텍처 설계 성능 최적화 및 보안 고려 3. 소프트 스킬 개발 커뮤니케이션 능력 팀워크 프로젝트 관리 결론 AI는 개발자의 일자리를 대체하기보다는, 개발자의 생산성을 높이고 더 복잡한 문제에 집중할 수 있도록 도와주는 도구로 자리잡을 것입니다. 중요한 것은 AI를 두려워하기보다는, AI와 함께 일하는 방법을 배우고, AI가 할 수 없는 고차원적인 문제 해결 능력을 키우는 것입니다. 참고 자료 GitHub Copilot 공식 문서 OpenAI API 문서 AI 시대의 개발자 역량 내 생각 출처를 남겨주는 건 좋다. 그런데 서두 이후 급하게 결론이 난 느낌… 다음부터는 좀 길게 써달라 해야지. 최소 글자 수 제한을 걸어봐야겠다.]]></summary></entry><entry><title type="html">프로그래머를 위한 생산성 툴 TOP 5 🧰</title><link href="https://movingwoo.github.io/ai-playground/gpt/2025/04/30/GPT.html" rel="alternate" type="text/html" title="프로그래머를 위한 생산성 툴 TOP 5 🧰" /><published>2025-04-30T03:00:00+00:00</published><updated>2025-04-30T03:00:00+00:00</updated><id>https://movingwoo.github.io/ai-playground/gpt/2025/04/30/GPT</id><content type="html" xml:base="https://movingwoo.github.io/ai-playground/gpt/2025/04/30/GPT.html"><![CDATA[<p><span style="color: red;"><strong>본 포스트는 AI가 제작한 포스트입니다.</strong></span><br />
<span style="color: orange;">주제: IT 자유</span></p>

<hr />

<blockquote>
  <p><strong>“좋은 도구는 개발자의 시간을 아껴준다.”</strong><br />
<em>- 모든 개발자의 마음속 명언</em></p>
</blockquote>

<p>개발은 단순한 코드 작성이 아닌, 문제 해결과 창조적 사고의 연속입니다. 그렇기에 생산성을 높이는 툴은 단순한 ‘보조도구’가 아니라 ‘생산성의 핵심’이라 할 수 있습니다.<br />
이번 포스트에서는 실제 개발자들이 애용하는 툴들 중, 생산성을 크게 향상시켜주는 다섯 가지를 소개합니다.</p>

<hr />

<h2 id="1-visual-studio-code-vs-code">1. <strong>Visual Studio Code (VS Code)</strong></h2>

<ul>
  <li>🌐 https://code.visualstudio.com/</li>
  <li>✨ 확장성이 뛰어난 오픈소스 에디터</li>
  <li>📦 추천 확장 기능:
    <ul>
      <li><em>Prettier</em> (코드 포매터)</li>
      <li><em>GitLens</em> (Git 기록 시각화)</li>
      <li><em>REST Client</em> (API 테스트용)</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>“에디터는 손끝의 무기. 자신에게 맞는 무기를 세팅하라.”</p>
</blockquote>

<hr />

<h2 id="2-raycast">2. <strong>Raycast</strong></h2>

<ul>
  <li>🌐 https://www.raycast.com/</li>
  <li>⌨️ Mac용 명령형 런처 (스팟라이트 업그레이드 버전)</li>
  <li>🧩 다양한 플러그인 &amp; 스크립트 가능</li>
</ul>

<p>💡 <strong>개발자 사용 예시:</strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 로컬 서버 종료</span>
<span class="nv">$ </span>raycast kill-server
</code></pre></div></div>

<hr />

<h2 id="3-notion">3. <strong>Notion</strong></h2>

<ul>
  <li>🌐 https://www.notion.so/</li>
  <li>📝 올인원 워크스페이스</li>
  <li>📌 프로젝트 관리, 문서화, 위키, 회의록 등에 최적화</li>
</ul>

<blockquote>
  <p>개발 문서는 결국 팀의 자산입니다. Notion으로 팀 지식을 구조화하세요.</p>
</blockquote>

<hr />

<h2 id="4-postman">4. <strong>Postman</strong></h2>

<ul>
  <li>🌐 https://www.postman.com/</li>
  <li>🔍 REST API 테스트 및 문서화 도구</li>
  <li>🧪 Collection 단위 테스트 가능</li>
  <li>✅ API 응답 시간, 상태 코드 체크 자동화</li>
</ul>

<hr />

<h2 id="5-tableplus">5. <strong>TablePlus</strong></h2>

<ul>
  <li>🌐 https://tableplus.com/</li>
  <li>🧩 직관적인 DB 클라이언트 (MySQL, PostgreSQL 등 지원)</li>
  <li>💨 빠른 쿼리, 편리한 UI, 로컬/원격 연결 모두 지원</li>
</ul>

<hr />

<h2 id="마치며-">마치며 🧘</h2>

<p>생산성을 높인다는 건 “더 빨리 코딩한다”는 뜻이 아닙니다.<br />
<strong>더 빠르게 이해하고, 더 정확히 실행하며, 더 적게 실수하는 것</strong>입니다.<br />
위 도구들이 여러분의 개발 여정을 한층 더 가볍고 효율적으로 만들어주길 바랍니다.</p>

<hr />

<p>📌 <strong>당신의 생산성 꿀팁은 무엇인가요? 댓글로 공유해주세요!</strong></p>

<blockquote>
  <h4 id="내-생각">내 생각</h4>
  <hr />
</blockquote>

<p>항상 느끼는 거지만 GPT는 이모지가 과하다.<br />
딴 건 이의없는데 왜 DB는 tableplus지? 한 번도 써본 적 없다.<br />
댓글 기능이라…</p>]]></content><author><name>GPT4o</name></author><category term="AI-playground/GPT/" /><summary type="html"><![CDATA[본 포스트는 AI가 제작한 포스트입니다. 주제: IT 자유 “좋은 도구는 개발자의 시간을 아껴준다.” - 모든 개발자의 마음속 명언 개발은 단순한 코드 작성이 아닌, 문제 해결과 창조적 사고의 연속입니다. 그렇기에 생산성을 높이는 툴은 단순한 ‘보조도구’가 아니라 ‘생산성의 핵심’이라 할 수 있습니다. 이번 포스트에서는 실제 개발자들이 애용하는 툴들 중, 생산성을 크게 향상시켜주는 다섯 가지를 소개합니다. 1. Visual Studio Code (VS Code) 🌐 https://code.visualstudio.com/ ✨ 확장성이 뛰어난 오픈소스 에디터 📦 추천 확장 기능: Prettier (코드 포매터) GitLens (Git 기록 시각화) REST Client (API 테스트용) “에디터는 손끝의 무기. 자신에게 맞는 무기를 세팅하라.” 2. Raycast 🌐 https://www.raycast.com/ ⌨️ Mac용 명령형 런처 (스팟라이트 업그레이드 버전) 🧩 다양한 플러그인 &amp; 스크립트 가능 💡 개발자 사용 예시: # 로컬 서버 종료 $ raycast kill-server 3. Notion 🌐 https://www.notion.so/ 📝 올인원 워크스페이스 📌 프로젝트 관리, 문서화, 위키, 회의록 등에 최적화 개발 문서는 결국 팀의 자산입니다. Notion으로 팀 지식을 구조화하세요. 4. Postman 🌐 https://www.postman.com/ 🔍 REST API 테스트 및 문서화 도구 🧪 Collection 단위 테스트 가능 ✅ API 응답 시간, 상태 코드 체크 자동화 5. TablePlus 🌐 https://tableplus.com/ 🧩 직관적인 DB 클라이언트 (MySQL, PostgreSQL 등 지원) 💨 빠른 쿼리, 편리한 UI, 로컬/원격 연결 모두 지원 마치며 🧘 생산성을 높인다는 건 “더 빨리 코딩한다”는 뜻이 아닙니다. 더 빠르게 이해하고, 더 정확히 실행하며, 더 적게 실수하는 것입니다. 위 도구들이 여러분의 개발 여정을 한층 더 가볍고 효율적으로 만들어주길 바랍니다. 📌 당신의 생산성 꿀팁은 무엇인가요? 댓글로 공유해주세요! 내 생각 항상 느끼는 거지만 GPT는 이모지가 과하다. 딴 건 이의없는데 왜 DB는 tableplus지? 한 번도 써본 적 없다. 댓글 기능이라…]]></summary></entry><entry><title type="html">지뢰찾기</title><link href="https://movingwoo.github.io/one-pan/javascript/2025/04/29/Minesweeper.html" rel="alternate" type="text/html" title="지뢰찾기" /><published>2025-04-29T22:00:00+00:00</published><updated>2025-04-29T22:00:00+00:00</updated><id>https://movingwoo.github.io/one-pan/javascript/2025/04/29/Minesweeper</id><content type="html" xml:base="https://movingwoo.github.io/one-pan/javascript/2025/04/29/Minesweeper.html"><![CDATA[<blockquote>
  <h4 id="탄생-비화">탄생 비화</h4>
  <hr />
</blockquote>

<p><span style="color: orange;"><strong>바닐라 JS 재활훈련삼아 투닥투닥 두들겨 봄</strong></span><br />
재활훈련을 마치면 canvas를 이용해 뭐라도 만들어 볼 요량</p>

<blockquote>
  <h4 id="구현-포인트">구현 포인트</h4>
  <hr />
</blockquote>

<h5 id="1-지뢰판-뿌리기">1. 지뢰판 뿌리기</h5>

<p>처음에는 그리드로 대충 만들어 뿌렸는데<br />
뿌려놓고 css가 변경될 경우 리드로우가 일어난다고 한다.<br />
그래서 DOM을 직접 컨트롤하는건 권장하지 않는다고<br />
지뢰찾기 몇 칸 넣는데 영향은 없겠지만 연습삼아 fragment를 사용해본다.</p>

<p>그리고 옛날사람처럼 굴지말고 템플릿 리터럴을 활용하면 더 깔끔해진다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 스타일 설정</span>
<span class="nx">mainArea</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">800px</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">mainArea</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">display</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">grid</span><span class="dl">'</span><span class="p">;</span>
<span class="c1">// 템플릿 리터럴을 사용하지 않으면 보기 지저분하게 + 해가며 써야함</span>
<span class="c1">// mainArea.style.gridTemplateColumns = 'repeat(' + col + ', 1fr)';</span>
<span class="c1">// mainArea.style.gridTemplateColumns = 'repeat(' + row + ', 1fr)';</span>
<span class="nx">mainArea</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">gridTemplateColumns</span> <span class="o">=</span> <span class="s2">`repeat(</span><span class="p">${</span><span class="nx">col</span><span class="p">}</span><span class="s2">, 1fr)`</span><span class="p">;</span>
<span class="nx">mainArea</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">gridTemplateRows</span> <span class="o">=</span> <span class="s2">`repeat(</span><span class="p">${</span><span class="nx">row</span><span class="p">}</span><span class="s2">, 1fr)`</span><span class="p">;</span>
<span class="nx">mainArea</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">gap</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">1px</span><span class="dl">'</span><span class="p">;</span> 
			
<span class="c1">// fragment 생성</span>
<span class="kd">const</span> <span class="nx">divFragment</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createDocumentFragment</span><span class="p">();</span>

<span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">col</span> <span class="o">*</span> <span class="nx">row</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">newDiv</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">currentRow</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nx">i</span> <span class="o">/</span> <span class="nx">col</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">currentCol</span> <span class="o">=</span> <span class="p">(</span><span class="nx">i</span> <span class="o">%</span> <span class="nx">col</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  
  <span class="c1">// 각 div에는 col과 row로 이루어진 고유 값을 id로 설정한다.</span>
  <span class="c1">// col과 row로 고유 id 설정</span>
  <span class="nx">newDiv</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">currentRow</span><span class="p">}</span><span class="s2"> </span><span class="p">${</span><span class="nx">currentCol</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
  
  <span class="c1">// 스타일 설정</span>
  <span class="nx">newDiv</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">aspectRatio</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">1 / 1</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">newDiv</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">border</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">1px solid black</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">newDiv</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">padding</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">1px</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">newDiv</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">display</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">flex</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">newDiv</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">alignItems</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">center</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">newDiv</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">justifyContent</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">center</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">newDiv</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">background</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">gray</span><span class="dl">'</span>

  <span class="c1">// fragment에 추가</span>
  <span class="nx">divFragment</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">newDiv</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// DOM에 추가</span>
<span class="nx">mainArea</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">divFragment</span><span class="p">);</span>
</code></pre></div></div>

<h5 id="2-클릭-감지">2. 클릭 감지</h5>

<p>좌클릭 우클릭은 간단하지만 지뢰찾기는 동시클릭 시 주변에 지뢰가 있을 가능성이 있는 타일을 표시해준다.<br />
따라서 동시클릭을 인식하도록 해야한다.<br />
마우스 좌우를 한 치 오차없이 누르는 건 불가능하기 때문에, 유예시간을 짧게 두고 양쪽이 모두 클릭되어있으면 동시 클릭으로 취급해야한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
마우스 다운 이벤트
*/</span>
<span class="kd">function</span> <span class="nf">MouseDownHandler</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">startTime</span><span class="p">)</span> <span class="nx">startTime</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">();</span> <span class="c1">// 첫 클릭 시간 체크</span>

  <span class="c1">// 클릭한 타겟의 id와 value 획득</span>
  <span class="kd">const</span> <span class="nx">targetId</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">targetValue</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
  <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">targetId</span> <span class="o">||</span> <span class="o">!</span><span class="nx">targetValue</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="c1">// 0은 좌클릭, 2는 우클릭</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">button</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">leftDown</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">button</span> <span class="o">===</span> <span class="mi">2</span><span class="p">)</span> <span class="nx">rightDown</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

  <span class="k">if </span><span class="p">(</span><span class="nx">clickDelay</span><span class="p">)</span> <span class="nf">clearTimeout</span><span class="p">(</span><span class="nx">clickDelay</span><span class="p">);</span> <span class="c1">// 이전 timeout이 있으면 취소</span>

  <span class="nx">clickDelay</span> <span class="o">=</span> <span class="nf">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 변수 불값으로 판단</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">leftDown</span> <span class="o">&amp;&amp;</span> <span class="nx">rightDown</span><span class="p">)</span> <span class="nf">check</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">leftDown</span><span class="p">)</span> <span class="nf">open</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">rightDown</span><span class="p">)</span> <span class="nf">flag</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">);</span>
    
    <span class="c1">// 초기화</span>
    <span class="nx">clickDelay</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">},</span> <span class="mi">50</span><span class="p">);</span> <span class="c1">// 딜레이 50ms</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="3-지뢰-설정">3. 지뢰 설정</h5>

<p>고유의 id를 가지고 있는 판을 만들었으니 지뢰를 배치해야 한다.<br />
지뢰 주변에는 숫자가 표기되어야 하는데, 구조 상 숫자는 0에서 8까지만 쓸 수 있다.<br />
따라서 지뢰를 9로 배치하고 나머지 칸엔 주변 지뢰상황을 파악해 숫자를 매긴다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// set을 이용해 무작위 칸에 value 9를 세팅한다.</span>
<span class="kd">const</span> <span class="nx">divs</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">querySelectorAll</span><span class="p">(</span><span class="dl">'</span><span class="s1">#main_area div</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">mineSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">();</span> <span class="c1">// 중복 방지용 set</span>

<span class="k">while </span><span class="p">(</span><span class="nx">mineSet</span><span class="p">.</span><span class="nx">size</span> <span class="o">&lt;</span> <span class="nx">mines</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 무작위 인덱스 값 생성</span>
  <span class="kd">const</span> <span class="nx">randomIdx</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">col</span> <span class="o">*</span> <span class="nx">row</span><span class="p">);</span>
  
  <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">mineSet</span><span class="p">.</span><span class="nf">has</span><span class="p">(</span><span class="nx">randomIdx</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// set에 집어넣으며 지뢰 세팅</span>
    <span class="nx">mineSet</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">randomIdx</span><span class="p">);</span>
    <span class="nx">divs</span><span class="p">[</span><span class="nx">randomIdx</span><span class="p">].</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 전체 div를 탐색하며 9가 아닌 경우 주변 칸이 9인 개수를 세팅한다.</span>
<span class="nx">divs</span><span class="p">.</span><span class="nf">forEach</span><span class="p">(</span><span class="nx">div</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">div</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">value</span> <span class="o">==</span> <span class="mi">9</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="c1">// 유효한 인접 div 가져오기</span>
  <span class="kd">const</span> <span class="nx">validNeighbors</span> <span class="o">=</span> <span class="nf">findNeighbors</span><span class="p">(</span><span class="nx">div</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>

  <span class="c1">// 유효 범위 내 지뢰 개수 카운팅</span>
  <span class="kd">let</span> <span class="nx">mineCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nx">validNeighbors</span><span class="p">.</span><span class="nf">forEach</span><span class="p">(([</span><span class="nx">r</span><span class="p">,</span> <span class="nx">c</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">neighborDiv</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">r</span><span class="p">}</span><span class="s2"> </span><span class="p">${</span><span class="nx">c</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
      <span class="k">if </span><span class="p">(</span><span class="nx">neighborDiv</span> <span class="o">&amp;&amp;</span> <span class="nx">neighborDiv</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">value</span> <span class="o">==</span> <span class="mi">9</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">mineCount</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">});</span>

  <span class="nx">div</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">mineCount</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></div>

<p>지뢰 제외 숫자를 세팅하기위해 특정 div의 주변 div를 탐색하는 함수를 별도로 만들어준다.<br />
좌클릭으로 칸을 열때, 자동으로 열릴때, 동시클릭 시 등 쓰일 곳이 많은 공통함수이다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
인접 div 탐색
*/</span>
<span class="kd">function</span> <span class="nf">findNeighbors</span><span class="p">(</span><span class="nx">divId</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// id를 파싱해 현재 좌표 확인</span>
  <span class="kd">const</span><span class="p">[</span><span class="nx">currentRow</span><span class="p">,</span> <span class="nx">currentCol</span><span class="p">]</span> <span class="o">=</span> <span class="nx">divId</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">'</span><span class="s1"> </span><span class="dl">'</span><span class="p">).</span><span class="nf">map</span><span class="p">(</span><span class="nb">Number</span><span class="p">);</span>

  <span class="c1">// 인접한 전체 좌표 확인</span>
  <span class="kd">const</span> <span class="nx">neighbors</span> <span class="o">=</span> <span class="p">[</span>
      <span class="p">[</span><span class="nx">currentRow</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">currentCol</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="nx">currentRow</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">currentCol</span><span class="p">],</span> <span class="p">[</span><span class="nx">currentRow</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">currentCol</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
      <span class="p">[</span><span class="nx">currentRow</span>    <span class="p">,</span> <span class="nx">currentCol</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>         <span class="cm">/* 현재 칸 */</span>          <span class="p">[</span><span class="nx">currentRow</span>    <span class="p">,</span> <span class="nx">currentCol</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
      <span class="p">[</span><span class="nx">currentRow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">currentCol</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="nx">currentRow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">currentCol</span><span class="p">],</span> <span class="p">[</span><span class="nx">currentRow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">currentCol</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
  <span class="p">];</span>

  <span class="c1">// 행열 범위를 벗어나면 제외하고 return</span>
  <span class="k">return</span> <span class="nx">neighbors</span><span class="p">.</span><span class="nf">filter</span><span class="p">(([</span><span class="nx">r</span><span class="p">,</span> <span class="nx">c</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="nx">r</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">r</span> <span class="o">&lt;=</span> <span class="nx">row</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">&lt;=</span> <span class="nx">col</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="4-지뢰찾기-기능-부여">4. 지뢰찾기 기능 부여</h5>

<p>좌클릭, 우클릭, 동시클릭 이벤트에 실제 게임 로직을 부여한다.</p>
<ul>
  <li>좌클릭
    <ul>
      <li>지뢰(9)인 경우 게임 오버</li>
      <li>지뢰가 아닌 경우
        <ul>
          <li>0인 경우 인접칸을 자동으로 열기</li>
          <li>0이 아닌 경우 해당 칸만 열기</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>우클릭
    <ul>
      <li>지뢰표시(flag)</li>
      <li>표시된 칸에 다시 우클릭 시 표시 제거</li>
    </ul>
  </li>
  <li>동시클릭
    <ul>
      <li>인접 칸 하이라이팅</li>
      <li>만약 인접 칸 모든 곳에 지뢰가 없는 것이 확실한 경우 자동으로 열기</li>
    </ul>
  </li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 닫힌칸은 회색, 열린칸은 흰색, 플래그는 검정색, 하이라이팅은 파란색, 게임오버 시 지뢰 위치는 빨간색</span>

<span class="cm">/**
좌클릭 시 open
*/</span>
<span class="kd">function</span> <span class="nf">open</span><span class="p">(</span><span class="nx">targetDiv</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// 지뢰칸은 즉시 패배처리</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">targetDiv</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">value</span> <span class="o">==</span> <span class="mi">9</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">youLose</span><span class="p">();</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="nx">targetDiv</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">background</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">;</span>
  
  <span class="c1">// 0인 경우엔 주변 div를 자동으로 열어줌</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">targetDiv</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">findNeighbors</span><span class="p">(</span><span class="nx">targetDiv</span><span class="p">.</span><span class="nx">id</span><span class="p">).</span><span class="nf">forEach</span><span class="p">(([</span><span class="nx">r</span><span class="p">,</span> <span class="nx">c</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">r</span><span class="p">}</span><span class="s2"> </span><span class="p">${</span><span class="nx">c</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
      
      <span class="c1">// 재귀 중 꼬이지 않게 열리지 않은 div만 열기</span>
      <span class="k">if </span><span class="p">(</span><span class="nx">div</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">background</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">gray</span><span class="dl">'</span><span class="p">)</span> <span class="nf">open</span><span class="p">(</span><span class="nx">div</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">targetDiv</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">=</span> <span class="nx">targetDiv</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
  
<span class="p">}</span>

<span class="cm">/**
우클릭 시 flag
*/</span>
<span class="kd">function</span> <span class="nf">flag</span><span class="p">(</span><span class="nx">targetDiv</span><span class="p">)</span> <span class="p">{</span>

  <span class="kd">const</span> <span class="nx">remainDiv</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">#remain</span><span class="dl">'</span><span class="p">);</span>

  <span class="c1">// 닫혀있는 div에 플래그를 추가하며, 플래그가 추가된 칸일 경우 플래그 해제</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">targetDiv</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">background</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">gray</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">targetDiv</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">background</span> <span class="o">=</span><span class="dl">'</span><span class="s1">black</span><span class="dl">'</span><span class="p">;</span>
    <span class="nx">remainDiv</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">remainDiv</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">value</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">targetDiv</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">background</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">targetDiv</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">background</span> <span class="o">=</span><span class="dl">'</span><span class="s1">gray</span><span class="dl">'</span><span class="p">;</span>
    <span class="nx">remainDiv</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">remainDiv</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">value</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>
  
<span class="p">}</span>

<span class="cm">/**
동시클릭 시 check
*/</span>
<span class="kd">function</span> <span class="nf">check</span><span class="p">(</span><span class="nx">targetDiv</span><span class="p">)</span> <span class="p">{</span>

  <span class="kd">const</span> <span class="nx">neighbors</span> <span class="o">=</span> <span class="nf">findNeighbors</span><span class="p">(</span><span class="nx">targetDiv</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
  
  <span class="c1">// 플래그 수</span>
  <span class="kd">let</span> <span class="nx">flagCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  
  <span class="nx">neighbors</span><span class="p">.</span><span class="nf">forEach</span><span class="p">(([</span><span class="nx">r</span><span class="p">,</span> <span class="nx">c</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">r</span><span class="p">}</span><span class="s2"> </span><span class="p">${</span><span class="nx">c</span><span class="p">}</span><span class="s2">`</span><span class="p">).</span><span class="nx">style</span><span class="p">.</span><span class="nx">background</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span><span class="p">)</span> <span class="nx">flagCount</span><span class="o">++</span><span class="p">;</span>
  <span class="p">});</span>
  
  <span class="c1">// 플래그와 지뢰수가 같으면 open, 아니면 주변 칸 반짝</span>
  <span class="c1">// 플래그 잘못 표시하여 자동오픈으로 지뢰 터지는것도 가능함</span>
  <span class="nx">neighbors</span><span class="p">.</span><span class="nf">forEach</span><span class="p">(([</span><span class="nx">r</span><span class="p">,</span> <span class="nx">c</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">r</span><span class="p">}</span><span class="s2"> </span><span class="p">${</span><span class="nx">c</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">div</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">background</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">gray</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if </span><span class="p">(</span><span class="nx">flagCount</span> <span class="o">==</span> <span class="nx">targetDiv</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span> <span class="nf">open</span><span class="p">(</span><span class="nx">div</span><span class="p">);</span>
      <span class="k">else</span> <span class="nx">div</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">background</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">blue</span><span class="dl">'</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="5-승리-및-패배-판정">5. 승리 및 패배 판정</h5>

<p>승리 판정은 매 좌클릭 후 체크한다.<br />
플래그 체크 안하고 클리어할 수 있으므로 판정은 닫혀있는 div 개수가 총 지뢰수와 같으면 승리한 것으로 한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
승리 반별
*/</span>
<span class="kd">function</span> <span class="nf">checkWin</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 닫혀있는 div 개수 세기</span>
  <span class="kd">let</span> <span class="nx">closeCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  
  <span class="nb">document</span><span class="p">.</span><span class="nf">querySelectorAll</span><span class="p">(</span><span class="dl">'</span><span class="s1">#main_area div</span><span class="dl">'</span><span class="p">).</span><span class="nf">forEach</span><span class="p">(</span><span class="nx">div</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">div</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">background</span> <span class="o">!=</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">)</span> <span class="nx">closeCount</span><span class="o">++</span><span class="p">;</span>
  <span class="p">});</span>
  
  <span class="c1">// 총 지뢰 수와 닫혀있는 div 수가 같으면 승리</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">closeCount</span> <span class="o">===</span> <span class="nx">mines</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">youWin</span><span class="p">();</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**
승리 처리
*/</span>
<span class="kd">function</span> <span class="nf">youWin</span><span class="p">()</span> <span class="p">{</span>

  <span class="kd">const</span> <span class="nx">endTime</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">();</span> <span class="c1">// 종료시간</span>
  <span class="kd">const</span> <span class="nx">elapsedTime</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">((</span><span class="nx">endTime</span> <span class="o">-</span> <span class="nx">startTime</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">);</span> <span class="c1">// 경과 시간 초 단위</span>
  
  <span class="c1">// 승자에 대한 찬사</span>
  <span class="nf">alert</span><span class="p">(</span><span class="s2">`You Win!!\n</span><span class="p">${</span><span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nx">elapsedTime</span> <span class="o">/</span> <span class="mi">60</span><span class="p">)}</span><span class="s2">분 </span><span class="p">${</span><span class="nx">elapsedTime</span> <span class="o">%</span> <span class="mi">60</span><span class="p">}</span><span class="s2">초`</span><span class="p">);</span>
  
  <span class="c1">// 마우스 이벤트 제거</span>
  <span class="nb">document</span><span class="p">.</span><span class="nf">removeEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">mousedown</span><span class="dl">'</span><span class="p">,</span> <span class="nx">MouseDownHandler</span><span class="p">);</span>
  <span class="nb">document</span><span class="p">.</span><span class="nf">removeEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">mouseup</span><span class="dl">'</span><span class="p">,</span> <span class="nx">MouseUpHandler</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**
패배 처리
*/</span>
<span class="kd">function</span> <span class="nf">youLose</span><span class="p">()</span> <span class="p">{</span>

  <span class="c1">// 패배자에 대한 조롱</span>
  <span class="nf">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">You Lose!!</span><span class="dl">'</span><span class="p">);</span>
  
  <span class="c1">// 모든 보드 열기</span>
  <span class="nb">document</span><span class="p">.</span><span class="nf">querySelectorAll</span><span class="p">(</span><span class="dl">'</span><span class="s1">#main_area div</span><span class="dl">'</span><span class="p">).</span><span class="nf">forEach</span><span class="p">(</span><span class="nx">div</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">div</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">value</span> <span class="o">==</span> <span class="mi">9</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 지뢰 위치는 빨간색으로 표시</span>
      <span class="nx">div</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">background</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">red</span><span class="dl">'</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">div</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">background</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">;</span>
      <span class="nx">div</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">=</span> <span class="nx">div</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">});</span>
  
  <span class="c1">// 마우스 이벤트 제거</span>
  <span class="nb">document</span><span class="p">.</span><span class="nf">removeEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">mousedown</span><span class="dl">'</span><span class="p">,</span> <span class="nx">MouseDownHandler</span><span class="p">);</span>
  <span class="nb">document</span><span class="p">.</span><span class="nf">removeEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">mouseup</span><span class="dl">'</span><span class="p">,</span> <span class="nx">MouseUpHandler</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="완성">완성</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/one-pan/JavaScript/2025-04-30-Minesweeper/img01.jpg" alt="img01" /></p>

<p>이지선다 지옥…</p>

<p><img src="/assets/images/posts/one-pan/JavaScript/2025-04-30-Minesweeper/img02.jpg" alt="img02" /></p>

<p><span style="color: red;"><strong>크아아아아아아아악</strong></span></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<ol>
  <li>
    <p><strong>DOM 직접 컨트롤 피하기</strong><br />
이유는 상술</p>
  </li>
  <li>
    <p>디자인 및 접근성<br />
뭔가 더 예쁘고 접근성 좋게 처리할 수 있었을 거란 아쉬움이 남는다<br />
div 사이 빈 줄도 없앨 수 있었을텐데…<br />
AI도 잘 되어있는 세상인데…</p>
  </li>
</ol>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="/play/Minesweeper.html" target="_blank" rel="noopener noreferrer">
  직접 해보기
</a></p>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-04-30-Minesweeper.html">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="one-pan/JavaScript/" /><summary type="html"><![CDATA[탄생 비화 바닐라 JS 재활훈련삼아 투닥투닥 두들겨 봄 재활훈련을 마치면 canvas를 이용해 뭐라도 만들어 볼 요량 구현 포인트 1. 지뢰판 뿌리기 처음에는 그리드로 대충 만들어 뿌렸는데 뿌려놓고 css가 변경될 경우 리드로우가 일어난다고 한다. 그래서 DOM을 직접 컨트롤하는건 권장하지 않는다고 지뢰찾기 몇 칸 넣는데 영향은 없겠지만 연습삼아 fragment를 사용해본다. 그리고 옛날사람처럼 굴지말고 템플릿 리터럴을 활용하면 더 깔끔해진다. // 스타일 설정 mainArea.style.width = '800px'; mainArea.style.display = 'grid'; // 템플릿 리터럴을 사용하지 않으면 보기 지저분하게 + 해가며 써야함 // mainArea.style.gridTemplateColumns = 'repeat(' + col + ', 1fr)'; // mainArea.style.gridTemplateColumns = 'repeat(' + row + ', 1fr)'; mainArea.style.gridTemplateColumns = `repeat(${col}, 1fr)`; mainArea.style.gridTemplateRows = `repeat(${row}, 1fr)`; mainArea.style.gap = '1px'; // fragment 생성 const divFragment = document.createDocumentFragment(); for (let i = 0; i &lt; col * row; i++) { const newDiv = document.createElement('div'); const currentRow = Math.floor(i / col) + 1; const currentCol = (i % col) + 1; // 각 div에는 col과 row로 이루어진 고유 값을 id로 설정한다. // col과 row로 고유 id 설정 newDiv.id = `${currentRow} ${currentCol}`; // 스타일 설정 newDiv.style.aspectRatio = '1 / 1'; newDiv.style.border = '1px solid black'; newDiv.style.padding = '1px'; newDiv.style.display = 'flex'; newDiv.style.alignItems = 'center'; newDiv.style.justifyContent = 'center'; newDiv.style.background = 'gray' // fragment에 추가 divFragment.appendChild(newDiv); } // DOM에 추가 mainArea.appendChild(divFragment); 2. 클릭 감지 좌클릭 우클릭은 간단하지만 지뢰찾기는 동시클릭 시 주변에 지뢰가 있을 가능성이 있는 타일을 표시해준다. 따라서 동시클릭을 인식하도록 해야한다. 마우스 좌우를 한 치 오차없이 누르는 건 불가능하기 때문에, 유예시간을 짧게 두고 양쪽이 모두 클릭되어있으면 동시 클릭으로 취급해야한다. /** 마우스 다운 이벤트 */ function MouseDownHandler(event) { if (!startTime) startTime = new Date(); // 첫 클릭 시간 체크 // 클릭한 타겟의 id와 value 획득 const targetId = event.target.id; const targetValue = event.target.dataset.value; if (!targetId || !targetValue) return; // 0은 좌클릭, 2는 우클릭 if (event.button === 0) leftDown = true; else if (event.button === 2) rightDown = true; if (clickDelay) clearTimeout(clickDelay); // 이전 timeout이 있으면 취소 clickDelay = setTimeout(() =&gt; { // 변수 불값으로 판단 if (leftDown &amp;&amp; rightDown) check(event.target); else if (leftDown) open(event.target); else if (rightDown) flag(event.target); // 초기화 clickDelay = null; }, 50); // 딜레이 50ms } 3. 지뢰 설정 고유의 id를 가지고 있는 판을 만들었으니 지뢰를 배치해야 한다. 지뢰 주변에는 숫자가 표기되어야 하는데, 구조 상 숫자는 0에서 8까지만 쓸 수 있다. 따라서 지뢰를 9로 배치하고 나머지 칸엔 주변 지뢰상황을 파악해 숫자를 매긴다. // set을 이용해 무작위 칸에 value 9를 세팅한다. const divs = document.querySelectorAll('#main_area div'); const mineSet = new Set(); // 중복 방지용 set while (mineSet.size &lt; mines) { // 무작위 인덱스 값 생성 const randomIdx = Math.floor(Math.random() * col * row); if (!mineSet.has(randomIdx)) { // set에 집어넣으며 지뢰 세팅 mineSet.add(randomIdx); divs[randomIdx].dataset.value = 9; } } // 전체 div를 탐색하며 9가 아닌 경우 주변 칸이 9인 개수를 세팅한다. divs.forEach(div =&gt; { if (div.dataset.value == 9) return; // 유효한 인접 div 가져오기 const validNeighbors = findNeighbors(div.id); // 유효 범위 내 지뢰 개수 카운팅 let mineCount = 0; validNeighbors.forEach(([r, c]) =&gt; { const neighborDiv = document.getElementById(`${r} ${c}`); if (neighborDiv &amp;&amp; neighborDiv.dataset.value == 9) { mineCount++; } }); div.dataset.value = mineCount; }); 지뢰 제외 숫자를 세팅하기위해 특정 div의 주변 div를 탐색하는 함수를 별도로 만들어준다. 좌클릭으로 칸을 열때, 자동으로 열릴때, 동시클릭 시 등 쓰일 곳이 많은 공통함수이다. /** 인접 div 탐색 */ function findNeighbors(divId) { // id를 파싱해 현재 좌표 확인 const[currentRow, currentCol] = divId.split(' ').map(Number); // 인접한 전체 좌표 확인 const neighbors = [ [currentRow - 1, currentCol - 1], [currentRow - 1, currentCol], [currentRow - 1, currentCol + 1], [currentRow , currentCol - 1], /* 현재 칸 */ [currentRow , currentCol + 1], [currentRow + 1, currentCol - 1], [currentRow + 1, currentCol], [currentRow + 1, currentCol + 1] ]; // 행열 범위를 벗어나면 제외하고 return return neighbors.filter(([r, c]) =&gt; r &gt;= 1 &amp;&amp; r &lt;= row &amp;&amp; c &gt;= 1 &amp;&amp; c &lt;= col); } 4. 지뢰찾기 기능 부여 좌클릭, 우클릭, 동시클릭 이벤트에 실제 게임 로직을 부여한다. 좌클릭 지뢰(9)인 경우 게임 오버 지뢰가 아닌 경우 0인 경우 인접칸을 자동으로 열기 0이 아닌 경우 해당 칸만 열기 우클릭 지뢰표시(flag) 표시된 칸에 다시 우클릭 시 표시 제거 동시클릭 인접 칸 하이라이팅 만약 인접 칸 모든 곳에 지뢰가 없는 것이 확실한 경우 자동으로 열기 // 닫힌칸은 회색, 열린칸은 흰색, 플래그는 검정색, 하이라이팅은 파란색, 게임오버 시 지뢰 위치는 빨간색 /** 좌클릭 시 open */ function open(targetDiv) { // 지뢰칸은 즉시 패배처리 if (targetDiv.dataset.value == 9) { youLose(); return; } targetDiv.style.background = 'white'; // 0인 경우엔 주변 div를 자동으로 열어줌 if (targetDiv.dataset.value == 0) { findNeighbors(targetDiv.id).forEach(([r, c]) =&gt; { const div = document.getElementById(`${r} ${c}`); // 재귀 중 꼬이지 않게 열리지 않은 div만 열기 if (div.style.background == 'gray') open(div); }); } else { targetDiv.textContent = targetDiv.dataset.value; } } /** 우클릭 시 flag */ function flag(targetDiv) { const remainDiv = document.querySelector('#remain'); // 닫혀있는 div에 플래그를 추가하며, 플래그가 추가된 칸일 경우 플래그 해제 if (targetDiv.style.background == 'gray') { targetDiv.style.background ='black'; remainDiv.dataset.value = remainDiv.dataset.value - 1; } else if (targetDiv.style.background == 'black') { targetDiv.style.background ='gray'; remainDiv.dataset.value = remainDiv.dataset.value - 1 + 2; } } /** 동시클릭 시 check */ function check(targetDiv) { const neighbors = findNeighbors(targetDiv.id); // 플래그 수 let flagCount = 0; neighbors.forEach(([r, c]) =&gt; { if (document.getElementById(`${r} ${c}`).style.background == 'black') flagCount++; }); // 플래그와 지뢰수가 같으면 open, 아니면 주변 칸 반짝 // 플래그 잘못 표시하여 자동오픈으로 지뢰 터지는것도 가능함 neighbors.forEach(([r, c]) =&gt; { const div = document.getElementById(`${r} ${c}`); if (div.style.background == 'gray') { if (flagCount == targetDiv.dataset.value) open(div); else div.style.background = 'blue' } }); } 5. 승리 및 패배 판정 승리 판정은 매 좌클릭 후 체크한다. 플래그 체크 안하고 클리어할 수 있으므로 판정은 닫혀있는 div 개수가 총 지뢰수와 같으면 승리한 것으로 한다. /** 승리 반별 */ function checkWin() { // 닫혀있는 div 개수 세기 let closeCount = 0; document.querySelectorAll('#main_area div').forEach(div =&gt; { if (div.style.background != 'white') closeCount++; }); // 총 지뢰 수와 닫혀있는 div 수가 같으면 승리 if (closeCount === mines) { youWin(); return; } } /** 승리 처리 */ function youWin() { const endTime = new Date(); // 종료시간 const elapsedTime = Math.floor((endTime - startTime) / 1000); // 경과 시간 초 단위 // 승자에 대한 찬사 alert(`You Win!!\n${Math.floor(elapsedTime / 60)}분 ${elapsedTime % 60}초`); // 마우스 이벤트 제거 document.removeEventListener('mousedown', MouseDownHandler); document.removeEventListener('mouseup', MouseUpHandler); } /** 패배 처리 */ function youLose() { // 패배자에 대한 조롱 alert('You Lose!!'); // 모든 보드 열기 document.querySelectorAll('#main_area div').forEach(div =&gt; { if (div.dataset.value == 9) { // 지뢰 위치는 빨간색으로 표시 div.style.background = 'red'; } else { div.style.background = 'white'; div.textContent = div.dataset.value; } }); // 마우스 이벤트 제거 document.removeEventListener('mousedown', MouseDownHandler); document.removeEventListener('mouseup', MouseUpHandler); } 완성 이지선다 지옥… 크아아아아아아아악 반성 DOM 직접 컨트롤 피하기 이유는 상술 디자인 및 접근성 뭔가 더 예쁘고 접근성 좋게 처리할 수 있었을 거란 아쉬움이 남는다 div 사이 빈 줄도 없앨 수 있었을텐데… AI도 잘 되어있는 세상인데… 코드 확인 직접 해보기 Link to GitHub]]></summary></entry><entry><title type="html">간단한 서버 관리 콘솔</title><link href="https://movingwoo.github.io/one-pan/shellscript/2025/04/28/Server-Manage-Console.html" rel="alternate" type="text/html" title="간단한 서버 관리 콘솔" /><published>2025-04-28T11:00:00+00:00</published><updated>2025-04-28T11:00:00+00:00</updated><id>https://movingwoo.github.io/one-pan/shellscript/2025/04/28/Server%20Manage%20Console</id><content type="html" xml:base="https://movingwoo.github.io/one-pan/shellscript/2025/04/28/Server-Manage-Console.html"><![CDATA[<blockquote>
  <h4 id="탄생-비화">탄생 비화</h4>
  <hr />
</blockquote>

<p>WSL 환경에서 tomcat과 jdk를 버전별로 올려 테스트 중 문제 발생<br />
윈도우 IP로 접속 시 WSL과 바로 연결이 안됨<br />
<span style="color: orange;">ㄴ <strong>포트 매핑이 필요하다.</strong></span></p>

<p>모든 톰캣의 포트를 일일이 매핑시키기 귀찮음<br />
<span style="color: orange;">ㄴ <strong>nginx를 올려 443번만 뚫고 각 톰캣 http 포트로 매핑</strong></span></p>

<p>설정 일일히 하기 귀찮아서 톰캣 8080 포트 통일<br />
일일이 경로 찾아가서 끄고 키기 귀찮아짐<br />
alternatives 로 jdk 버전 바꾸는 것도 귀찮음<br />
<span style="color: orange;">ㄴ <strong>그냥 간단한 shell script 작성해 때우자!</strong></span></p>

<blockquote>
  <h4 id="구현-포인트">구현 포인트</h4>
  <hr />
</blockquote>

<h5 id="1-메뉴-틀-작성">1. 메뉴 틀 작성</h5>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 메뉴가 계속 돌아야 하므로 반복문 안에 집어넣는다</span>
<span class="k">while </span><span class="nb">true</span><span class="p">;</span> <span class="k">do
  </span>clear <span class="c"># 계속 쌓이므로 돌아올때 clear</span>
	
  <span class="c"># 숫자와 함께 메뉴 틀 작성</span>
  <span class="nb">echo</span> <span class="s2">"=========================="</span>
  <span class="nb">echo</span> <span class="s2">"      Manage Console"</span>
  <span class="nb">echo</span> <span class="s2">"--------------------------"</span>
  <span class="nb">echo</span> <span class="s2">"00. Refresh"</span>
  <span class="nb">echo</span> <span class="s2">"11. JDK"</span>
  <span class="nb">echo</span> <span class="s2">"21. Nginx"</span>
  <span class="nb">echo</span> <span class="s2">"... 중략 ..."</span>
  <span class="nb">echo</span> <span class="s2">"Else. Exit"</span>
  <span class="nb">echo</span> <span class="s2">"=========================="</span>
  <span class="nb">echo</span> <span class="nt">-n</span> <span class="s2">"&gt;&gt; "</span>

  <span class="nb">read </span>choice
	
  <span class="c"># 입력 받아서 분기</span>
  <span class="k">case</span> <span class="nv">$choice</span> <span class="k">in
    </span>00<span class="p">)</span>
      <span class="p">;;</span>
    11<span class="p">)</span>
      <span class="p">;;</span>
    21<span class="p">)</span>
      <span class="p">;;</span>
    <span class="k">*</span><span class="p">)</span>
      <span class="nb">exit </span>0
      <span class="p">;;</span>
  <span class="k">esac</span>
<span class="k">done</span>
</code></pre></div></div>

<h5 id="2-기동-및-중단-완료-판단">2. 기동 및 중단 완료 판단</h5>

<ul>
  <li>docker
    <ul>
      <li>start 시 컨테이너 완전 기동 판단을 위해 docker compose 사용 등을 고려해야함 -&gt; 귀찮으니 그냥 start 후 기동 처리</li>
      <li>stop 시 프로세스 사라지면 중단 처리</li>
    </ul>
  </li>
  <li>nginx
    <ul>
      <li>nginx 헬스체크 페이지를 만들어두고 curl 호출해서 200 성공 시 기동 처리</li>
      <li>종료 시 프로세스 확인</li>
    </ul>
  </li>
  <li>tomcat
    <ul>
      <li>ROOT 페이지를 남겨두고 curl 호출해서 200 성공 시 기동 처리</li>
      <li>종료 시 프로세스 확인</li>
    </ul>
  </li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 프로세스가 올라올 때까지 기다리는 함수</span>
wait_service_process<span class="o">()</span> <span class="o">{</span>
  <span class="k">while </span><span class="nb">true</span><span class="p">;</span> <span class="k">do
    if </span>ps <span class="nt">-aux</span> | <span class="nb">grep</span> <span class="nt">-E</span> <span class="s2">"grep 할 단어"</span> | <span class="nb">grep</span> <span class="nt">-v</span> <span class="nb">grep</span> <span class="o">&gt;</span> /dev/null<span class="p">;</span> <span class="k">then
      return
    else
      </span><span class="nb">sleep </span>1
    <span class="k">fi
  done</span>
<span class="o">}</span>

<span class="c"># curl 성공할 때까지 기다리는 함수</span>
wait_service_curl<span class="o">()</span> <span class="o">{</span>
  <span class="k">if </span>ps <span class="nt">-aux</span> | <span class="nb">grep</span> <span class="nt">-E</span> <span class="s2">"grep 할 단어"</span> | <span class="nb">grep</span> <span class="nt">-v</span> <span class="nb">grep</span> <span class="o">&gt;</span> /dev/null<span class="p">;</span> <span class="k">then
    while </span><span class="nb">true</span><span class="p">;</span> <span class="k">do</span>  
      <span class="c"># http status만 200인지 확인</span>
      <span class="nv">http_status</span><span class="o">=</span><span class="si">$(</span>curl <span class="nt">-s</span> <span class="nt">-o</span> /dev/null <span class="nt">-w</span> <span class="s2">"%{http_code}"</span> <span class="nt">-L</span> <span class="nt">-k</span> <span class="nt">--connect-timeout</span> 5 <span class="nt">--max-time</span> 5 https://localhost:8080/<span class="si">)</span>
			
      <span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$http_status</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"200"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
        return
      else
        </span><span class="nb">sleep </span>1
      <span class="k">fi
    done
  fi</span>
<span class="o">}</span>
</code></pre></div></div>

<h5 id="3-로딩-처리">3. 로딩 처리</h5>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 로딩 애니메이션 함수</span>
loading_animation<span class="o">()</span> <span class="o">{</span>
  <span class="nv">frames</span><span class="o">=(</span><span class="s1">'-'</span> <span class="s1">'\'</span> <span class="s1">'|'</span> <span class="s1">'/'</span><span class="o">)</span>
	
  <span class="k">while </span><span class="nb">true</span><span class="p">;</span> <span class="k">do
    for </span>frame <span class="k">in</span> <span class="s2">"</span><span class="k">${</span><span class="nv">frames</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">do</span>
      <span class="c"># 0.2초마다 노란색 프레임이 돌아간다</span>
      <span class="nb">echo</span> <span class="nt">-ne</span> <span class="s2">"</span><span class="se">\r\e</span><span class="s2">[33mLoading... </span><span class="nv">$frame</span><span class="s2"> </span><span class="se">\0</span><span class="s2">33[K</span><span class="se">\e</span><span class="s2">[0m"</span>
      <span class="nb">sleep </span>0.2
    <span class="k">done
  done</span>
<span class="o">}</span>

<span class="c"># 서비스 시작 시 </span>
start_service<span class="o">()</span> <span class="o">{</span>
  <span class="c"># 로딩 중 입력을 막고 애니메이션을 시작한다.</span>
  <span class="nb">stty</span> <span class="nt">-echo</span> <span class="nt">-icanon</span>
  loading_animation &amp;
  <span class="nv">animation_pid</span><span class="o">=</span><span class="nv">$!</span>

  <span class="c"># ... 중략 ...</span>

  <span class="c"># 완료 후 애니메이션을 종료하고 입력버퍼를 비운다.</span>
  <span class="nb">kill</span> <span class="nv">$animation_pid</span> 2&gt;/dev/null
  <span class="nb">wait</span> <span class="nv">$animation_pid</span> 2&gt;/dev/null
  <span class="k">while </span><span class="nb">read</span> <span class="nt">-t</span> 0.1 <span class="nt">-n</span> 10000<span class="p">;</span> <span class="k">do</span> : <span class="p">;</span> <span class="k">done
  </span><span class="nb">stty echo </span>icanon

  <span class="c"># 서비스 종료도 마찬가지로 처리</span>
<span class="o">}</span>
</code></pre></div></div>

<h5 id="4-jdk-변경-처리">4. jdk 변경 처리</h5>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># JDK 버전 변경 함수</span>
switch_jdk_version<span class="o">()</span> <span class="o">{</span>
  <span class="c"># ... 전략 ...</span>
	
  <span class="c"># 설치된 자바 목록은 alternatives로 가져와서 보여준다</span>
  <span class="nv">JAVA_PATHS</span><span class="o">=(</span><span class="si">$(</span>alternatives <span class="nt">--display</span> java | <span class="nb">grep</span> <span class="nt">-E</span> <span class="s1">'^/usr'</span> | <span class="nb">awk</span> <span class="s1">'{print $1}'</span><span class="si">)</span><span class="o">)</span>

  <span class="nv">i</span><span class="o">=</span>1
  <span class="k">for </span>path <span class="k">in</span> <span class="s2">"</span><span class="k">${</span><span class="nv">JAVA_PATHS</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">do
    </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$i</span><span class="s2">. </span><span class="nv">$path</span><span class="s2">"</span>
    <span class="o">((</span>i++<span class="o">))</span>
  <span class="k">done</span>

  <span class="c"># ... 중략 ...</span>
	
  <span class="c"># 버전마다 내부 경로가 다르다 (특히 1.8이 문제)</span>
  <span class="c"># jre 경로에서 javac을 찾는데 없을 경우 상위 bin 폴더에서 javac을 찾는다</span>
  <span class="nv">SELECTED_PATH</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">JAVA_PATHS</span><span class="p">[</span><span class="k">$((</span>num-1<span class="k">))</span><span class="p">]</span><span class="k">}</span><span class="s2">"</span>
  <span class="nv">SELECTED_DIR</span><span class="o">=</span><span class="si">$(</span><span class="nb">dirname</span> <span class="s2">"</span><span class="nv">$SELECTED_PATH</span><span class="s2">"</span><span class="si">)</span>
  <span class="nv">JAVAC_PATH</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">SELECTED_DIR</span><span class="k">}</span><span class="s2">/javac"</span>
	
  <span class="k">if</span> <span class="o">[</span> <span class="o">!</span> <span class="nt">-f</span> <span class="s2">"</span><span class="nv">$JAVAC_PATH</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nv">PARENT_DIR</span><span class="o">=</span><span class="si">$(</span><span class="nb">dirname</span> <span class="s2">"</span><span class="nv">$SELECTED_DIR</span><span class="s2">"</span><span class="si">)</span>
    <span class="nv">GRAND_PARENT_DIR</span><span class="o">=</span><span class="si">$(</span><span class="nb">dirname</span> <span class="s2">"</span><span class="nv">$PARENT_DIR</span><span class="s2">"</span><span class="si">)</span> 
    <span class="nv">JAVAC_PATH</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">GRAND_PARENT_DIR</span><span class="k">}</span><span class="s2">/bin/javac"</span>
  <span class="k">fi</span>

  <span class="c"># ... 중략 ...</span>
	
  <span class="c"># alternatives를 이용해서 선택한 경로의 java와 javac으로 바꾼다</span>
  alternatives <span class="nt">--set</span> java <span class="s2">"</span><span class="nv">$SELECTED_PATH</span><span class="s2">"</span>
  alternatives <span class="nt">--set</span> javac <span class="s2">"</span><span class="nv">$JAVAC_PATH</span><span class="s2">"</span>
<span class="o">}</span>
</code></pre></div></div>

<h5 id="5-변수-설정">5. 변수 설정</h5>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 가능한한 추후 쉽게 변동될만한 부분은 변수부로 뺀다</span>
<span class="c"># NGINX ENV</span>
<span class="nb">export </span><span class="nv">NGINX_GREP</span><span class="o">=</span>nginx: master
<span class="nb">export </span><span class="nv">NGINX_PORT</span><span class="o">=</span>443
<span class="nb">export </span><span class="nv">NGINX_URL</span><span class="o">=</span>/health

<span class="c"># TOMCAT10 ENV</span>
<span class="nb">export </span><span class="nv">TOMCAT10_PATH</span><span class="o">=</span>/app/tomcat10.1.9
<span class="nb">export </span><span class="nv">TOMCAT10_GREP</span><span class="o">=</span>app/tomcat10.1.9
<span class="nb">export </span><span class="nv">TOMCAT10_PORT</span><span class="o">=</span>8080
<span class="nb">export </span><span class="nv">TOMCAT10_URL</span><span class="o">=</span>
<span class="c"># ... 후략 ...</span>
</code></pre></div></div>

<blockquote>
  <h4 id="완성">완성</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/one-pan/ShellScript/2025-04-28-Server Manage Console/img01.jpg" alt="img01" /></p>

<p>각 프로세스 현 상황과 jdk 버전을 한 눈에 확인하기 위한 상태 확인 코드를 추가하고 기동<br />
메뉴 별 번호를 입력시 기동/중단을 즉시 수행한다</p>

<p><img src="/assets/images/posts/one-pan/ShellScript/2025-04-28-Server Manage Console/img02.jpg" alt="img02" /></p>

<p>메뉴 선택 시 로딩화면과 함께 기동/중단이 진행된다</p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>대충 뚝딱 만들었다보니 고칠 수 있는 부분이 많이 보인다</p>

<ol>
  <li>
    <p>메뉴 선택 시<br />
메뉴의 디자인을 단순하게 유지한다면 <strong>idx를 잡고 반복문</strong>을 돌리는 것으로 코드를 줄일 수 있다</p>
  </li>
  <li>
    <p>기동/중단 시<br />
<strong>메뉴 선택시 start / stop</strong> 을 넘기면 중복 코드를 제거할 수 있다</p>
  </li>
  <li>
    <p>환경변수<br />
<strong>배열로 설정</strong>하고 배열을 가져와서 빼 쓰면 코드를 많이 줄일 수 있다<br />
1번 내용과 함께할 시 하드코딩된 부분을 상당수 제거 가능하다</p>
  </li>
</ol>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/ShellScript/2025-04-28-Server%20Manage%20Console.sh">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="one-pan/ShellScript/" /><summary type="html"><![CDATA[탄생 비화 WSL 환경에서 tomcat과 jdk를 버전별로 올려 테스트 중 문제 발생 윈도우 IP로 접속 시 WSL과 바로 연결이 안됨 ㄴ 포트 매핑이 필요하다. 모든 톰캣의 포트를 일일이 매핑시키기 귀찮음 ㄴ nginx를 올려 443번만 뚫고 각 톰캣 http 포트로 매핑 설정 일일히 하기 귀찮아서 톰캣 8080 포트 통일 일일이 경로 찾아가서 끄고 키기 귀찮아짐 alternatives 로 jdk 버전 바꾸는 것도 귀찮음 ㄴ 그냥 간단한 shell script 작성해 때우자! 구현 포인트 1. 메뉴 틀 작성 # 메뉴가 계속 돌아야 하므로 반복문 안에 집어넣는다 while true; do clear # 계속 쌓이므로 돌아올때 clear # 숫자와 함께 메뉴 틀 작성 echo "==========================" echo " Manage Console" echo "--------------------------" echo "00. Refresh" echo "11. JDK" echo "21. Nginx" echo "... 중략 ..." echo "Else. Exit" echo "==========================" echo -n "&gt;&gt; " read choice # 입력 받아서 분기 case $choice in 00) ;; 11) ;; 21) ;; *) exit 0 ;; esac done 2. 기동 및 중단 완료 판단 docker start 시 컨테이너 완전 기동 판단을 위해 docker compose 사용 등을 고려해야함 -&gt; 귀찮으니 그냥 start 후 기동 처리 stop 시 프로세스 사라지면 중단 처리 nginx nginx 헬스체크 페이지를 만들어두고 curl 호출해서 200 성공 시 기동 처리 종료 시 프로세스 확인 tomcat ROOT 페이지를 남겨두고 curl 호출해서 200 성공 시 기동 처리 종료 시 프로세스 확인 # 프로세스가 올라올 때까지 기다리는 함수 wait_service_process() { while true; do if ps -aux | grep -E "grep 할 단어" | grep -v grep &gt; /dev/null; then return else sleep 1 fi done } # curl 성공할 때까지 기다리는 함수 wait_service_curl() { if ps -aux | grep -E "grep 할 단어" | grep -v grep &gt; /dev/null; then while true; do # http status만 200인지 확인 http_status=$(curl -s -o /dev/null -w "%{http_code}" -L -k --connect-timeout 5 --max-time 5 https://localhost:8080/) if [ "$http_status" = "200" ]; then return else sleep 1 fi done fi } 3. 로딩 처리 # 로딩 애니메이션 함수 loading_animation() { frames=('-' '\' '|' '/') while true; do for frame in "${frames[@]}"; do # 0.2초마다 노란색 프레임이 돌아간다 echo -ne "\r\e[33mLoading... $frame \033[K\e[0m" sleep 0.2 done done } # 서비스 시작 시 start_service() { # 로딩 중 입력을 막고 애니메이션을 시작한다. stty -echo -icanon loading_animation &amp; animation_pid=$! # ... 중략 ... # 완료 후 애니메이션을 종료하고 입력버퍼를 비운다. kill $animation_pid 2&gt;/dev/null wait $animation_pid 2&gt;/dev/null while read -t 0.1 -n 10000; do : ; done stty echo icanon # 서비스 종료도 마찬가지로 처리 } 4. jdk 변경 처리 # JDK 버전 변경 함수 switch_jdk_version() { # ... 전략 ... # 설치된 자바 목록은 alternatives로 가져와서 보여준다 JAVA_PATHS=($(alternatives --display java | grep -E '^/usr' | awk '{print $1}')) i=1 for path in "${JAVA_PATHS[@]}"; do echo "$i. $path" ((i++)) done # ... 중략 ... # 버전마다 내부 경로가 다르다 (특히 1.8이 문제) # jre 경로에서 javac을 찾는데 없을 경우 상위 bin 폴더에서 javac을 찾는다 SELECTED_PATH="${JAVA_PATHS[$((num-1))]}" SELECTED_DIR=$(dirname "$SELECTED_PATH") JAVAC_PATH="${SELECTED_DIR}/javac" if [ ! -f "$JAVAC_PATH" ]; then PARENT_DIR=$(dirname "$SELECTED_DIR") GRAND_PARENT_DIR=$(dirname "$PARENT_DIR") JAVAC_PATH="${GRAND_PARENT_DIR}/bin/javac" fi # ... 중략 ... # alternatives를 이용해서 선택한 경로의 java와 javac으로 바꾼다 alternatives --set java "$SELECTED_PATH" alternatives --set javac "$JAVAC_PATH" } 5. 변수 설정 # 가능한한 추후 쉽게 변동될만한 부분은 변수부로 뺀다 # NGINX ENV export NGINX_GREP=nginx: master export NGINX_PORT=443 export NGINX_URL=/health # TOMCAT10 ENV export TOMCAT10_PATH=/app/tomcat10.1.9 export TOMCAT10_GREP=app/tomcat10.1.9 export TOMCAT10_PORT=8080 export TOMCAT10_URL= # ... 후략 ... 완성 각 프로세스 현 상황과 jdk 버전을 한 눈에 확인하기 위한 상태 확인 코드를 추가하고 기동 메뉴 별 번호를 입력시 기동/중단을 즉시 수행한다 메뉴 선택 시 로딩화면과 함께 기동/중단이 진행된다 반성 대충 뚝딱 만들었다보니 고칠 수 있는 부분이 많이 보인다 메뉴 선택 시 메뉴의 디자인을 단순하게 유지한다면 idx를 잡고 반복문을 돌리는 것으로 코드를 줄일 수 있다 기동/중단 시 메뉴 선택시 start / stop 을 넘기면 중복 코드를 제거할 수 있다 환경변수 배열로 설정하고 배열을 가져와서 빼 쓰면 코드를 많이 줄일 수 있다 1번 내용과 함께할 시 하드코딩된 부분을 상당수 제거 가능하다 코드 확인 Link to GitHub]]></summary></entry></feed>