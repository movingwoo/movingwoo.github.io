<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://movingwoo.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://movingwoo.com/" rel="alternate" type="text/html" hreflang="ko-KR" /><updated>2025-05-28T02:42:24+00:00</updated><id>https://movingwoo.com/feed.xml</id><title type="html">뭐라도 하겠지</title><subtitle>나도 사람인데 뭐라도 하겠지</subtitle><entry><title type="html">던전 생성기 02</title><link href="https://movingwoo.com/one-pan/javascript/2025/05/28/Dungeon-Generator-02.html" rel="alternate" type="text/html" title="던전 생성기 02" /><published>2025-05-28T02:00:00+00:00</published><updated>2025-05-28T02:00:00+00:00</updated><id>https://movingwoo.com/one-pan/javascript/2025/05/28/Dungeon%20Generator%2002</id><content type="html" xml:base="https://movingwoo.com/one-pan/javascript/2025/05/28/Dungeon-Generator-02.html"><![CDATA[<blockquote>
  <h4 id="개요">개요</h4>
  <hr />
</blockquote>

<p>남은 두개의 알고리즘으로 맵 만들기<br />
<span style="color: orange;"><strong>즐 겁 다 !!</strong></span></p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-delaunay-triangulation--mst">1. Delaunay Triangulation + MST</h5>

<p>얘는 왜 두개가 합쳐졌느냐???</p>

<p>우선 랜덤한 점을 방의 중심점으로 사용해 방을 넒힌다.  <br />
그리고 Delaunay Triangulation 알고리즘으로 모든 점을 삼각형으로 연결해<br />
각 삼각형의 외접원이 다른 점을 포함하지 않도록 최적의 삼각형 분할을 생성한다.<br />
마지막으로 MST 알고리즘은 모든 방을 연결하는 최소 비용의 통로를 생성한다.</p>

<p>Delaunay Triangulation만 사용할 경우 모든 점이 서로 연결되어 너무 많은 통로가 생성되어 어지럽다.<br />
이를 커버하는게 MST의 역할이다.</p>

<p>덕분에 자연스러운 방 배치와 효율적인 통로 연결이 이루어지게 된다.</p>

<p>삼각형 생성이 중요한데 삼각형을 생성하는 것으로 아래와 같은 일들이 가능해진다.</p>
<ul>
  <li><span style="color: orange;"><strong>국지적 연결을 최적화해 가까운 방들끼리 통로가 생기는 기반 마련</strong></span></li>
  <li><span style="color: orange;"><strong>삼각형의 변이 후보 연결선이 됨</strong></span></li>
  <li><span style="color: orange;"><strong>삼각형은 면을 채울 수 있는 기본 단위라 공간을 균형있게 분할하기 유리함</strong></span></li>
</ul>

<p>이렇게 생성된 삼각형들을 MST가 간소화해 효율성을 확보한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 점 클래스</span>
<span class="kd">class</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="nf">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nf">equals</span><span class="p">(</span><span class="nx">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">===</span> <span class="nx">other</span><span class="p">.</span><span class="nx">x</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">===</span> <span class="nx">other</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 간선 클래스</span>
<span class="kd">class</span> <span class="nc">Edge</span> <span class="p">{</span>
    <span class="nf">constructor</span><span class="p">(</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">p1</span> <span class="o">=</span> <span class="nx">p1</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">p2</span> <span class="o">=</span> <span class="nx">p2</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">weight</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span>
            <span class="nb">Math</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="nx">p2</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="nx">p1</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="nx">p2</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">p1</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 삼각형 클래스</span>
<span class="kd">class</span> <span class="nc">Triangle</span> <span class="p">{</span>
    <span class="nf">constructor</span><span class="p">(</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">p3</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">p1</span> <span class="o">=</span> <span class="nx">p1</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">p2</span> <span class="o">=</span> <span class="nx">p2</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">p3</span> <span class="o">=</span> <span class="nx">p3</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 외접원의 중심과 반지름 계산</span>
    <span class="nf">circumcircle</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">d</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="o">+</span> 
                      <span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="o">+</span> 
                      <span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">y</span><span class="p">));</span>
        <span class="kd">const</span> <span class="nx">ux</span> <span class="o">=</span> <span class="p">((</span><span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="o">+</span>
                   <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="o">+</span>
                   <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">y</span><span class="p">))</span> <span class="o">/</span> <span class="nx">d</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">uy</span> <span class="o">=</span> <span class="p">((</span><span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">x</span><span class="p">)</span> <span class="o">+</span>
                   <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">x</span><span class="p">)</span> <span class="o">+</span>
                   <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">x</span><span class="p">))</span> <span class="o">/</span> <span class="nx">d</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">center</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="p">(</span><span class="nx">ux</span><span class="p">,</span> <span class="nx">uy</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">radius</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span>
            <span class="nb">Math</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="nx">center</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">center</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">);</span>
        <span class="k">return</span> <span class="p">{</span> <span class="nx">center</span><span class="p">,</span> <span class="nx">radius</span> <span class="p">};</span>
    <span class="p">}</span>

    <span class="c1">// 점이 외접원 내부에 있는지 확인</span>
    <span class="nf">containsPoint</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="p">{</span> <span class="nx">center</span><span class="p">,</span> <span class="nx">radius</span> <span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nf">circumcircle</span><span class="p">();</span>
        <span class="kd">const</span> <span class="nx">distance</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span>
            <span class="nb">Math</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="nx">center</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">center</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">);</span>
        <span class="k">return</span> <span class="nx">distance</span> <span class="o">&lt;</span> <span class="nx">radius</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">async</span> <span class="kd">function</span> <span class="nf">startDelaunay</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">initMap</span><span class="p">();</span>
    
    <span class="c1">// 랜덤 점 생성 (방의 중심점)</span>
    <span class="kd">const</span> <span class="nx">points</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">const</span> <span class="nx">numPoints</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">// 방의 개수</span>
    <span class="kd">const</span> <span class="nx">roomSize</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 방 크기</span>
    <span class="kd">const</span> <span class="nx">margin</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 방 사이의 최소 간격</span>
    
    <span class="c1">// 방이 겹치는지 확인</span>
    <span class="kd">function</span> <span class="nf">isOverlapping</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">dy</span> <span class="o">=</span> <span class="o">-</span><span class="nx">size</span> <span class="o">-</span> <span class="nx">margin</span><span class="p">;</span> <span class="nx">dy</span> <span class="o">&lt;=</span> <span class="nx">size</span> <span class="o">+</span> <span class="nx">margin</span><span class="p">;</span> <span class="nx">dy</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">dx</span> <span class="o">=</span> <span class="o">-</span><span class="nx">size</span> <span class="o">-</span> <span class="nx">margin</span><span class="p">;</span> <span class="nx">dx</span> <span class="o">&lt;=</span> <span class="nx">size</span> <span class="o">+</span> <span class="nx">margin</span><span class="p">;</span> <span class="nx">dx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kd">const</span> <span class="nx">nx</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">;</span>
                <span class="kd">const</span> <span class="nx">ny</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">;</span>
                <span class="k">if </span><span class="p">(</span><span class="nx">nx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nx</span> <span class="o">&lt;</span> <span class="nx">cols</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&lt;</span> <span class="nx">rows</span> <span class="o">&amp;&amp;</span> <span class="nx">map</span><span class="p">[</span><span class="nx">ny</span><span class="p">][</span><span class="nx">nx</span><span class="p">]</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// 안전한 위치 찾기</span>
    <span class="kd">function</span> <span class="nf">findSafePosition</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">attempts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">maxAttempts</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
        
        <span class="k">do</span> <span class="p">{</span>
            <span class="nx">x</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">cols</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">roomSize</span><span class="p">))</span> <span class="o">+</span> <span class="nx">roomSize</span><span class="p">;</span>
            <span class="nx">y</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">rows</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">roomSize</span><span class="p">))</span> <span class="o">+</span> <span class="nx">roomSize</span><span class="p">;</span>
            <span class="nx">attempts</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while </span><span class="p">(</span><span class="nf">isOverlapping</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">roomSize</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">attempts</span> <span class="o">&lt;</span> <span class="nx">maxAttempts</span><span class="p">);</span>
        
        <span class="k">return</span> <span class="nx">attempts</span> <span class="o">&lt;</span> <span class="nx">maxAttempts</span> <span class="p">?</span> <span class="p">{</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">}</span> <span class="p">:</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// 방 생성</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">numPoints</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">pos</span> <span class="o">=</span> <span class="nf">findSafePosition</span><span class="p">();</span>
        <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">pos</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// 안전한 위치를 찾지 못하면 건너뛰기</span>
        
        <span class="nx">points</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="k">new</span> <span class="nc">Point</span><span class="p">(</span><span class="nx">pos</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">pos</span><span class="p">.</span><span class="nx">y</span><span class="p">));</span>
        
        <span class="c1">// 방 생성</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">dy</span> <span class="o">=</span> <span class="o">-</span><span class="nx">roomSize</span><span class="p">;</span> <span class="nx">dy</span> <span class="o">&lt;=</span> <span class="nx">roomSize</span><span class="p">;</span> <span class="nx">dy</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">dx</span> <span class="o">=</span> <span class="o">-</span><span class="nx">roomSize</span><span class="p">;</span> <span class="nx">dx</span> <span class="o">&lt;=</span> <span class="nx">roomSize</span><span class="p">;</span> <span class="nx">dx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kd">const</span> <span class="nx">nx</span> <span class="o">=</span> <span class="nx">pos</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">;</span>
                <span class="kd">const</span> <span class="nx">ny</span> <span class="o">=</span> <span class="nx">pos</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">;</span>
                <span class="k">if </span><span class="p">(</span><span class="nx">nx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nx</span> <span class="o">&lt;</span> <span class="nx">cols</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">map</span><span class="p">[</span><span class="nx">ny</span><span class="p">][</span><span class="nx">nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">nx</span><span class="p">,</span> <span class="nx">ny</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="kd">const</span> <span class="nx">triangles</span> <span class="o">=</span> <span class="nf">delaunayTriangulation</span><span class="p">(</span><span class="nx">points</span><span class="p">);</span>
    
    <span class="c1">// 간선 추출</span>
    <span class="kd">const</span> <span class="nx">edges</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">();</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">triangle</span> <span class="k">of</span> <span class="nx">triangles</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">edges</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="k">new</span> <span class="nc">Edge</span><span class="p">(</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">triangle</span><span class="p">.</span><span class="nx">p2</span><span class="p">));</span>
        <span class="nx">edges</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="k">new</span> <span class="nc">Edge</span><span class="p">(</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p2</span><span class="p">,</span> <span class="nx">triangle</span><span class="p">.</span><span class="nx">p3</span><span class="p">));</span>
        <span class="nx">edges</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="k">new</span> <span class="nc">Edge</span><span class="p">(</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p3</span><span class="p">,</span> <span class="nx">triangle</span><span class="p">.</span><span class="nx">p1</span><span class="p">));</span>
    <span class="p">}</span>
    
    <span class="kd">const</span> <span class="nx">mstEdges</span> <span class="o">=</span> <span class="nf">kruskalMST</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">edges</span><span class="p">));</span>
    
    <span class="c1">// MST 간선을 따라 통로 생성</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">edge</span> <span class="k">of</span> <span class="nx">mstEdges</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">await</span> <span class="nf">createCorridor</span><span class="p">(</span><span class="nx">edge</span><span class="p">.</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">edge</span><span class="p">.</span><span class="nx">p2</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="nf">generateEntrance</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Delaunay Triangulation 알고리즘</span>
<span class="kd">function</span> <span class="nf">delaunayTriangulation</span><span class="p">(</span><span class="nx">points</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">triangles</span> <span class="o">=</span> <span class="p">[];</span>
    
    <span class="c1">// 슈퍼 삼각형 생성 (모든 점을 포함하는 큰 삼각형)</span>
    <span class="c1">// 초기 삼각형이 필요해 생성하며 나중에 제거함</span>
    <span class="kd">const</span> <span class="nx">superTriangle</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Triangle</span><span class="p">(</span>
        <span class="k">new</span> <span class="nc">Point</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">),</span>
        <span class="k">new</span> <span class="nc">Point</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">),</span>
        <span class="k">new</span> <span class="nc">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="p">);</span>
    <span class="nx">triangles</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">superTriangle</span><span class="p">);</span>
    
    <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">point</span> <span class="k">of</span> <span class="nx">points</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">badTriangles</span> <span class="o">=</span> <span class="p">[];</span>
        
        <span class="c1">// 현재 점을 포함하는 삼각형 찾기</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">triangle</span> <span class="k">of</span> <span class="nx">triangles</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if </span><span class="p">(</span><span class="nx">triangle</span><span class="p">.</span><span class="nf">containsPoint</span><span class="p">(</span><span class="nx">point</span><span class="p">))</span> <span class="p">{</span>
                <span class="nx">badTriangles</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">triangle</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// 나쁜 삼각형들의 간선 찾기</span>
        <span class="c1">// 나쁜 삼각형은 너무 뾰족하거나 한 꼭지점에 너무 몰려 있는 못난 삼각형</span>
        <span class="kd">const</span> <span class="nx">edges</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">();</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">triangle</span> <span class="k">of</span> <span class="nx">badTriangles</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">edges</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="k">new</span> <span class="nc">Edge</span><span class="p">(</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">triangle</span><span class="p">.</span><span class="nx">p2</span><span class="p">));</span>
            <span class="nx">edges</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="k">new</span> <span class="nc">Edge</span><span class="p">(</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p2</span><span class="p">,</span> <span class="nx">triangle</span><span class="p">.</span><span class="nx">p3</span><span class="p">));</span>
            <span class="nx">edges</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="k">new</span> <span class="nc">Edge</span><span class="p">(</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p3</span><span class="p">,</span> <span class="nx">triangle</span><span class="p">.</span><span class="nx">p1</span><span class="p">));</span>
        <span class="p">}</span>
        
        <span class="c1">// 나쁜 삼각형 제거</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">triangle</span> <span class="k">of</span> <span class="nx">badTriangles</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">triangles</span><span class="p">.</span><span class="nf">indexOf</span><span class="p">(</span><span class="nx">triangle</span><span class="p">);</span>
            <span class="k">if </span><span class="p">(</span><span class="nx">index</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">triangles</span><span class="p">.</span><span class="nf">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// 새로운 삼각형 생성</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">edge</span> <span class="k">of</span> <span class="nx">edges</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">triangles</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="k">new</span> <span class="nc">Triangle</span><span class="p">(</span><span class="nx">edge</span><span class="p">.</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">edge</span><span class="p">.</span><span class="nx">p2</span><span class="p">,</span> <span class="nx">point</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// 슈퍼 삼각형과 관련된 삼각형 제거</span>
    <span class="k">return</span> <span class="nx">triangles</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="nx">triangle</span> <span class="o">=&gt;</span> 
        <span class="o">!</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nf">equals</span><span class="p">(</span><span class="nx">superTriangle</span><span class="p">.</span><span class="nx">p1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nf">equals</span><span class="p">(</span><span class="nx">superTriangle</span><span class="p">.</span><span class="nx">p2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p1</span><span class="p">.</span><span class="nf">equals</span><span class="p">(</span><span class="nx">superTriangle</span><span class="p">.</span><span class="nx">p3</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nf">equals</span><span class="p">(</span><span class="nx">superTriangle</span><span class="p">.</span><span class="nx">p1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nf">equals</span><span class="p">(</span><span class="nx">superTriangle</span><span class="p">.</span><span class="nx">p2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p2</span><span class="p">.</span><span class="nf">equals</span><span class="p">(</span><span class="nx">superTriangle</span><span class="p">.</span><span class="nx">p3</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nf">equals</span><span class="p">(</span><span class="nx">superTriangle</span><span class="p">.</span><span class="nx">p1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nf">equals</span><span class="p">(</span><span class="nx">superTriangle</span><span class="p">.</span><span class="nx">p2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">p3</span><span class="p">.</span><span class="nf">equals</span><span class="p">(</span><span class="nx">superTriangle</span><span class="p">.</span><span class="nx">p3</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Kruskal's MST 알고리즘</span>
<span class="kd">function</span> <span class="nf">kruskalMST</span><span class="p">(</span><span class="nx">edges</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 간선을 가중치 순으로 정렬</span>
    <span class="nx">edges</span><span class="p">.</span><span class="nf">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">weight</span> <span class="o">-</span> <span class="nx">b</span><span class="p">.</span><span class="nx">weight</span><span class="p">);</span>
    
    <span class="kd">const</span> <span class="nx">mst</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">const</span> <span class="nx">sets</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Map</span><span class="p">();</span>
    
    <span class="c1">// 각 점을 독립적인 집합으로 초기화</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">edge</span> <span class="k">of</span> <span class="nx">edges</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">sets</span><span class="p">.</span><span class="nf">has</span><span class="p">(</span><span class="nx">edge</span><span class="p">.</span><span class="nx">p1</span><span class="p">))</span> <span class="nx">sets</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">edge</span><span class="p">.</span><span class="nx">p1</span><span class="p">,</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">([</span><span class="nx">edge</span><span class="p">.</span><span class="nx">p1</span><span class="p">]));</span>
        <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">sets</span><span class="p">.</span><span class="nf">has</span><span class="p">(</span><span class="nx">edge</span><span class="p">.</span><span class="nx">p2</span><span class="p">))</span> <span class="nx">sets</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">edge</span><span class="p">.</span><span class="nx">p2</span><span class="p">,</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">([</span><span class="nx">edge</span><span class="p">.</span><span class="nx">p2</span><span class="p">]));</span>
    <span class="p">}</span>
    
    <span class="c1">// 사이클을 형성하지 않는 간선만 선택</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">edge</span> <span class="k">of</span> <span class="nx">edges</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">set1</span> <span class="o">=</span> <span class="nx">sets</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">edge</span><span class="p">.</span><span class="nx">p1</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">set2</span> <span class="o">=</span> <span class="nx">sets</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">edge</span><span class="p">.</span><span class="nx">p2</span><span class="p">);</span>
        
        <span class="k">if </span><span class="p">(</span><span class="nx">set1</span> <span class="o">!==</span> <span class="nx">set2</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">mst</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">edge</span><span class="p">);</span>
            
            <span class="c1">// 두 집합 합치기</span>
            <span class="kd">const</span> <span class="nx">union</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">();</span>
            <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">p</span> <span class="k">of</span> <span class="nx">set1</span><span class="p">)</span> <span class="nx">union</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
            <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">p</span> <span class="k">of</span> <span class="nx">set2</span><span class="p">)</span> <span class="nx">union</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>

            <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">point</span> <span class="k">of</span> <span class="nx">union</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">sets</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">point</span><span class="p">,</span> <span class="nx">union</span><span class="p">);</span>  <span class="c1">// 각 포인트가 새로운 union 집합을 참조하도록 갱신</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="nx">mst</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 두 점 사이의 통로 생성</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">createCorridor</span><span class="p">(</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">dx</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sign</span><span class="p">(</span><span class="nx">p2</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="nx">p1</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">dy</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sign</span><span class="p">(</span><span class="nx">p2</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">p1</span><span class="p">.</span><span class="nx">y</span><span class="p">);</span>
    
    <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">p1</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">p1</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span>
    
    <span class="c1">// x축 방향으로 먼저 이동</span>
    <span class="k">while </span><span class="p">(</span><span class="nx">x</span> <span class="o">!==</span> <span class="nx">p2</span><span class="p">.</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">map</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
        <span class="nx">x</span> <span class="o">+=</span> <span class="nx">dx</span><span class="p">;</span>
        <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">// y축 방향으로 이동</span>
    <span class="k">while </span><span class="p">(</span><span class="nx">y</span> <span class="o">!==</span> <span class="nx">p2</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">map</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
        <span class="nx">y</span> <span class="o">+=</span> <span class="nx">dy</span><span class="p">;</span>
        <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="2-wfc-알고리즘">2. WFC 알고리즘</h5>

<p>다소 난해했던 알고리즘<br />
주변 셀에 따라 가능한 옵션을 줄이며 점차 결정하는 방식이다.<br />
규칙을 설정해두는게 무엇보다 중요하다.</p>

<p>WFC는 Wave Function Collapse의 약자인데<br />
Wave Function은 모든 타일이 겹쳐진 상태를 의미하고 Collapse는 결정하는 과정을 말한다.<br />
다른 내용은 괜찮은데 엔트로피 개념이 갑자기 끼어들어서 헷갈렸다.<br />
WFC에서의 <span style="color: orange;"><strong>엔트로피는 셀의 불확실성 정도, 그 셀에서 가능한 타일 후보 수</strong></span>를 의미한다.<br />
가능한 타일이 많을수록 엔트로피가 높은 셀인 것.</p>

<p>흐름은 아래와 같다.</p>
<ul>
  <li><span style="color: orange;"><strong>모든 셀은 타일 후보를 가지고 시작</strong></span></li>
  <li><span style="color: orange;"><strong>가장 적은 옵션을 가진 셀 선택(엔트로피가 가장 낮은 셀)</strong></span></li>
  <li><span style="color: orange;"><strong>그 셀이 가능한 타일 중 하나를 무작위로 결정(collapse)</strong></span></li>
  <li><span style="color: orange;"><strong>전파(Propagation)</strong></span></li>
  <li><span style="color: orange;"><strong>결정과 전파 반복</strong></span></li>
</ul>

<p>설정한 타일로 가득 채워진 맵을 얻을 수 있으며 타일을 잘 설정할수록 상당히 구조적인 맵이 나온다.<br />
나는 불확실성으로 가득찬게 좋아서 타일을 8개 맘대로 집어넣었더니 결과물이 깔끔해 보이진 않는다.</p>

<p>개념을 확실히 정립하기 전에는 방 전체가 뚫린다던가 죄다 벽이라던가 구현이 어려웠다.<br />
그래도 전파되며 만들어지는 모습이 아름답다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 2x2 타일 사전 정의</span>
<span class="kd">const</span> <span class="nx">tiles</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span>
        <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">wall</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// 전체 벽</span>
        <span class="na">data</span><span class="p">:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
        <span class="na">edges</span><span class="p">:</span> <span class="p">{</span> <span class="na">up</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">right</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">down</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">left</span><span class="p">:</span> <span class="mi">1</span> <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">floor</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// 전체 통로</span>
        <span class="na">data</span><span class="p">:</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
        <span class="na">edges</span><span class="p">:</span> <span class="p">{</span> <span class="na">up</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">right</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">down</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">left</span><span class="p">:</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">hall_h</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// 수평 복도</span>
        <span class="na">data</span><span class="p">:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
        <span class="na">edges</span><span class="p">:</span> <span class="p">{</span> <span class="na">up</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">right</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">down</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">left</span><span class="p">:</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">hall_v</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// 수직 복도</span>
        <span class="na">data</span><span class="p">:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
        <span class="na">edges</span><span class="p">:</span> <span class="p">{</span> <span class="na">up</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">right</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">down</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">left</span><span class="p">:</span> <span class="mi">1</span> <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">room_corner_top_left</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// 위/왼쪽이 열린 방 구석</span>
        <span class="na">data</span><span class="p">:</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
        <span class="na">edges</span><span class="p">:</span> <span class="p">{</span> <span class="na">up</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">right</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">down</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">left</span><span class="p">:</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">room_corner_bottom_right</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// 아래/오른쪽 열린 방 구석</span>
        <span class="na">data</span><span class="p">:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
        <span class="na">edges</span><span class="p">:</span> <span class="p">{</span> <span class="na">up</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">right</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">down</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">left</span><span class="p">:</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">junction_T_up</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// T자 모양 (위쪽 갈래)</span>
        <span class="na">data</span><span class="p">:</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
        <span class="na">edges</span><span class="p">:</span> <span class="p">{</span> <span class="na">up</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">right</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">down</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">left</span><span class="p">:</span> <span class="mi">1</span> <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">dead_end_left</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// 왼쪽에만 열린 막다른길</span>
        <span class="na">data</span><span class="p">:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
        <span class="na">edges</span><span class="p">:</span> <span class="p">{</span> <span class="na">up</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">right</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">down</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">left</span><span class="p">:</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">];</span>
  
<span class="c1">// 붙으려는 상대방 타일의 방향을 찾기 위한 반대 방향 매핑</span>
<span class="kd">const</span> <span class="nx">opposite</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">up</span><span class="p">:</span> <span class="dl">"</span><span class="s2">down</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">down</span><span class="p">:</span> <span class="dl">"</span><span class="s2">up</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">left</span><span class="p">:</span> <span class="dl">"</span><span class="s2">right</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">right</span><span class="p">:</span> <span class="dl">"</span><span class="s2">left</span><span class="dl">"</span>
<span class="p">};</span>

<span class="c1">// 타일 간 인접성 판단</span>
<span class="kd">function</span> <span class="nf">compatible</span><span class="p">(</span><span class="nx">tileA</span><span class="p">,</span> <span class="nx">tileB</span><span class="p">,</span> <span class="nx">direction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">tileA</span><span class="p">.</span><span class="nx">edges</span><span class="p">[</span><span class="nx">direction</span><span class="p">]</span> <span class="o">===</span> <span class="nx">tileB</span><span class="p">.</span><span class="nx">edges</span><span class="p">[</span><span class="nx">opposite</span><span class="p">[</span><span class="nx">direction</span><span class="p">]];</span>
<span class="p">}</span>

<span class="c1">// 셀 클래스 (1칸마다 타일 1개)</span>
<span class="kd">class</span> <span class="nc">WFC_TileCell</span> <span class="p">{</span>
    <span class="nf">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">options</span> <span class="o">=</span> <span class="nx">tiles</span><span class="p">.</span><span class="nf">slice</span><span class="p">();</span> <span class="c1">// 가능한 타일들</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">collapsed</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nf">collapse</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">pick</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">options</span><span class="p">[</span><span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">length</span><span class="p">)];</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">options</span> <span class="o">=</span> <span class="p">[</span><span class="nx">pick</span><span class="p">];</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">collapsed</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">pick</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nf">getTile</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">options</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">async</span> <span class="kd">function</span> <span class="nf">startWFC</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">initMap</span><span class="p">();</span>

    <span class="kd">const</span> <span class="nx">tileSize</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 2x2 타일</span>
    <span class="kd">const</span> <span class="nx">tileCols</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nx">cols</span> <span class="o">/</span> <span class="nx">tileSize</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">tileRows</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nx">rows</span> <span class="o">/</span> <span class="nx">tileSize</span><span class="p">);</span>

    <span class="kd">const</span> <span class="nx">grid</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">({</span> <span class="na">length</span><span class="p">:</span> <span class="nx">tileRows</span> <span class="p">},</span> <span class="p">(</span><span class="nx">_</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">({</span> <span class="na">length</span><span class="p">:</span> <span class="nx">tileCols</span> <span class="p">},</span> <span class="p">(</span><span class="nx">_</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nc">WFC_TileCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">))</span>
    <span class="p">);</span>

    <span class="c1">// collapse 루프</span>
    <span class="kd">let</span> <span class="nx">pending</span> <span class="o">=</span> <span class="nx">grid</span><span class="p">.</span><span class="nf">flat</span><span class="p">().</span><span class="nf">filter</span><span class="p">(</span><span class="nx">cell</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="nx">cell</span><span class="p">.</span><span class="nx">collapsed</span><span class="p">);</span>

    <span class="k">while </span><span class="p">(</span><span class="nx">pending</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 아직 collapse되지 않은 셀 중에서 가능한 옵션이 가장 적은 값 찾기</span>
        <span class="kd">let</span> <span class="nx">minEntropy</span> <span class="o">=</span> <span class="nx">pending</span><span class="p">.</span><span class="nf">reduce</span><span class="p">((</span><span class="nx">min</span><span class="p">,</span> <span class="nx">cell</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="nx">min</span><span class="p">,</span> <span class="nx">cell</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">length</span><span class="p">),</span> <span class="kc">Infinity</span><span class="p">);</span>
        <span class="c1">// 가능한 옵션 수가 최소인 셀들만 필터링</span>
        <span class="kd">let</span> <span class="nx">choices</span> <span class="o">=</span> <span class="nx">pending</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="nx">c</span> <span class="o">=&gt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="nx">minEntropy</span><span class="p">);</span>
        <span class="c1">// 그 중 하나를 랜덤 선택</span>
        <span class="kd">let</span> <span class="nx">cell</span> <span class="o">=</span> <span class="nx">choices</span><span class="p">[</span><span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">choices</span><span class="p">.</span><span class="nx">length</span><span class="p">)];</span>

        <span class="kd">const</span> <span class="nx">tile</span> <span class="o">=</span> <span class="nx">cell</span><span class="p">.</span><span class="nf">collapse</span><span class="p">();</span>

        <span class="c1">// 타일을 실제 맵에 그리기</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">dy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">dy</span> <span class="o">&lt;</span> <span class="nx">tileSize</span><span class="p">;</span> <span class="nx">dy</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">dx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">dx</span> <span class="o">&lt;</span> <span class="nx">tileSize</span><span class="p">;</span> <span class="nx">dx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">mx</span> <span class="o">=</span> <span class="nx">cell</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="nx">tileSize</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">;</span>
            <span class="kd">const</span> <span class="nx">my</span> <span class="o">=</span> <span class="nx">cell</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="nx">tileSize</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">;</span>

            <span class="k">if </span><span class="p">(</span><span class="nx">mx</span> <span class="o">&lt;</span> <span class="nx">cols</span> <span class="o">&amp;&amp;</span> <span class="nx">my</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">map</span><span class="p">[</span><span class="nx">my</span><span class="p">][</span><span class="nx">mx</span><span class="p">]</span> <span class="o">=</span> <span class="nx">tile</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">dy</span><span class="p">][</span><span class="nx">dx</span><span class="p">];</span>
              <span class="nf">drawCell</span><span class="p">(</span><span class="nx">mx</span><span class="p">,</span> <span class="nx">my</span><span class="p">,</span> <span class="nx">tile</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">dy</span><span class="p">][</span><span class="nx">dx</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

        <span class="c1">// 주변 셀 옵션 줄이기</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="p">[</span><span class="nx">dir</span><span class="p">,</span> <span class="p">[</span><span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">]]</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">entries</span><span class="p">({</span>
            <span class="na">up</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="na">right</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="na">down</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="na">left</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="p">}))</span> <span class="p">{</span>
                <span class="kd">const</span> <span class="nx">nx</span> <span class="o">=</span> <span class="nx">cell</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">;</span>
                <span class="kd">const</span> <span class="nx">ny</span> <span class="o">=</span> <span class="nx">cell</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">;</span>

                <span class="k">if </span><span class="p">(</span><span class="nx">nx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">ny</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">nx</span> <span class="o">&gt;=</span> <span class="nx">tileCols</span> <span class="o">||</span> <span class="nx">ny</span> <span class="o">&gt;=</span> <span class="nx">tileRows</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

                <span class="kd">const</span> <span class="nx">neighbor</span> <span class="o">=</span> <span class="nx">grid</span><span class="p">[</span><span class="nx">ny</span><span class="p">][</span><span class="nx">nx</span><span class="p">];</span>
                <span class="k">if </span><span class="p">(</span><span class="nx">neighbor</span><span class="p">.</span><span class="nx">collapsed</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

                <span class="c1">// 현재 셀과 호환되는 타일만 남김</span>
                <span class="nx">neighbor</span><span class="p">.</span><span class="nx">options</span> <span class="o">=</span> <span class="nx">neighbor</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="nx">opt</span> <span class="o">=&gt;</span>
                    <span class="nf">compatible</span><span class="p">(</span><span class="nx">tile</span><span class="p">,</span> <span class="nx">opt</span><span class="p">,</span> <span class="nx">dir</span><span class="p">)</span>
                <span class="p">);</span>
            <span class="p">}</span>

            <span class="nx">pending</span> <span class="o">=</span> <span class="nx">grid</span><span class="p">.</span><span class="nf">flat</span><span class="p">().</span><span class="nf">filter</span><span class="p">(</span><span class="nx">c</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="nx">c</span><span class="p">.</span><span class="nx">collapsed</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">await</span> <span class="nf">generateEntrance</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="완성">완성</h4>
  <hr />
</blockquote>

<p>Delaunay Triangulation + MST<br />
<img src="/assets/images/posts/one-pan/JavaScript/2025-05-28-Dungeon Generator 02/img01.gif" alt="img01" /></p>

<p>WFC<br />
<img src="/assets/images/posts/one-pan/JavaScript/2025-05-28-Dungeon Generator 02/img02.gif" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>동굴 지형같은 구불구불 무작위보다 구조적인 지형을 구성하는게 무엇보다 더 어려운 느낌이다.<br />
우연하게 태어난 아름다움과 철저히 설계된 아름다움의 차이로 느껴진다.<br />
아 감성적인 하루</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="/play/Dungeon%20Generator.html" target="_blank" rel="noopener noreferrer">
  직접 해보기
</a></p>

<p>Delaunay Triangulation + MST<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-28-Delaunay.js">Link to GitHub</a></p>

<p>WFC<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-28-WFC.js">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="one-pan/JavaScript/" /><summary type="html"><![CDATA[개요 남은 두개의 알고리즘으로 맵 만들기 즐 겁 다 !! 구현 1. Delaunay Triangulation + MST 얘는 왜 두개가 합쳐졌느냐??? 우선 랜덤한 점을 방의 중심점으로 사용해 방을 넒힌다. 그리고 Delaunay Triangulation 알고리즘으로 모든 점을 삼각형으로 연결해 각 삼각형의 외접원이 다른 점을 포함하지 않도록 최적의 삼각형 분할을 생성한다. 마지막으로 MST 알고리즘은 모든 방을 연결하는 최소 비용의 통로를 생성한다. Delaunay Triangulation만 사용할 경우 모든 점이 서로 연결되어 너무 많은 통로가 생성되어 어지럽다. 이를 커버하는게 MST의 역할이다. 덕분에 자연스러운 방 배치와 효율적인 통로 연결이 이루어지게 된다. 삼각형 생성이 중요한데 삼각형을 생성하는 것으로 아래와 같은 일들이 가능해진다. 국지적 연결을 최적화해 가까운 방들끼리 통로가 생기는 기반 마련 삼각형의 변이 후보 연결선이 됨 삼각형은 면을 채울 수 있는 기본 단위라 공간을 균형있게 분할하기 유리함 이렇게 생성된 삼각형들을 MST가 간소화해 효율성을 확보한다. // 점 클래스 class Point { constructor(x, y) { this.x = x; this.y = y; } equals(other) { return this.x === other.x &amp;&amp; this.y === other.y; } } // 간선 클래스 class Edge { constructor(p1, p2) { this.p1 = p1; this.p2 = p2; this.weight = Math.sqrt( Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2) ); } } // 삼각형 클래스 class Triangle { constructor(p1, p2, p3) { this.p1 = p1; this.p2 = p2; this.p3 = p3; } // 외접원의 중심과 반지름 계산 circumcircle() { const d = 2 * (this.p1.x * (this.p2.y - this.p3.y) + this.p2.x * (this.p3.y - this.p1.y) + this.p3.x * (this.p1.y - this.p2.y)); const ux = ((this.p1.x * this.p1.x + this.p1.y * this.p1.y) * (this.p2.y - this.p3.y) + (this.p2.x * this.p2.x + this.p2.y * this.p2.y) * (this.p3.y - this.p1.y) + (this.p3.x * this.p3.x + this.p3.y * this.p3.y) * (this.p1.y - this.p2.y)) / d; const uy = ((this.p1.x * this.p1.x + this.p1.y * this.p1.y) * (this.p3.x - this.p2.x) + (this.p2.x * this.p2.x + this.p2.y * this.p2.y) * (this.p1.x - this.p3.x) + (this.p3.x * this.p3.x + this.p3.y * this.p3.y) * (this.p2.x - this.p1.x)) / d; const center = new Point(ux, uy); const radius = Math.sqrt( Math.pow(this.p1.x - center.x, 2) + Math.pow(this.p1.y - center.y, 2) ); return { center, radius }; } // 점이 외접원 내부에 있는지 확인 containsPoint(p) { const { center, radius } = this.circumcircle(); const distance = Math.sqrt( Math.pow(p.x - center.x, 2) + Math.pow(p.y - center.y, 2) ); return distance &lt; radius; } } async function startDelaunay() { initMap(); // 랜덤 점 생성 (방의 중심점) const points = []; const numPoints = 20; // 방의 개수 const roomSize = 2; // 방 크기 const margin = 2; // 방 사이의 최소 간격 // 방이 겹치는지 확인 function isOverlapping(x, y, size) { for (let dy = -size - margin; dy &lt;= size + margin; dy++) { for (let dx = -size - margin; dx &lt;= size + margin; dx++) { const nx = x + dx; const ny = y + dy; if (nx &gt;= 0 &amp;&amp; nx &lt; cols &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; rows &amp;&amp; map[ny][nx] === 0) { return true; } } } return false; } // 안전한 위치 찾기 function findSafePosition() { let x, y; let attempts = 0; const maxAttempts = 100; do { x = Math.floor(Math.random() * (cols - 2 * roomSize)) + roomSize; y = Math.floor(Math.random() * (rows - 2 * roomSize)) + roomSize; attempts++; } while (isOverlapping(x, y, roomSize) &amp;&amp; attempts &lt; maxAttempts); return attempts &lt; maxAttempts ? {x, y} : null; } // 방 생성 for (let i = 0; i &lt; numPoints; i++) { const pos = findSafePosition(); if (!pos) continue; // 안전한 위치를 찾지 못하면 건너뛰기 points.push(new Point(pos.x, pos.y)); // 방 생성 for (let dy = -roomSize; dy &lt;= roomSize; dy++) { for (let dx = -roomSize; dx &lt;= roomSize; dx++) { const nx = pos.x + dx; const ny = pos.y + dy; if (nx &gt;= 0 &amp;&amp; nx &lt; cols &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; rows) { map[ny][nx] = 0; drawCell(nx, ny, 'white'); } } } await sleep(50); } const triangles = delaunayTriangulation(points); // 간선 추출 const edges = new Set(); for (const triangle of triangles) { edges.add(new Edge(triangle.p1, triangle.p2)); edges.add(new Edge(triangle.p2, triangle.p3)); edges.add(new Edge(triangle.p3, triangle.p1)); } const mstEdges = kruskalMST(Array.from(edges)); // MST 간선을 따라 통로 생성 for (const edge of mstEdges) { await createCorridor(edge.p1, edge.p2); } generateEntrance(); } // Delaunay Triangulation 알고리즘 function delaunayTriangulation(points) { const triangles = []; // 슈퍼 삼각형 생성 (모든 점을 포함하는 큰 삼각형) // 초기 삼각형이 필요해 생성하며 나중에 제거함 const superTriangle = new Triangle( new Point(-100, -100), new Point(100, -100), new Point(0, 100) ); triangles.push(superTriangle); for (const point of points) { const badTriangles = []; // 현재 점을 포함하는 삼각형 찾기 for (const triangle of triangles) { if (triangle.containsPoint(point)) { badTriangles.push(triangle); } } // 나쁜 삼각형들의 간선 찾기 // 나쁜 삼각형은 너무 뾰족하거나 한 꼭지점에 너무 몰려 있는 못난 삼각형 const edges = new Set(); for (const triangle of badTriangles) { edges.add(new Edge(triangle.p1, triangle.p2)); edges.add(new Edge(triangle.p2, triangle.p3)); edges.add(new Edge(triangle.p3, triangle.p1)); } // 나쁜 삼각형 제거 for (const triangle of badTriangles) { const index = triangles.indexOf(triangle); if (index &gt; -1) { triangles.splice(index, 1); } } // 새로운 삼각형 생성 for (const edge of edges) { triangles.push(new Triangle(edge.p1, edge.p2, point)); } } // 슈퍼 삼각형과 관련된 삼각형 제거 return triangles.filter(triangle =&gt; !triangle.p1.equals(superTriangle.p1) &amp;&amp; !triangle.p1.equals(superTriangle.p2) &amp;&amp; !triangle.p1.equals(superTriangle.p3) &amp;&amp; !triangle.p2.equals(superTriangle.p1) &amp;&amp; !triangle.p2.equals(superTriangle.p2) &amp;&amp; !triangle.p2.equals(superTriangle.p3) &amp;&amp; !triangle.p3.equals(superTriangle.p1) &amp;&amp; !triangle.p3.equals(superTriangle.p2) &amp;&amp; !triangle.p3.equals(superTriangle.p3) ); } // Kruskal's MST 알고리즘 function kruskalMST(edges) { // 간선을 가중치 순으로 정렬 edges.sort((a, b) =&gt; a.weight - b.weight); const mst = []; const sets = new Map(); // 각 점을 독립적인 집합으로 초기화 for (const edge of edges) { if (!sets.has(edge.p1)) sets.set(edge.p1, new Set([edge.p1])); if (!sets.has(edge.p2)) sets.set(edge.p2, new Set([edge.p2])); } // 사이클을 형성하지 않는 간선만 선택 for (const edge of edges) { const set1 = sets.get(edge.p1); const set2 = sets.get(edge.p2); if (set1 !== set2) { mst.push(edge); // 두 집합 합치기 const union = new Set(); for (const p of set1) union.add(p); for (const p of set2) union.add(p); for (const point of union) { sets.set(point, union); // 각 포인트가 새로운 union 집합을 참조하도록 갱신 } } } return mst; } // 두 점 사이의 통로 생성 async function createCorridor(p1, p2) { const dx = Math.sign(p2.x - p1.x); const dy = Math.sign(p2.y - p1.y); let x = p1.x; let y = p1.y; // x축 방향으로 먼저 이동 while (x !== p2.x) { map[y][x] = 0; drawCell(x, y, 'white'); x += dx; await sleep(1); } // y축 방향으로 이동 while (y !== p2.y) { map[y][x] = 0; drawCell(x, y, 'white'); y += dy; await sleep(1); } } 2. WFC 알고리즘 다소 난해했던 알고리즘 주변 셀에 따라 가능한 옵션을 줄이며 점차 결정하는 방식이다. 규칙을 설정해두는게 무엇보다 중요하다. WFC는 Wave Function Collapse의 약자인데 Wave Function은 모든 타일이 겹쳐진 상태를 의미하고 Collapse는 결정하는 과정을 말한다. 다른 내용은 괜찮은데 엔트로피 개념이 갑자기 끼어들어서 헷갈렸다. WFC에서의 엔트로피는 셀의 불확실성 정도, 그 셀에서 가능한 타일 후보 수를 의미한다. 가능한 타일이 많을수록 엔트로피가 높은 셀인 것. 흐름은 아래와 같다. 모든 셀은 타일 후보를 가지고 시작 가장 적은 옵션을 가진 셀 선택(엔트로피가 가장 낮은 셀) 그 셀이 가능한 타일 중 하나를 무작위로 결정(collapse) 전파(Propagation) 결정과 전파 반복 설정한 타일로 가득 채워진 맵을 얻을 수 있으며 타일을 잘 설정할수록 상당히 구조적인 맵이 나온다. 나는 불확실성으로 가득찬게 좋아서 타일을 8개 맘대로 집어넣었더니 결과물이 깔끔해 보이진 않는다. 개념을 확실히 정립하기 전에는 방 전체가 뚫린다던가 죄다 벽이라던가 구현이 어려웠다. 그래도 전파되며 만들어지는 모습이 아름답다. // 2x2 타일 사전 정의 const tiles = [ { name: "wall", // 전체 벽 data: [[1, 1], [1, 1]], edges: { up: 1, right: 1, down: 1, left: 1 } }, { name: "floor", // 전체 통로 data: [[0, 0], [0, 0]], edges: { up: 0, right: 0, down: 0, left: 0 } }, { name: "hall_h", // 수평 복도 data: [[1, 1], [0, 0]], edges: { up: 1, right: 0, down: 1, left: 0 } }, { name: "hall_v", // 수직 복도 data: [[1, 0], [1, 0]], edges: { up: 0, right: 1, down: 0, left: 1 } }, { name: "room_corner_top_left", // 위/왼쪽이 열린 방 구석 data: [[0, 0], [0, 1]], edges: { up: 0, right: 0, down: 1, left: 0 } }, { name: "room_corner_bottom_right", // 아래/오른쪽 열린 방 구석 data: [[1, 0], [0, 0]], edges: { up: 1, right: 0, down: 0, left: 0 } }, { name: "junction_T_up", // T자 모양 (위쪽 갈래) data: [[0, 0], [1, 0]], edges: { up: 0, right: 0, down: 1, left: 1 } }, { name: "dead_end_left", // 왼쪽에만 열린 막다른길 data: [[1, 1], [0, 1]], edges: { up: 1, right: 1, down: 1, left: 0 } } ]; // 붙으려는 상대방 타일의 방향을 찾기 위한 반대 방향 매핑 const opposite = { up: "down", down: "up", left: "right", right: "left" }; // 타일 간 인접성 판단 function compatible(tileA, tileB, direction) { return tileA.edges[direction] === tileB.edges[opposite[direction]]; } // 셀 클래스 (1칸마다 타일 1개) class WFC_TileCell { constructor(x, y) { this.x = x; this.y = y; this.options = tiles.slice(); // 가능한 타일들 this.collapsed = false; } collapse() { const pick = this.options[Math.floor(Math.random() * this.options.length)]; this.options = [pick]; this.collapsed = true; return pick; } getTile() { return this.options[0]; } } async function startWFC() { initMap(); const tileSize = 2; // 2x2 타일 const tileCols = Math.floor(cols / tileSize); const tileRows = Math.floor(rows / tileSize); const grid = Array.from({ length: tileRows }, (_, y) =&gt; Array.from({ length: tileCols }, (_, x) =&gt; new WFC_TileCell(x, y)) ); // collapse 루프 let pending = grid.flat().filter(cell =&gt; !cell.collapsed); while (pending.length &gt; 0) { // 아직 collapse되지 않은 셀 중에서 가능한 옵션이 가장 적은 값 찾기 let minEntropy = pending.reduce((min, cell) =&gt; Math.min(min, cell.options.length), Infinity); // 가능한 옵션 수가 최소인 셀들만 필터링 let choices = pending.filter(c =&gt; c.options.length === minEntropy); // 그 중 하나를 랜덤 선택 let cell = choices[Math.floor(Math.random() * choices.length)]; const tile = cell.collapse(); // 타일을 실제 맵에 그리기 for (let dy = 0; dy &lt; tileSize; dy++) { for (let dx = 0; dx &lt; tileSize; dx++) { const mx = cell.x * tileSize + dx; const my = cell.y * tileSize + dy; if (mx &lt; cols &amp;&amp; my &lt; rows) { map[my][mx] = tile.data[dy][dx]; drawCell(mx, my, tile.data[dy][dx] === 1 ? 'black' : 'white'); } } await sleep(5); // 주변 셀 옵션 줄이기 for (const [dir, [dx, dy]] of Object.entries({ up: [0, -1], right: [1, 0], down: [0, 1], left: [-1, 0] })) { const nx = cell.x + dx; const ny = cell.y + dy; if (nx &lt; 0 || ny &lt; 0 || nx &gt;= tileCols || ny &gt;= tileRows) continue; const neighbor = grid[ny][nx]; if (neighbor.collapsed) continue; // 현재 셀과 호환되는 타일만 남김 neighbor.options = neighbor.options.filter(opt =&gt; compatible(tile, opt, dir) ); } pending = grid.flat().filter(c =&gt; !c.collapsed); } } await generateEntrance(); } 완성 Delaunay Triangulation + MST WFC 반성 동굴 지형같은 구불구불 무작위보다 구조적인 지형을 구성하는게 무엇보다 더 어려운 느낌이다. 우연하게 태어난 아름다움과 철저히 설계된 아름다움의 차이로 느껴진다. 아 감성적인 하루 코드 확인 직접 해보기 Delaunay Triangulation + MST Link to GitHub WFC Link to GitHub]]></summary></entry><entry><title type="html">7106번 Wonderful Fours</title><link href="https://movingwoo.com/random-solve/python/2025/05/27/7106.html" rel="alternate" type="text/html" title="7106번 Wonderful Fours" /><published>2025-05-27T07:00:00+00:00</published><updated>2025-05-27T07:00:00+00:00</updated><id>https://movingwoo.com/random-solve/python/2025/05/27/7106</id><content type="html" xml:base="https://movingwoo.com/random-solve/python/2025/05/27/7106.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Python/2025-05-27-7106/img01.jpg" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/7106">7106번 Wonderful Fours - 백준</a></p>

<blockquote>
  <h4 id="번역">번역</h4>
  <hr />
</blockquote>

<p>브론즈 문제 하나, 텍스트 제출 문제 하나 거르고 나온 실버 문제.<br />
내 그지같은 파이썬 실력에 알맞은 난이도다.<br />
찬찬히 해석해보면…</p>

<p>십진수 숫자 5개를 K5라 부른다.<br />
모두 사용하되 0으로 시작하지 않는 숫자를 만들면 그 숫자는 <span style="color: orange;"><strong>‘적절히’</strong></span> 만들어진 것이다.<br />
그리고 아래 내용이 모두 참일 경우 <span style="color: orange;"><strong>완다풀 포</strong></span>가 된다.</p>
<ul>
  <li>4개의 5자리 자연수가 모두 적절하게 만들어짐</li>
  <li>4개의 5자리 자연수는 모두 다른 숫자</li>
  <li>s1 + s2 + s3 = s4</li>
</ul>

<p>여기서 주어진 K5로 몇 개의 서로 다른 완다풀 포를 만들 수 있는지 계산하시오.</p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>뭐 방법이 있나?<br />
숫자 크기도 작고 그냥 세개 뽑아서 합해서 찾아보면 되겠다.<br />
중복 제거에만 신경쓰면 될 듯</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<p>중복 제거를 고민해봤는데<br />
처음부터 ‘적절한’ 숫자를 만들며 중복되는걸 날려버리면 끝이다.</p>

<h5 id="1-입력받아-적절한-숫자-만들기">1. 입력받아 ‘적절한’ 숫자 만들기</h5>

<p>더 똑똑하게 할 수 있지만<br />
겨우 숫자 다섯개로 하는거니 5중 나생문을 쌓았다.<br />
중복 거르고 정렬.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">K5</span> <span class="o">=</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">()</span>

<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># 적절한 숫자 생성(중복제외)
</span><span class="n">all_num</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>

<span class="c1"># 몇개 안되고 귀찮으니 5중반복문
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">i</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="n">i</span> <span class="ow">or</span> <span class="n">l</span> <span class="o">==</span> <span class="n">j</span> <span class="ow">or</span> <span class="n">l</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">i</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">==</span> <span class="n">j</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">==</span> <span class="n">k</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">==</span> <span class="n">l</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">num_str</span> <span class="o">=</span> <span class="n">K5</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">K5</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">K5</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">K5</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">+</span> <span class="n">K5</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">num_str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sh">'</span><span class="s">0</span><span class="sh">'</span><span class="p">:</span>
                        <span class="n">all_num</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">num_str</span><span class="p">))</span>

<span class="n">all_num</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">all_num</span><span class="p">)</span>
<span class="n">all_num</span><span class="p">.</span><span class="nf">sort</span><span class="p">()</span>
</code></pre></div></div>

<h5 id="2-완다풀-포-구하기">2. 완다풀 포 구하기</h5>

<p>미리 중복 거르고 정렬해놔서 중복체크는 할 필요 없고<br />
리스트의 최대값보다 합이 커지면 더 탐색할 필요없이 break 한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">all_num</span><span class="p">)</span>
<span class="nb">max</span> <span class="o">=</span> <span class="n">all_num</span><span class="p">[</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># list 순회하며 s1 + s2 + s3 = s4 조건 확인
</span><span class="k">if</span> <span class="n">length</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
                <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">s3</span> <span class="o">=</span> <span class="n">all_num</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">all_num</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">all_num</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">s4</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span> <span class="o">+</span> <span class="n">s3</span>

                <span class="k">if</span> <span class="n">s4</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">:</span>
                    <span class="c1"># 최대 숫자보다 크면 탈출
</span>                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">s4</span> <span class="ow">in</span> <span class="n">all_num</span><span class="p">:</span>
                    <span class="n">r</span><span class="o">+=</span><span class="mi">1</span>

<span class="nf">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Python/2025-05-27-7106/img02.jpg" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>머리아파서 뇌비우고 하다가 그래도 더 잘할 수 있지 않나? 하는 마음에 탈출코드 추가해서 시간을 줄였다.<br />
이제 5중 나생문을 해체하려고 보는 순간 다시 머리가 아파서 관뒀다.<br />
휴식이 필요한 하루다…</p>

<p>얼마나 머리아프냐면 생각없이 파이썬 코드를 C++코드로 제출해서 컴파일 오류남</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/random-solve/Python/2025-05-27-7106.py">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="random-solve/Python/" /><summary type="html"><![CDATA[문제 7106번 Wonderful Fours - 백준 번역 브론즈 문제 하나, 텍스트 제출 문제 하나 거르고 나온 실버 문제. 내 그지같은 파이썬 실력에 알맞은 난이도다. 찬찬히 해석해보면… 십진수 숫자 5개를 K5라 부른다. 모두 사용하되 0으로 시작하지 않는 숫자를 만들면 그 숫자는 ‘적절히’ 만들어진 것이다. 그리고 아래 내용이 모두 참일 경우 완다풀 포가 된다. 4개의 5자리 자연수가 모두 적절하게 만들어짐 4개의 5자리 자연수는 모두 다른 숫자 s1 + s2 + s3 = s4 여기서 주어진 K5로 몇 개의 서로 다른 완다풀 포를 만들 수 있는지 계산하시오. 설계 뭐 방법이 있나? 숫자 크기도 작고 그냥 세개 뽑아서 합해서 찾아보면 되겠다. 중복 제거에만 신경쓰면 될 듯 구현 중복 제거를 고민해봤는데 처음부터 ‘적절한’ 숫자를 만들며 중복되는걸 날려버리면 끝이다. 1. 입력받아 ‘적절한’ 숫자 만들기 더 똑똑하게 할 수 있지만 겨우 숫자 다섯개로 하는거니 5중 나생문을 쌓았다. 중복 거르고 정렬. K5 = input().split() r = 0 # 적절한 숫자 생성(중복제외) all_num = set() # 몇개 안되고 귀찮으니 5중반복문 for i in range(5): for j in range(5): if j == i: continue for k in range(5): if k == i or k == j: continue for l in range(5): if l == i or l == j or l == k: continue for m in range(5): if m == i or m == j or m == k or m == l: continue num_str = K5[i] + K5[j] + K5[k] + K5[l] + K5[m] if num_str[0] != '0': all_num.add(int(num_str)) all_num = list(all_num) all_num.sort() 2. 완다풀 포 구하기 미리 중복 거르고 정렬해놔서 중복체크는 할 필요 없고 리스트의 최대값보다 합이 커지면 더 탐색할 필요없이 break 한다. length = len(all_num) max = all_num[length-1] # list 순회하며 s1 + s2 + s3 = s4 조건 확인 if length &gt;= 4: for i in range(length): for j in range(i + 1, length): for k in range(j + 1, length): s1, s2, s3 = all_num[i], all_num[j], all_num[k] s4 = s1 + s2 + s3 if s4 &gt; max: # 최대 숫자보다 크면 탈출 break if s4 in all_num: r+=1 print(r) 채점 반성 머리아파서 뇌비우고 하다가 그래도 더 잘할 수 있지 않나? 하는 마음에 탈출코드 추가해서 시간을 줄였다. 이제 5중 나생문을 해체하려고 보는 순간 다시 머리가 아파서 관뒀다. 휴식이 필요한 하루다… 얼마나 머리아프냐면 생각없이 파이썬 코드를 C++코드로 제출해서 컴파일 오류남 코드 확인 Link to GitHub]]></summary></entry><entry><title type="html">던전 생성기 01</title><link href="https://movingwoo.com/one-pan/javascript/2025/05/27/Dungeon-Generator-01.html" rel="alternate" type="text/html" title="던전 생성기 01" /><published>2025-05-27T02:00:00+00:00</published><updated>2025-05-27T02:00:00+00:00</updated><id>https://movingwoo.com/one-pan/javascript/2025/05/27/Dungeon%20Generator%2001</id><content type="html" xml:base="https://movingwoo.com/one-pan/javascript/2025/05/27/Dungeon-Generator-01.html"><![CDATA[<blockquote>
  <h4 id="개요">개요</h4>
  <hr />
</blockquote>

<p>신나는 던전 맵 생성기<br />
5종 알고리즘과 함께</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-설계">1. 설계</h5>

<p>던전 맵 생성 관련 대표 알고리즘에 대해 찾아보았다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">알고리즘</th>
      <th style="text-align: left">스타일</th>
      <th style="text-align: left">특징</th>
      <th style="text-align: left">용도</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">BSP (Binary Space Partitioning)</td>
      <td style="text-align: left">직사각형 방 + 복도</td>
      <td style="text-align: left">공간을 재귀적으로 분할, 각 방을 연결</td>
      <td style="text-align: left">방 중심의 던전, 구조적 배치</td>
    </tr>
    <tr>
      <td style="text-align: left">Random Walk (Drunkard’s Walk)</td>
      <td style="text-align: left">유기적 경로, 비정형</td>
      <td style="text-align: left">무작위 방향 이동, 비선형 구조</td>
      <td style="text-align: left">자연 동굴, 탐험 중심 던전</td>
    </tr>
    <tr>
      <td style="text-align: left">Cellular Automata</td>
      <td style="text-align: left">자연 동굴 형태, 굴곡 많음</td>
      <td style="text-align: left">셀 규칙 반복으로 패턴 정제</td>
      <td style="text-align: left">동굴 스타일 던전, 유기적 형태</td>
    </tr>
    <tr>
      <td style="text-align: left">Delaunay Triangulation + MST</td>
      <td style="text-align: left">방 중심 + 경로 연결</td>
      <td style="text-align: left">무작위 방 &gt; 삼각분할 &gt; 최소 연결</td>
      <td style="text-align: left">모든 방 연결 보장, 전략적 맵</td>
    </tr>
    <tr>
      <td style="text-align: left">Wave Function Collapse (WFC)</td>
      <td style="text-align: left">타일 기반, 정교한 제약</td>
      <td style="text-align: left">타일 제약 기반 패턴 구성</td>
      <td style="text-align: left">정교한 던전, 룰 기반 구조</td>
    </tr>
  </tbody>
</table>

<p>맵을 그릴 캔버스가 있는 html은 이전 미로 생성기의 것을 그대로 가져와서 사용한다.</p>

<h5 id="2-bsp-알고리즘">2. BSP 알고리즘</h5>

<p>BSP 알고리즘을 공간을 재귀적으로 분할한다.<br />
분할 과정이 이진트리 형태로 표현되며 방 설정을 통해 크기와 개수를 쉽게 조절 가능하다.<br />
통로는 각 방의 중심을 직선 또는 L자로 적당히 연결한다.</p>

<p>방이 완전히 랜덤한 위치에 생성되기 때문에 방의 중심을 연결하는 통로의 특성 상<br />
<span style="color: orange;"><strong>통로가 겹치기도 하고 두껍게 이어지기도 한다.</strong></span></p>

<p>또 현재 입구 생성을 [0, 0]에서 가장 가까운 셀로 해두었는데<br />
랜덤하게 생성되어 이어지는 구조 특성 상 통로가 가장 가까운 경우 통로에 입구가 생길 수도 있다.<br />
강제로 가까운 셀을 껴서 생성시키기에는 BSP의 취지에 맞지 않은 것 같고<br />
방과 통로를 구분할 수 있게 방 데이터를 가져오려면 공통함수로 쓰기 애매하다.<br />
그냥 복도에 입구가 생기면 운이 나쁜걸로…</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 방 클래스 정의</span>
<span class="kd">class</span> <span class="nc">Room</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">h</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">w</span> <span class="o">=</span> <span class="nx">w</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">h</span> <span class="o">=</span> <span class="nx">h</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 방의 중심 좌표</span>
  <span class="nf">center</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span>
      <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">w</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
      <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">h</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">// 다른 방과 겹치는지 판정</span>
  <span class="nf">intersects</span><span class="p">(</span><span class="nx">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return </span><span class="p">(</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">other</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">other</span><span class="p">.</span><span class="nx">w</span> <span class="o">&amp;&amp;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">w</span> <span class="o">&gt;</span> <span class="nx">other</span><span class="p">.</span><span class="nx">x</span> <span class="o">&amp;&amp;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">other</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">other</span><span class="p">.</span><span class="nx">h</span> <span class="o">&amp;&amp;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">h</span> <span class="o">&gt;</span> <span class="nx">other</span><span class="p">.</span><span class="nx">y</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
  
<span class="k">async</span> <span class="kd">function</span> <span class="nf">startBSP</span><span class="p">()</span> <span class="p">{</span>

  <span class="kd">const</span> <span class="nx">MIN_SIZE</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// 방 최소 크기</span>
  <span class="kd">const</span> <span class="nx">MAX_SIZE</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="c1">// 방 최대 크기</span>
  <span class="kd">const</span> <span class="nx">partitions</span> <span class="o">=</span> <span class="p">[{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">w</span><span class="p">:</span> <span class="nx">cols</span><span class="p">,</span> <span class="na">h</span><span class="p">:</span> <span class="nx">rows</span> <span class="p">}];</span>
  <span class="kd">const</span> <span class="nx">rooms</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// 생성된 방 목록</span>

  <span class="c1">// 공간을 재귀적으로 분할</span>
  <span class="k">async</span> <span class="kd">function</span> <span class="nf">splitSpace</span><span class="p">(</span><span class="nx">space</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">h</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">space</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">horizontal</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">;</span> <span class="c1">// 분할 방향 랜덤(수평/수직)</span>

    <span class="c1">// 더 이상 분할이 불가능할 때(최소 크기 이하)</span>
    <span class="k">if </span><span class="p">((</span><span class="nx">horizontal</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">MIN_SIZE</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="nx">horizontal</span> <span class="o">&amp;&amp;</span> <span class="nx">w</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">MIN_SIZE</span><span class="p">))</span> <span class="p">{</span>
      <span class="c1">// 방 생성 시도 (겹쳐서 실패할 경우 10회까지 재시도)</span>
      <span class="kd">let</span> <span class="nx">tryCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="kd">let</span> <span class="nx">room</span><span class="p">;</span>
      <span class="kd">let</span> <span class="nx">overlapped</span><span class="p">;</span>
      <span class="k">do</span> <span class="p">{</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">w</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">MIN_SIZE</span> <span class="o">||</span> <span class="nx">h</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">MIN_SIZE</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="c1">// 공간이 너무 작으면 중단</span>

        <span class="c1">// 방 크기 랜덤 (MIN_SIZE~MAX_SIZE), 위치도 랜덤(테두리와 1칸 이상 띄움)</span>
        <span class="kd">const</span> <span class="nx">rw</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span>
          <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">w</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="nx">MIN_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="nx">MIN_SIZE</span><span class="p">,</span>
          <span class="nx">MAX_SIZE</span>
        <span class="p">);</span>
        <span class="kd">const</span> <span class="nx">rh</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span>
          <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">h</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="nx">MIN_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="nx">MIN_SIZE</span><span class="p">,</span>
          <span class="nx">MAX_SIZE</span>
        <span class="p">);</span>
        <span class="kd">const</span> <span class="nx">rx</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">w</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="nx">rw</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">ry</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">h</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="nx">rh</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nx">room</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Room</span><span class="p">(</span><span class="nx">rx</span><span class="p">,</span> <span class="nx">ry</span><span class="p">,</span> <span class="nx">rw</span><span class="p">,</span> <span class="nx">rh</span><span class="p">);</span>
        <span class="nx">overlapped</span> <span class="o">=</span> <span class="nx">rooms</span><span class="p">.</span><span class="nf">some</span><span class="p">(</span><span class="nx">r</span> <span class="o">=&gt;</span> <span class="nx">room</span><span class="p">.</span><span class="nf">intersects</span><span class="p">(</span><span class="nx">r</span><span class="p">));</span>
        <span class="nx">tryCount</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">while </span><span class="p">(</span><span class="nx">overlapped</span> <span class="o">&amp;&amp;</span> <span class="nx">tryCount</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">);</span>

      <span class="c1">// 겹치지 않는 방만 생성</span>
      <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">overlapped</span> <span class="o">&amp;&amp;</span> <span class="nx">room</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">rooms</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">room</span><span class="p">);</span>
        <span class="c1">// 방 내부를 흰색칠</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">room</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">room</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">room</span><span class="p">.</span><span class="nx">h</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">room</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">room</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">room</span><span class="p">.</span><span class="nx">w</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">map</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="nf">drawCell</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
            <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 분할: 수평 또는 수직으로 영역을 나눔</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">horizontal</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 수평 분할</span>
      <span class="kd">const</span> <span class="nx">split</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">h</span> <span class="o">-</span> <span class="nx">MIN_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nx">MIN_SIZE</span><span class="p">);</span>
      <span class="kd">const</span> <span class="nx">top</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="na">h</span><span class="p">:</span> <span class="nx">split</span> <span class="p">};</span>
      <span class="kd">const</span> <span class="nx">bottom</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">split</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="na">h</span><span class="p">:</span> <span class="nx">h</span> <span class="o">-</span> <span class="nx">split</span> <span class="p">};</span>
      <span class="k">await</span> <span class="nf">splitSpace</span><span class="p">(</span><span class="nx">top</span><span class="p">);</span>
      <span class="k">await</span> <span class="nf">splitSpace</span><span class="p">(</span><span class="nx">bottom</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// 수직 분할</span>
      <span class="kd">const</span> <span class="nx">split</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">w</span> <span class="o">-</span> <span class="nx">MIN_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nx">MIN_SIZE</span><span class="p">);</span>
      <span class="kd">const</span> <span class="nx">left</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="na">w</span><span class="p">:</span> <span class="nx">split</span><span class="p">,</span> <span class="nx">h</span> <span class="p">};</span>
      <span class="kd">const</span> <span class="nx">right</span> <span class="o">=</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">split</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="na">w</span><span class="p">:</span> <span class="nx">w</span> <span class="o">-</span> <span class="nx">split</span><span class="p">,</span> <span class="nx">h</span> <span class="p">};</span>
      <span class="k">await</span> <span class="nf">splitSpace</span><span class="p">(</span><span class="nx">left</span><span class="p">);</span>
      <span class="k">await</span> <span class="nf">splitSpace</span><span class="p">(</span><span class="nx">right</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 터널 뚫는 함수</span>
  <span class="k">async</span> <span class="kd">function</span> <span class="nf">tunneling</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">dx</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sign</span><span class="p">(</span><span class="nx">x2</span> <span class="o">-</span> <span class="nx">x1</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">dy</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sign</span><span class="p">(</span><span class="nx">y2</span> <span class="o">-</span> <span class="nx">y1</span><span class="p">);</span>
    <span class="c1">// x축 방향으로 먼저 이동</span>
    <span class="k">while </span><span class="p">(</span><span class="nx">x1</span> <span class="o">!==</span> <span class="nx">x2</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">map</span><span class="p">[</span><span class="nx">y1</span><span class="p">][</span><span class="nx">x1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
      <span class="nx">x1</span> <span class="o">+=</span> <span class="nx">dx</span><span class="p">;</span>
      <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// y축 방향으로 이동</span>
    <span class="k">while </span><span class="p">(</span><span class="nx">y1</span> <span class="o">!==</span> <span class="nx">y2</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">map</span><span class="p">[</span><span class="nx">y1</span><span class="p">][</span><span class="nx">x1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
      <span class="nx">y1</span> <span class="o">+=</span> <span class="nx">dy</span><span class="p">;</span>
      <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">await</span> <span class="nf">splitSpace</span><span class="p">(</span><span class="nx">partitions</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

  <span class="c1">// 생성된 방들의 중심을 순서대로 복도로 연결</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">rooms</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">rooms</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="nf">center</span><span class="p">();</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">rooms</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nf">center</span><span class="p">();</span>

    <span class="k">if </span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">await</span> <span class="nf">tunneling</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y1</span><span class="p">);</span>
      <span class="k">await</span> <span class="nf">tunneling</span><span class="p">(</span><span class="nx">x2</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">await</span> <span class="nf">tunneling</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x1</span><span class="p">,</span> <span class="nx">y2</span><span class="p">);</span>
      <span class="k">await</span> <span class="nf">tunneling</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y2</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 입출구 생성</span>
  <span class="nf">generateEntrance</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="3-random-walk-알고리즘">3. Random Walk 알고리즘</h5>

<p>굉장히 간단한 알고리즘이다.<br />
이름에서 볼 수 있듯 방향을 랜덤으로 움직이며 길을 채우고<br />
정해둔 만큼 맵을 채우면 종료한다.</p>

<p>통로나 방이 곡선형으로 잘 생성되는데 랜덤으로 여기저기 쑤시다보니<br />
통로가 너무 좁을 수 있고 전체적인 구조를 제어하기 힙들다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nf">startRandomWalk</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">initMap</span><span class="p">();</span>
  
  <span class="c1">// 시작점 (중앙)</span>
  <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nx">cols</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nx">rows</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
  
  <span class="c1">// 방문한 셀 수를 추적</span>
  <span class="kd">let</span> <span class="nx">visitedCells</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">targetCells</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">((</span><span class="nx">cols</span> <span class="o">*</span> <span class="nx">rows</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.4</span><span class="p">);</span> <span class="c1">// 전체 셀의 40% 채우면 종료</span>
  
  <span class="c1">// 4방향 이동 </span>
  <span class="kd">const</span> <span class="nx">directions</span> <span class="o">=</span> <span class="p">[</span>
      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
      <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
      <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
  <span class="p">];</span>
  
  <span class="c1">// 현재 위치를 통로로 만들고 방문 표시</span>
  <span class="nx">map</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">visitedCells</span><span class="o">++</span><span class="p">;</span>
  
  <span class="k">while </span><span class="p">(</span><span class="nx">visitedCells</span> <span class="o">&lt;</span> <span class="nx">targetCells</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 랜덤한 방향 선택</span>
      <span class="kd">const</span> <span class="p">[</span><span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">]</span> <span class="o">=</span> <span class="nx">directions</span><span class="p">[</span><span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)];</span>
      <span class="kd">const</span> <span class="nx">newX</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">;</span>
      <span class="kd">const</span> <span class="nx">newY</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">;</span>
      
      <span class="c1">// 경계 체크</span>
      <span class="k">if </span><span class="p">(</span><span class="nx">newX</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">newX</span> <span class="o">&lt;</span> <span class="nx">cols</span> <span class="o">&amp;&amp;</span> <span class="nx">newY</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">newY</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// 새로운 위치가 벽이면 통로로 만들기</span>
          <span class="k">if </span><span class="p">(</span><span class="nx">map</span><span class="p">[</span><span class="nx">newY</span><span class="p">][</span><span class="nx">newX</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">map</span><span class="p">[</span><span class="nx">newY</span><span class="p">][</span><span class="nx">newX</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
              <span class="nf">drawCell</span><span class="p">(</span><span class="nx">newX</span><span class="p">,</span> <span class="nx">newY</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
              <span class="nx">visitedCells</span><span class="o">++</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="nx">x</span> <span class="o">=</span> <span class="nx">newX</span><span class="p">;</span>
          <span class="nx">y</span> <span class="o">=</span> <span class="nx">newY</span><span class="p">;</span>
      <span class="p">}</span>
      
      <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="nf">generateEntrance</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="4-cellular-automata-알고리즘">4. Cellular Automata 알고리즘</h5>

<p><span style="color: orange;"><strong>셀의 상태를 바탕으로 다음 상태를 결정해 갱신</strong></span>하는 알고리즘이다.</p>

<p>규칙은 어떻게 정하느냐에 따라 다르겠지마는<br />
초기에 랜덤하게 벽을 뚫어두고 4번에 거쳐 다듬어나간다.<br />
규칙은 아래와 같이 정했다.</p>
<ul>
  <li>현재 셀이 벽인데 주변 벽이 4개 이상이면 벽 유지, 그렇지 않으면 통로로 변경</li>
  <li>현재 셀이 통로인데 주변 벽이 5개 이상이변 벽으로 변경, 그렇지 않으면 통로 유지</li>
</ul>

<p>위 과정을 거쳐 자연스러운 동굴 형태의 맵이 완성된다.<br />
엄격한 규칙을 기반으로 다듬어나가기 때문에 뭔가 틀에 박힌 BSP와 자유롭게 칠렐레 팔렐레 뻗은 Random Walk보다 보기 좋다.</p>

<p>이 알고리즘도 고립된 공간이 생길 수 있는데 이는 추가적인 알고리즘을 통해 고립된 방과 통로로 연결하거나 제거하면 된다.<br />
하지만 이번 구현에서 그 부분은 패스.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nf">startCellularAutomata</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">initMap</span><span class="p">();</span>
  
  <span class="c1">// 초기 랜덤 상태 생성 (약 45%의 벽)</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// 테두리는 벽으로 설정</span>
          <span class="k">if </span><span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">x</span> <span class="o">===</span> <span class="nx">cols</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">===</span> <span class="nx">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">map</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
              <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span><span class="p">);</span>
          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
              <span class="nx">map</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.45</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
              <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">map</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
  
  <span class="c1">// Cellular Automata 규칙 적용 (4회 반복)</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">generation</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">generation</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="nx">generation</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">newMap</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">({</span> <span class="na">length</span><span class="p">:</span> <span class="nx">rows</span> <span class="p">},</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nc">Array</span><span class="p">(</span><span class="nx">cols</span><span class="p">).</span><span class="nf">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
      
      <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// 테두리는 벽 유지</span>
              <span class="k">if </span><span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">x</span> <span class="o">===</span> <span class="nx">cols</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">===</span> <span class="nx">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">newMap</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                  <span class="k">continue</span><span class="p">;</span>
              <span class="p">}</span>
              
              <span class="c1">// 주변 8칸의 벽 개수 세기</span>
              <span class="kd">let</span> <span class="nx">wallCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
              <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">dy</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">dy</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">dy</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">dx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">dx</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">dx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">if </span><span class="p">(</span><span class="nx">dx</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">dy</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
                      <span class="k">if </span><span class="p">(</span><span class="nx">map</span><span class="p">[</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">][</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="nx">wallCount</span><span class="o">++</span><span class="p">;</span>
                  <span class="p">}</span>
              <span class="p">}</span>
              
              <span class="c1">//현재 셀이 벽인데 주변 벽이 4개 이상이면 벽 유지, 그렇지 않으면 통로로 변경</span>
              <span class="c1">//현재 셀이 통로인데 주변 벽이 5개 이상이변 벽으로 변경, 그렇지 않으면 통로 유지</span>
              <span class="k">if </span><span class="p">(</span><span class="nx">map</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">newMap</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nx">wallCount</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
              <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                  <span class="nx">newMap</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nx">wallCount</span> <span class="o">&gt;=</span> <span class="mi">5</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
              <span class="p">}</span>
              
              <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">newMap</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
              <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">}</span>
      
      <span class="nx">map</span> <span class="o">=</span> <span class="nx">newMap</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="nf">generateEntrance</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="완성">완성</h4>
  <hr />
</blockquote>

<p>BSP<br />
<img src="/assets/images/posts/one-pan/JavaScript/2025-05-27-Dungeon Generator 01/img01.gif" alt="img01" /></p>

<p>Random Walk<br />
<img src="/assets/images/posts/one-pan/JavaScript/2025-05-27-Dungeon Generator 01/img02.gif" alt="img02" /></p>

<p>Cellular Automata<br />
<img src="/assets/images/posts/one-pan/JavaScript/2025-05-27-Dungeon Generator 01/img03.gif" alt="img03" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>Random Walk 알고리즘과 Cellular Automata 알고리즘을 구현하며 즐거워졌다.<br />
오래된 피쳐폰게임의 작은 미니맵을 보는 기분이다.<br />
아 마음이 충만해진다…</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="/play/Dungeon%20Generator.html" target="_blank" rel="noopener noreferrer">
  직접 해보기
</a></p>

<p>BSP<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-27-BSP.js">Link to GitHub</a></p>

<p>Random Walk<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-27-RandomWalk.js">Link to GitHub</a></p>

<p>Cellular Automata<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-27-CellularAutomata.js">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="one-pan/JavaScript/" /><summary type="html"><![CDATA[개요 신나는 던전 맵 생성기 5종 알고리즘과 함께 구현 1. 설계 던전 맵 생성 관련 대표 알고리즘에 대해 찾아보았다. 알고리즘 스타일 특징 용도 BSP (Binary Space Partitioning) 직사각형 방 + 복도 공간을 재귀적으로 분할, 각 방을 연결 방 중심의 던전, 구조적 배치 Random Walk (Drunkard’s Walk) 유기적 경로, 비정형 무작위 방향 이동, 비선형 구조 자연 동굴, 탐험 중심 던전 Cellular Automata 자연 동굴 형태, 굴곡 많음 셀 규칙 반복으로 패턴 정제 동굴 스타일 던전, 유기적 형태 Delaunay Triangulation + MST 방 중심 + 경로 연결 무작위 방 &gt; 삼각분할 &gt; 최소 연결 모든 방 연결 보장, 전략적 맵 Wave Function Collapse (WFC) 타일 기반, 정교한 제약 타일 제약 기반 패턴 구성 정교한 던전, 룰 기반 구조 맵을 그릴 캔버스가 있는 html은 이전 미로 생성기의 것을 그대로 가져와서 사용한다. 2. BSP 알고리즘 BSP 알고리즘을 공간을 재귀적으로 분할한다. 분할 과정이 이진트리 형태로 표현되며 방 설정을 통해 크기와 개수를 쉽게 조절 가능하다. 통로는 각 방의 중심을 직선 또는 L자로 적당히 연결한다. 방이 완전히 랜덤한 위치에 생성되기 때문에 방의 중심을 연결하는 통로의 특성 상 통로가 겹치기도 하고 두껍게 이어지기도 한다. 또 현재 입구 생성을 [0, 0]에서 가장 가까운 셀로 해두었는데 랜덤하게 생성되어 이어지는 구조 특성 상 통로가 가장 가까운 경우 통로에 입구가 생길 수도 있다. 강제로 가까운 셀을 껴서 생성시키기에는 BSP의 취지에 맞지 않은 것 같고 방과 통로를 구분할 수 있게 방 데이터를 가져오려면 공통함수로 쓰기 애매하다. 그냥 복도에 입구가 생기면 운이 나쁜걸로… // 방 클래스 정의 class Room { constructor(x, y, w, h) { this.x = x; this.y = y; this.w = w; this.h = h; } // 방의 중심 좌표 center() { return [ Math.floor(this.x + this.w / 2), Math.floor(this.y + this.h / 2) ]; } // 다른 방과 겹치는지 판정 intersects(other) { return ( this.x &lt; other.x + other.w &amp;&amp; this.x + this.w &gt; other.x &amp;&amp; this.y &lt; other.y + other.h &amp;&amp; this.y + this.h &gt; other.y ); } } async function startBSP() { const MIN_SIZE = 4; // 방 최소 크기 const MAX_SIZE = 6; // 방 최대 크기 const partitions = [{ x: 0, y: 0, w: cols, h: rows }]; const rooms = []; // 생성된 방 목록 // 공간을 재귀적으로 분할 async function splitSpace(space) { const { x, y, w, h } = space; const horizontal = Math.random() &lt; 0.5; // 분할 방향 랜덤(수평/수직) // 더 이상 분할이 불가능할 때(최소 크기 이하) if ((horizontal &amp;&amp; h &lt;= 2 * MIN_SIZE) || (!horizontal &amp;&amp; w &lt;= 2 * MIN_SIZE)) { // 방 생성 시도 (겹쳐서 실패할 경우 10회까지 재시도) let tryCount = 0; let room; let overlapped; do { if (w - 2 &lt; MIN_SIZE || h - 2 &lt; MIN_SIZE) break; // 공간이 너무 작으면 중단 // 방 크기 랜덤 (MIN_SIZE~MAX_SIZE), 위치도 랜덤(테두리와 1칸 이상 띄움) const rw = Math.min( Math.floor(Math.random() * (w - 2 - MIN_SIZE + 1)) + MIN_SIZE, MAX_SIZE ); const rh = Math.min( Math.floor(Math.random() * (h - 2 - MIN_SIZE + 1)) + MIN_SIZE, MAX_SIZE ); const rx = Math.floor(Math.random() * (w - 2 - rw + 1)) + x + 1; const ry = Math.floor(Math.random() * (h - 2 - rh + 1)) + y + 1; room = new Room(rx, ry, rw, rh); overlapped = rooms.some(r =&gt; room.intersects(r)); tryCount++; } while (overlapped &amp;&amp; tryCount &lt; 10); // 겹치지 않는 방만 생성 if (!overlapped &amp;&amp; room) { rooms.push(room); // 방 내부를 흰색칠 for (let i = room.y; i &lt; room.y + room.h; i++) { for (let j = room.x; j &lt; room.x + room.w; j++) { map[i][j] = 0; drawCell(j, i, 'white'); await sleep(1); } } } return; } // 분할: 수평 또는 수직으로 영역을 나눔 if (horizontal) { // 수평 분할 const split = Math.floor(Math.random() * (h - MIN_SIZE * 2) + MIN_SIZE); const top = { x, y, w, h: split }; const bottom = { x, y: y + split, w, h: h - split }; await splitSpace(top); await splitSpace(bottom); } else { // 수직 분할 const split = Math.floor(Math.random() * (w - MIN_SIZE * 2) + MIN_SIZE); const left = { x, y, w: split, h }; const right = { x: x + split, y, w: w - split, h }; await splitSpace(left); await splitSpace(right); } } // 터널 뚫는 함수 async function tunneling(x1, y1, x2, y2) { const dx = Math.sign(x2 - x1); const dy = Math.sign(y2 - y1); // x축 방향으로 먼저 이동 while (x1 !== x2) { map[y1][x1] = 0; drawCell(x1, y1, 'white'); x1 += dx; await sleep(1); } // y축 방향으로 이동 while (y1 !== y2) { map[y1][x1] = 0; drawCell(x1, y1, 'white'); y1 += dy; await sleep(1); } } await splitSpace(partitions[0]); // 생성된 방들의 중심을 순서대로 복도로 연결 for (let i = 1; i &lt; rooms.length; i++) { const [x1, y1] = rooms[i - 1].center(); const [x2, y2] = rooms[i].center(); if (Math.random() &lt; 0.5) { await tunneling(x1, y1, x2, y1); await tunneling(x2, y1, x2, y2); } else { await tunneling(x1, y1, x1, y2); await tunneling(x1, y2, x2, y2); } } // 입출구 생성 generateEntrance(); } 3. Random Walk 알고리즘 굉장히 간단한 알고리즘이다. 이름에서 볼 수 있듯 방향을 랜덤으로 움직이며 길을 채우고 정해둔 만큼 맵을 채우면 종료한다. 통로나 방이 곡선형으로 잘 생성되는데 랜덤으로 여기저기 쑤시다보니 통로가 너무 좁을 수 있고 전체적인 구조를 제어하기 힙들다. async function startRandomWalk() { initMap(); // 시작점 (중앙) let x = Math.floor(cols / 2); let y = Math.floor(rows / 2); // 방문한 셀 수를 추적 let visitedCells = 0; const targetCells = Math.floor((cols * rows) * 0.4); // 전체 셀의 40% 채우면 종료 // 4방향 이동 const directions = [ [0, -1], [1, 0], [0, 1], [-1, 0] ]; // 현재 위치를 통로로 만들고 방문 표시 map[y][x] = 0; drawCell(x, y, 'white'); visitedCells++; while (visitedCells &lt; targetCells) { // 랜덤한 방향 선택 const [dx, dy] = directions[Math.floor(Math.random() * 4)]; const newX = x + dx; const newY = y + dy; // 경계 체크 if (newX &gt;= 0 &amp;&amp; newX &lt; cols &amp;&amp; newY &gt;= 0 &amp;&amp; newY &lt; rows) { // 새로운 위치가 벽이면 통로로 만들기 if (map[newY][newX] === 1) { map[newY][newX] = 0; drawCell(newX, newY, 'white'); visitedCells++; } x = newX; y = newY; } await sleep(1); } generateEntrance(); } 4. Cellular Automata 알고리즘 셀의 상태를 바탕으로 다음 상태를 결정해 갱신하는 알고리즘이다. 규칙은 어떻게 정하느냐에 따라 다르겠지마는 초기에 랜덤하게 벽을 뚫어두고 4번에 거쳐 다듬어나간다. 규칙은 아래와 같이 정했다. 현재 셀이 벽인데 주변 벽이 4개 이상이면 벽 유지, 그렇지 않으면 통로로 변경 현재 셀이 통로인데 주변 벽이 5개 이상이변 벽으로 변경, 그렇지 않으면 통로 유지 위 과정을 거쳐 자연스러운 동굴 형태의 맵이 완성된다. 엄격한 규칙을 기반으로 다듬어나가기 때문에 뭔가 틀에 박힌 BSP와 자유롭게 칠렐레 팔렐레 뻗은 Random Walk보다 보기 좋다. 이 알고리즘도 고립된 공간이 생길 수 있는데 이는 추가적인 알고리즘을 통해 고립된 방과 통로로 연결하거나 제거하면 된다. 하지만 이번 구현에서 그 부분은 패스. async function startCellularAutomata() { initMap(); // 초기 랜덤 상태 생성 (약 45%의 벽) for (let y = 0; y &lt; rows; y++) { for (let x = 0; x &lt; cols; x++) { // 테두리는 벽으로 설정 if (x === 0 || x === cols - 1 || y === 0 || y === rows - 1) { map[y][x] = 1; drawCell(x, y, 'black'); } else { map[y][x] = Math.random() &lt; 0.45 ? 1 : 0; drawCell(x, y, map[y][x] === 1 ? 'black' : 'white'); } await sleep(1); } } // Cellular Automata 규칙 적용 (4회 반복) for (let generation = 0; generation &lt; 4; generation++) { const newMap = Array.from({ length: rows }, () =&gt; Array(cols).fill(0)); for (let y = 0; y &lt; rows; y++) { for (let x = 0; x &lt; cols; x++) { // 테두리는 벽 유지 if (x === 0 || x === cols - 1 || y === 0 || y === rows - 1) { newMap[y][x] = 1; continue; } // 주변 8칸의 벽 개수 세기 let wallCount = 0; for (let dy = -1; dy &lt;= 1; dy++) { for (let dx = -1; dx &lt;= 1; dx++) { if (dx === 0 &amp;&amp; dy === 0) continue; if (map[y + dy][x + dx] === 1) wallCount++; } } //현재 셀이 벽인데 주변 벽이 4개 이상이면 벽 유지, 그렇지 않으면 통로로 변경 //현재 셀이 통로인데 주변 벽이 5개 이상이변 벽으로 변경, 그렇지 않으면 통로 유지 if (map[y][x] === 1) { newMap[y][x] = wallCount &gt;= 4 ? 1 : 0; } else { newMap[y][x] = wallCount &gt;= 5 ? 1 : 0; } drawCell(x, y, newMap[y][x] === 1 ? 'black' : 'white'); await sleep(1); } } map = newMap; } generateEntrance(); } 완성 BSP Random Walk Cellular Automata 반성 Random Walk 알고리즘과 Cellular Automata 알고리즘을 구현하며 즐거워졌다. 오래된 피쳐폰게임의 작은 미니맵을 보는 기분이다. 아 마음이 충만해진다… 코드 확인 직접 해보기 BSP Link to GitHub Random Walk Link to GitHub Cellular Automata Link to GitHub]]></summary></entry><entry><title type="html">5101번 Sequences</title><link href="https://movingwoo.com/random-solve/python/2025/05/23/5101.html" rel="alternate" type="text/html" title="5101번 Sequences" /><published>2025-05-23T07:00:00+00:00</published><updated>2025-05-23T07:00:00+00:00</updated><id>https://movingwoo.com/random-solve/python/2025/05/23/5101</id><content type="html" xml:base="https://movingwoo.com/random-solve/python/2025/05/23/5101.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Python/2025-05-23-5101/img01.jpg" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/5101">5101번 Sequences - 백준</a></p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>음 쉬운 문제<br />
하루의 마무리로 딱이다.</p>

<p>시작 숫자와 차이가 주어지고 다음 숫자가 수열의 항인지 판단하는 문제이다.</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<p>단순 덧셈 반복해도 문제없지만 조금 더 스마트하게 해봐야지.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">());</span>

    <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">break</span>

    <span class="c1"># b가 0이면 예외처리
</span>    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">c</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">X</span><span class="sh">"</span><span class="p">)</span>
    <span class="c1"># 음수 고려
</span>    <span class="nf">elif </span><span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">%</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">//</span> <span class="n">b</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">((</span><span class="n">c</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">//</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">X</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Python/2025-05-23-5101/img02.jpg" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>아무래도 랜덤 돌려서 브론즈 문제 나오면 좀 거르는게 좋겠다.<br />
이것도 일종의 탄소 과잉배출로 볼 수 있지 않나?</p>

<p>앞으로 랜덤백준디펜스의 브론즈 문제가 걸리면 다 거르는 것으로 해야겠다.<br />
이건 뭐 깃에 코드 올리기도 뭐하고</p>]]></content><author><name>movingwoo</name></author><category term="random-solve/Python/" /><summary type="html"><![CDATA[문제 5101번 Sequences - 백준 설계 음 쉬운 문제 하루의 마무리로 딱이다. 시작 숫자와 차이가 주어지고 다음 숫자가 수열의 항인지 판단하는 문제이다. 구현 단순 덧셈 반복해도 문제없지만 조금 더 스마트하게 해봐야지. while True: a, b, c = map(int, input().split()); if a == 0 and b == 0 and c == 0: break # b가 0이면 예외처리 if b == 0: if a == c: print(1) else: print("X") # 음수 고려 elif (c - a) % b == 0 and (c - a) // b &gt;= 0: print((c - a) // b + 1) else: print("X") 채점 반성 아무래도 랜덤 돌려서 브론즈 문제 나오면 좀 거르는게 좋겠다. 이것도 일종의 탄소 과잉배출로 볼 수 있지 않나? 앞으로 랜덤백준디펜스의 브론즈 문제가 걸리면 다 거르는 것으로 해야겠다. 이건 뭐 깃에 코드 올리기도 뭐하고]]></summary></entry><entry><title type="html">27391번 Platform Placing</title><link href="https://movingwoo.com/random-solve/java/2025/05/23/27391.html" rel="alternate" type="text/html" title="27391번 Platform Placing" /><published>2025-05-23T06:00:00+00:00</published><updated>2025-05-23T06:00:00+00:00</updated><id>https://movingwoo.com/random-solve/java/2025/05/23/27391</id><content type="html" xml:base="https://movingwoo.com/random-solve/java/2025/05/23/27391.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Java/2025-05-23-27391/img01.jpg" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/27391">27391번 Platform Placing - 백준</a></p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>한글 문제 언제 나오나?</p>

<p>플랫폼을 설치하는데 x-l/2, x+l/2 크기를 차지한다.<br />
양쪽으로 펼쳐진다는 뜻.<br />
최소값과 최대값이 정해져 있고 플랫폼 사이의 공간이 있어도 되고 딱 붙어도 되지만 겹치는건 안된다.<br />
모든 고정지점마다 플랫폼 하나 설치가 가능하다.<br />
이때 플랫폼 길이의 총합이 최대가 되도록 하시오.</p>

<p>대충 그리디 알고리즘 ㄱㄱ</p>

<p>당연히 각 위치마다 최대 길이를 설치하는 것이 좋을 것이다.<br />
고정 지점들을 정렬해 순차적으로 길이를 할당하되<br />
이전 플랫폼과 겹치지 않는 한에서 가장 큰 값을 선택해 할당한다.</p>

<p>해결 불가능 시 -1 출력인데 두 지점 간격이 s보다 작을 경우 불가능 처리하면 되겠다.</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-입력-받기">1. 입력 받기</h5>

<p>제한시간은 항상 두려우니 버퍼로 입력받고<br />
플랫폼 배열은 오름차순 정렬, 길이 배열은 최대값으로 채워둔다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    	
    	<span class="k">try</span><span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
	        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
	        
	        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">(),</span> <span class="s">" "</span><span class="o">);</span>
	        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
	        <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
	        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
	        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	        
	        <span class="kt">int</span><span class="o">[]</span> <span class="n">platforms</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
	        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
	        	<span class="n">platforms</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
	        <span class="o">}</span>
	        <span class="c1">// 오름차순</span>
	        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">platforms</span><span class="o">);</span>
	        
	        <span class="kt">int</span><span class="o">[]</span> <span class="n">lengths</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
	        <span class="c1">// 최대길이로 일단 채우고 시작</span>
	        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">lengths</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
	        
	    <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
	        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
	    <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<h5 id="2-플랫폼-배열-탐색">2. 플랫폼 배열 탐색</h5>

<p>플랫폼은 양쪽으로 펼쳐지므로 최대 길이는 2를 곱해서 봐야한다.<br />
배치 불가능하면 -1을 즉시 출력하고<br />
가능하면 현재길이를 우선적으로 조정, 현재길이를 최대로 줄여도 안되면 이전 플랫폼 길이를 줄인다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">platforms</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">platforms</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
    <span class="c1">// 플랫폼이 양쪽으로 펼쳐짐</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dist</span><span class="o">;</span>

    <span class="c1">// 불가능한 경우</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">max</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"-1"</span><span class="o">);</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 이전 길이와 현재 길이의 합이 max를 넘지 않도록 조정</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">lengths</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">lengths</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">lengths</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">lengths</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">max</span> <span class="o">-</span> <span class="n">lengths</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]));</span>

        <span class="c1">// 여전히 안 되면 lengths[i]를 최대한 줄여서 해결 안되면 length[i-1] 조절을 해야함</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">lengths</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">lengths</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">lengths</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">max</span> <span class="o">-</span> <span class="n">lengths</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">length</span> <span class="o">:</span> <span class="n">lengths</span><span class="o">)</span> <span class="n">result</span> <span class="o">+=</span> <span class="n">length</span><span class="o">;</span>
<span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">result</span><span class="o">));</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Java/2025-05-23-27391/img02.jpg" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>기분좋게 잘 해결되었다.<br />
C++ 하다가 Java 하니 잘쳐지는 것도 있고 그리디 알고리즘도 재밌고</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/random-solve/Java/2025-05-23-27391.java">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="random-solve/Java/" /><summary type="html"><![CDATA[문제 27391번 Platform Placing - 백준 설계 한글 문제 언제 나오나? 플랫폼을 설치하는데 x-l/2, x+l/2 크기를 차지한다. 양쪽으로 펼쳐진다는 뜻. 최소값과 최대값이 정해져 있고 플랫폼 사이의 공간이 있어도 되고 딱 붙어도 되지만 겹치는건 안된다. 모든 고정지점마다 플랫폼 하나 설치가 가능하다. 이때 플랫폼 길이의 총합이 최대가 되도록 하시오. 대충 그리디 알고리즘 ㄱㄱ 당연히 각 위치마다 최대 길이를 설치하는 것이 좋을 것이다. 고정 지점들을 정렬해 순차적으로 길이를 할당하되 이전 플랫폼과 겹치지 않는 한에서 가장 큰 값을 선택해 할당한다. 해결 불가능 시 -1 출력인데 두 지점 간격이 s보다 작을 경우 불가능 처리하면 되겠다. 구현 1. 입력 받기 제한시간은 항상 두려우니 버퍼로 입력받고 플랫폼 배열은 오름차순 정렬, 길이 배열은 최대값으로 채워둔다. public static void main(String[] args) { try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out))) { StringTokenizer st = new StringTokenizer(br.readLine(), " "); int n = Integer.parseInt(st.nextToken()); int s = Integer.parseInt(st.nextToken()); int k = Integer.parseInt(st.nextToken()); int result = 0; int[] platforms = new int[n]; for(int i = 0 ; i &lt; n ; i++) { platforms[i] = Integer.parseInt(br.readLine()); } // 오름차순 Arrays.sort(platforms); int[] lengths = new int[n]; // 최대길이로 일단 채우고 시작 Arrays.fill(lengths, k); }catch(IOException e) { e.printStackTrace(); } } 2. 플랫폼 배열 탐색 플랫폼은 양쪽으로 펼쳐지므로 최대 길이는 2를 곱해서 봐야한다. 배치 불가능하면 -1을 즉시 출력하고 가능하면 현재길이를 우선적으로 조정, 현재길이를 최대로 줄여도 안되면 이전 플랫폼 길이를 줄인다. for (int i = 1 ; i &lt; n ; i++) { int dist = platforms[i] - platforms[i - 1]; // 플랫폼이 양쪽으로 펼쳐짐 int max = 2 * dist; // 불가능한 경우 if (max &lt; 2 * s) { bw.write("-1"); return; } // 이전 길이와 현재 길이의 합이 max를 넘지 않도록 조정 if (lengths[i - 1] + lengths[i] &gt; max) { lengths[i] = Math.max(s, Math.min(lengths[i], max - lengths[i - 1])); // 여전히 안 되면 lengths[i]를 최대한 줄여서 해결 안되면 length[i-1] 조절을 해야함 if (lengths[i - 1] + lengths[i] &gt; max) { lengths[i - 1] = Math.max(s, max - lengths[i]); } } } for (int length : lengths) result += length; bw.write(String.valueOf(result)); 채점 반성 기분좋게 잘 해결되었다. C++ 하다가 Java 하니 잘쳐지는 것도 있고 그리디 알고리즘도 재밌고 코드 확인 Link to GitHub]]></summary></entry><entry><title type="html">25245번 Amusement Arcade</title><link href="https://movingwoo.com/random-solve/c++/2025/05/23/25245.html" rel="alternate" type="text/html" title="25245번 Amusement Arcade" /><published>2025-05-23T05:00:00+00:00</published><updated>0225-05-23T05:00:00+00:00</updated><id>https://movingwoo.com/random-solve/c++/2025/05/23/25245</id><content type="html" xml:base="https://movingwoo.com/random-solve/c++/2025/05/23/25245.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/C++/2025-05-23-25245/img01.jpg" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/25245">25245번 Amusement Arcade - 백준</a></p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>n개의 오락기가 있다.(n은 홀수)<br />
사람이 앉아야하는데 반드시 오락기에 한 칸씩 비우고 앉아야한다.<br />
도착하는 사람은 사람이 있는 곳에서 가장 멀리 떨어진 자리를 고르며, 여러개라면 무작위로 선택한다.</p>

<p>이때 줄리아가 가장 먼저 앉을 적절한 위치를 고르시오.</p>

<p>n은 반드시 홀수고 한 칸씩 비우면 최대 인원은 (n + 1) / 2 이다.<br />
줄리아가 대충 n / 2 + 1 위치인 중앙에 앉으면 impossible이 나올 조건은 없어보이는데…<br />
예제에서는 15를 넣을 시 impossible이 나온다.</p>

<p><span style="color: orange;"><strong>사람에서 최대한 멀리 떨어진 곳에 앉으려는 좋지 않은 습성</strong></span> 때문인데…<br />
실제 15를 받아 줄리아를 8번에 앉힐 경우<br />
[1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1]
이 상황에서 정확히 한 칸 조건이 깨져버린다!</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-시뮬레이션">1. 시뮬레이션</h5>

<p>제한시간이 빡빡해서 단순 시뮬레이션은 아닌 것 같다.<br />
일단 대충 코드짜서 순열 규칙 확인 ㄱㄱ</p>

<p>줄리아의 자리는 모든 홀수 자리를 탐색해서 앉혀본다.<br />
단순히 n / 2 + 1 에만 앉을 경우 7을 넣으면 4에 앉아야 하는데 그러면 오답이 나온다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">simulate</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">where</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">;</span> <span class="n">k</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">seats</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
        <span class="c1">// 줄리아가 앉을 자리</span>
        <span class="n">seats</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">people</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">people</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 현재 가능한 자리들 중 가장 큰 최소 거리</span>
            <span class="kt">int</span> <span class="n">max_dist</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">candidates</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">seats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="kt">int</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>

                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">seats</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                        <span class="c1">// 가장 가까운 사람과의 거리</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">abs</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">));</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="c1">// 현재 자리가 이전보다 더 멀리 떨어져 있다면 새로운 후보, 같으면 추가</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&gt;</span> <span class="n">max_dist</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">max_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">;</span>
                    <span class="n">candidates</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
                    <span class="n">candidates</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">==</span> <span class="n">max_dist</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">candidates</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="c1">// 후보자리가 없으면 끝</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">candidates</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">candidates</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// 홀수 자리에 앉지 못하면 의미 없음</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
                    <span class="n">seats</span><span class="p">[</span><span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            
            <span class="n">people</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 최종 상태가 x . x . x ... 패턴인지 확인</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">seats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">seats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">where</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">where</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">31</span> <span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" : "</span> <span class="o">&lt;&lt;</span> <span class="n">simulate</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>시뮬레이션 결과는 아래와 같다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">n</th>
      <th style="text-align: center">줄리아</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">7</td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center">9</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">11</td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center">13</td>
      <td style="text-align: center">5</td>
    </tr>
    <tr>
      <td style="text-align: center">15</td>
      <td style="text-align: center">impossible</td>
    </tr>
    <tr>
      <td style="text-align: center">17</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">19</td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center">21</td>
      <td style="text-align: center">5</td>
    </tr>
    <tr>
      <td style="text-align: center">23</td>
      <td style="text-align: center">impossible</td>
    </tr>
    <tr>
      <td style="text-align: center">25</td>
      <td style="text-align: center">9</td>
    </tr>
    <tr>
      <td style="text-align: center">27</td>
      <td style="text-align: center">impossible</td>
    </tr>
    <tr>
      <td style="text-align: center">29</td>
      <td style="text-align: center">impossible</td>
    </tr>
    <tr>
      <td style="text-align: center">31</td>
      <td style="text-align: center">impossible</td>
    </tr>
  </tbody>
</table>

<p>예제는 다 맞는다.</p>

<h5 id="2-규칙-찾기">2. 규칙 찾기</h5>

<p>가설 1: <span style="color: orange;"><strong>n = 2^k + 1 (k &gt; 0)</strong></span> 인 경우 답은 반드시 1이다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">n</th>
      <th style="text-align: center">줄리아</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">9</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">17</td>
      <td style="text-align: center">1</td>
    </tr>
  </tbody>
</table>

<p>가설 2: <span style="color: orange;"><strong>n != 2^a + 2^b + 1</strong></span> 인 경우 배치가 불가능하다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">n</th>
      <th style="text-align: center">줄리아</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">15</td>
      <td style="text-align: center">impossible</td>
    </tr>
    <tr>
      <td style="text-align: center">23</td>
      <td style="text-align: center">impossible</td>
    </tr>
    <tr>
      <td style="text-align: center">27</td>
      <td style="text-align: center">impossible</td>
    </tr>
    <tr>
      <td style="text-align: center">29</td>
      <td style="text-align: center">impossible</td>
    </tr>
    <tr>
      <td style="text-align: center">31</td>
      <td style="text-align: center">impossible</td>
    </tr>
  </tbody>
</table>

<p>이부분은 <span style="color: orange;"><strong>n + 1의 이진수 1의 개수가 3 이상이면 불가능</strong></span>으로 처리할 수 있다.</p>

<p>가설 3: 그 외의 경우는 시뮬레이션을 하되, 2^k + 1 인 자리만 대상으로 한다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">n</th>
      <th style="text-align: center">줄리아</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">7</td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center">11</td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center">13</td>
      <td style="text-align: center">5</td>
    </tr>
    <tr>
      <td style="text-align: center">19</td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center">21</td>
      <td style="text-align: center">5</td>
    </tr>
    <tr>
      <td style="text-align: center">25</td>
      <td style="text-align: center">9</td>
    </tr>
  </tbody>
</table>

<h5 id="2-구현">2. 구현</h5>

<p>가설 1, 2를 넘었을 경우 시뮬레이션을 해야하는데<br />
n이 10^18까지 있으므로 평범하게 하면 바로 시간초과다.<br />
어차피 꽉 채워 앉으면 완전 이진트리 구조가 되므로 줄리아 배치 기준 양쪽을 반으로 계속 나눌 수 있는지만 확인하면 된다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 가설 1: n == 2^k + 1 이면 반드시 줄리아는 1번 자리에 앉으면 됨</span>
<span class="kt">bool</span> <span class="nf">hypothesis_1</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 가설 2: n == 2^a + 2^b + 1 형태인지 확인</span>
<span class="c1">// n - 1 == 2^a + 2^b 라면 가능성 있음</span>
<span class="kt">bool</span> <span class="nf">hypothesis_2</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int64_t</span> <span class="n">x</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// 균등분할이 가능할지</span>
<span class="kt">bool</span> <span class="nf">can_seat</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">can_seat</span><span class="p">((</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int64_t</span> <span class="nf">solve</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 짝수일 경우 패스</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 가설 1</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hypothesis_1</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 가설 2</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hypothesis_2</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 가설 3</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">64</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="kt">int64_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1LL</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">can_seat</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">can_seat</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/C++/2025-05-23-25245/img02.jpg" alt="img02" /></p>

<p>허허 정답비율 나 혼자 다깎아먹었넹</p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>반복문 조건도 잘 못잡고 균등분할 조건도 잘 못잡고<br />
제대로 했으면 덜 틀렸을걸 실컷 틀렸다.<br />
아주 고봉밥이다 어우 배불러</p>

<p>근데 분명 더 멋진 풀이가 있을거란 말이지<br />
맞힌 사람 보면 코드 길이가 심상치가 않다.</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/random-solve/C%2B%2B/2025-05-23-25245.cpp">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="random-solve/C++/" /><summary type="html"><![CDATA[문제 25245번 Amusement Arcade - 백준 설계 n개의 오락기가 있다.(n은 홀수) 사람이 앉아야하는데 반드시 오락기에 한 칸씩 비우고 앉아야한다. 도착하는 사람은 사람이 있는 곳에서 가장 멀리 떨어진 자리를 고르며, 여러개라면 무작위로 선택한다. 이때 줄리아가 가장 먼저 앉을 적절한 위치를 고르시오. n은 반드시 홀수고 한 칸씩 비우면 최대 인원은 (n + 1) / 2 이다. 줄리아가 대충 n / 2 + 1 위치인 중앙에 앉으면 impossible이 나올 조건은 없어보이는데… 예제에서는 15를 넣을 시 impossible이 나온다. 사람에서 최대한 멀리 떨어진 곳에 앉으려는 좋지 않은 습성 때문인데… 실제 15를 받아 줄리아를 8번에 앉힐 경우 [1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1] 이 상황에서 정확히 한 칸 조건이 깨져버린다! 구현 1. 시뮬레이션 제한시간이 빡빡해서 단순 시뮬레이션은 아닌 것 같다. 일단 대충 코드짜서 순열 규칙 확인 ㄱㄱ 줄리아의 자리는 모든 홀수 자리를 탐색해서 앉혀본다. 단순히 n / 2 + 1 에만 앉을 경우 7을 넣으면 4에 앉아야 하는데 그러면 오답이 나온다. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;limits&gt; using namespace std; int simulate(int n) { int max = (n + 1) / 2; int where = -1; for (int k = 0 ; k &lt; n ; k+=2) { bool result = true; vector&lt;int&gt; seats(n, 0); // 줄리아가 앉을 자리 seats[k] = 1; int people = 1; while (people &lt; max) { // 현재 가능한 자리들 중 가장 큰 최소 거리 int max_dist = -1; vector&lt;int&gt; candidates; for (int i = 0 ; i &lt; n ; i++) { if (seats[i] == 1) { continue; } int dist = numeric_limits&lt;int&gt;::max(); for (int j = 0 ; j &lt; n ; j++) { if (seats[j] == 1) { // 가장 가까운 사람과의 거리 dist = min(dist, abs(i - j)); } } // 현재 자리가 이전보다 더 멀리 떨어져 있다면 새로운 후보, 같으면 추가 if (dist &gt; max_dist) { max_dist = dist; candidates.clear(); candidates.push_back(i); } else if (dist == max_dist) { candidates.push_back(i); } } // 후보자리가 없으면 끝 if (candidates.empty()) { break; } for (int i = 0 ; i &lt; candidates.size() ; i++) { if (candidates[i] % 2 != 0) { // 홀수 자리에 앉지 못하면 의미 없음 continue; }else { seats[candidates[i]] = 1; break; } } people++; } // 최종 상태가 x . x . x ... 패턴인지 확인 for (int i = 0 ; i &lt; n ; i++) { if (i % 2 == 0) { if (seats[i] != 1) { result = false; break; } } else { if (seats[i] != 0) { result = false; break; } } } if (result) { where = k + 1; break; } } return where; } int main() { bool result = false; for (int i = 1 ; i &lt;= 31 ; i+=2) { cout &lt;&lt; i &lt;&lt; " : " &lt;&lt; simulate(i) &lt;&lt; endl; } return 0; } 시뮬레이션 결과는 아래와 같다. n 줄리아 1 1 3 1 5 1 7 3 9 1 11 3 13 5 15 impossible 17 1 19 3 21 5 23 impossible 25 9 27 impossible 29 impossible 31 impossible 예제는 다 맞는다. 2. 규칙 찾기 가설 1: n = 2^k + 1 (k &gt; 0) 인 경우 답은 반드시 1이다. n 줄리아 3 1 5 1 9 1 17 1 가설 2: n != 2^a + 2^b + 1 인 경우 배치가 불가능하다. n 줄리아 15 impossible 23 impossible 27 impossible 29 impossible 31 impossible 이부분은 n + 1의 이진수 1의 개수가 3 이상이면 불가능으로 처리할 수 있다. 가설 3: 그 외의 경우는 시뮬레이션을 하되, 2^k + 1 인 자리만 대상으로 한다. n 줄리아 7 3 11 3 13 5 19 3 21 5 25 9 2. 구현 가설 1, 2를 넘었을 경우 시뮬레이션을 해야하는데 n이 10^18까지 있으므로 평범하게 하면 바로 시간초과다. 어차피 꽉 채워 앉으면 완전 이진트리 구조가 되므로 줄리아 배치 기준 양쪽을 반으로 계속 나눌 수 있는지만 확인하면 된다. // 가설 1: n == 2^k + 1 이면 반드시 줄리아는 1번 자리에 앉으면 됨 bool hypothesis_1(int64_t n) { return (n &gt; 1) &amp;&amp; ((n - 1) &amp; (n - 2)) == 0; } // 가설 2: n == 2^a + 2^b + 1 형태인지 확인 // n - 1 == 2^a + 2^b 라면 가능성 있음 bool hypothesis_2(int64_t n) { int64_t x = n - 1; int count = 0; while (x &gt; 0) { if (x &amp; 1) count++; if (count &gt; 2) return false; x &gt;&gt;= 1; } return count == 2; } // 균등분할이 가능할지 bool can_seat(int64_t len) { if (len &lt; 2) return true; if (len % 2 == 0) return false; return can_seat((len - 1) / 2); } int64_t solve(int64_t n) { // 짝수일 경우 패스 if (n % 2 == 0) { return -1; } // 가설 1 if (hypothesis_1(n)) { return 1; } // 가설 2 if (!hypothesis_2(n)) { return -1; } // 가설 3 for (int i = 0 ; i &lt; 64 ; i++){ int64_t pos = (1LL &lt;&lt; i) + 1; if (pos &gt; n) { break; } if (can_seat(pos - 2) &amp;&amp; can_seat(n - pos - 1)) { return pos; } } return -1; } 채점 허허 정답비율 나 혼자 다깎아먹었넹 반성 반복문 조건도 잘 못잡고 균등분할 조건도 잘 못잡고 제대로 했으면 덜 틀렸을걸 실컷 틀렸다. 아주 고봉밥이다 어우 배불러 근데 분명 더 멋진 풀이가 있을거란 말이지 맞힌 사람 보면 코드 길이가 심상치가 않다. 코드 확인 Link to GitHub]]></summary></entry><entry><title type="html">미로 생성기 03</title><link href="https://movingwoo.com/one-pan/javascript/2025/05/23/Maze-Generator-03.html" rel="alternate" type="text/html" title="미로 생성기 03" /><published>2025-05-23T01:00:00+00:00</published><updated>2025-05-23T01:00:00+00:00</updated><id>https://movingwoo.com/one-pan/javascript/2025/05/23/Maze%20Generator%2003</id><content type="html" xml:base="https://movingwoo.com/one-pan/javascript/2025/05/23/Maze-Generator-03.html"><![CDATA[<blockquote>
  <h4 id="개요">개요</h4>
  <hr />
</blockquote>

<p>남은 알고리즘 미로 추가하여 미로 생성기 완성하기.</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<p>시작 전에 길찾고 그리는 부분이 중복되기 때문에 공통 함수로 옮겨줬다.</p>

<h5 id="1-binary-tree-알고리즘과-sidewinder-알고리즘">1. Binary Tree 알고리즘과 Sidewinder 알고리즘</h5>

<p>두 알고리즘의 미로 생성 과정이나 결과물은 상당히 유사해보인다.<br />
셀에서 방향을 무작위로 선택해 벽을 제거하고 나아가는 방식이다.</p>

<p>차이점을 정리해보면</p>
<ul>
  <li>Binary Tree
    <ul>
      <li>각 셀마다 독립적으로 결정을 내림</li>
      <li>대각선 방향의 경향</li>
    </ul>
  </li>
  <li>Sidewinder
    <ul>
      <li>연속된 동쪽 경로인 run이라는 개념을 활용, 동쪽으로 진행</li>
      <li>현재 run에서 무작위 셀을 남쪽으로 연결하며 run 종료</li>
      <li>이전 셀들의 선택이 다음 셀 선택에 영향을 줌</li>
      <li>수평 방향의 경향</li>
    </ul>
  </li>
</ul>

<p>실제 입구 출구를 이어보면 이는 더 명확하게 드러난다.<br />
전통적인 Sidewinder 알고리즘 사용시 동쪽과 북쪽을 선택하는데<br />
시작 좌표를 [0, 0] 으로 잡기 때문에 동쪽과 남쪽으로 진행하게 방향을 잡았다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Binary Tree 알고리즘</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">generateBinaryTree</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 모든 셀을 벽으로 초기화</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 각 셀에 대해</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 현재 셀을 통로로 만들기</span>
            <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>

            <span class="c1">// 동쪽과 남쪽 중 하나를 무작위로 선택</span>
            <span class="kd">const</span> <span class="nx">canGoEast</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span>
            <span class="kd">const</span> <span class="nx">canGoSouth</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span>

            <span class="k">if </span><span class="p">(</span><span class="nx">canGoEast</span> <span class="o">&amp;&amp;</span> <span class="nx">canGoSouth</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 둘 다 가능하면 무작위로 선택</span>
                <span class="k">if </span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// 동쪽으로</span>
                    <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="c1">// 남쪽으로</span>
                    <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">canGoEast</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 동쪽만 가능</span>
                <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">canGoSouth</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 남쪽만 가능</span>
                <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Sidewinder 알고리즘</span>
<span class="c1">// 전통적인 Sidewinder 알고리즘은 북쪽으로 길을 파는데 입구가 0,0이라 남쪽으로 파는 것으로 변경</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">generateSidewinder</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 모든 셀을 벽으로 초기화</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 각 행을 처리</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">run</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// 현재 실행 중인 경로 (연속된 동쪽 경로)</span>

        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 현재 셀을 통로로 만들기</span>
            <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
            <span class="nx">run</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">]);</span> <span class="c1">// 현재 셀을 run에 추가</span>

            <span class="c1">// 동쪽으로 갈 수 있는지 확인</span>
            <span class="kd">const</span> <span class="nx">canGoEast</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span>
            <span class="c1">// 남쪽으로 갈 수 있는지 확인</span>
            <span class="kd">const</span> <span class="nx">canGoSouth</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span>

            <span class="c1">// 동쪽으로 계속 진행할지, 남쪽으로 연결할지 결정</span>
            <span class="c1">// 1. 동쪽으로 갈 수 없거나</span>
            <span class="c1">// 2. 남쪽으로 갈 수 있고 50% 확률로 run을 종료</span>
            <span class="kd">const</span> <span class="nx">shouldCloseOut</span> <span class="o">=</span> <span class="o">!</span><span class="nx">canGoEast</span> <span class="o">||</span> <span class="p">(</span><span class="nx">canGoSouth</span> <span class="o">&amp;&amp;</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">);</span>

            <span class="k">if </span><span class="p">(</span><span class="nx">shouldCloseOut</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 현재 run에서 무작위로 선택된 셀을 남쪽과 연결</span>
                <span class="kd">const</span> <span class="p">[</span><span class="nx">rx</span><span class="p">,</span> <span class="nx">ry</span><span class="p">]</span> <span class="o">=</span> <span class="nx">run</span><span class="p">[</span><span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">run</span><span class="p">.</span><span class="nx">length</span><span class="p">)];</span>
                <span class="k">if </span><span class="p">(</span><span class="nx">canGoSouth</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">maze</span><span class="p">[</span><span class="nx">ry</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="nx">rx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">rx</span><span class="p">,</span> <span class="nx">ry</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="nx">run</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// run 초기화</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// 동쪽으로 계속 진행 (run 확장)</span>
                <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="2-recursive-division-알고리즘">2. Recursive Division 알고리즘</h5>

<p>Resursive Division 알고리즘으로 생성된 미로를 보면 다른 미로들과 비교해 상당히 이질적이다.<br />
마치 던전 맵 같은 방 구조로 되어있으며 <span style="color: orange;"><strong>접근할 수 없는 갇힌 방</strong></span>도 만들어진다.</p>

<p>공간을 분할하며 한 줄짜리 벽을 만들고 벽에 단 하나의 통로만 뚫는다.<br />
이 과정이 반복되며 어떤 영역은 한 통로만 생기고 나머지는 벽으로 막혀버릴 수 있다.</p>

<p>모든 칸이 연결된 완전 미로를 만들기 위해 코드를 약간 수정했다.<br />
벽을 만들 때 이미 통로가 있는지 확인하고 막히게 된다면 추가로 통로를 더 뚫어주는 로직을 넣어주었다.<br />
그래도 막힌 방이 생성됨… 좀 벽을 더 뚫어줘야할 것 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Recursive Division 알고리즘</span>
<span class="c1">// 완전 미로를 만들기 위한 커스텀</span>
<span class="c1">// 분할선 크기 조정 시 방 크기 조정</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">generateRecursiveDivision</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">,</span> <span class="nx">orientation</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 방이 너무 작으면 중단</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">x2</span> <span class="o">-</span> <span class="nx">x1</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">||</span> <span class="nx">y2</span> <span class="o">-</span> <span class="nx">y1</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 수평</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">orientation</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">horizontal</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 분할선 후보(짝수)</span>
        <span class="kd">const</span> <span class="nx">possibleYs</span> <span class="o">=</span> <span class="p">[];</span>
        
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">y1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">y2</span><span class="p">;</span> <span class="nx">y</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">possibleYs</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if </span><span class="p">(</span><span class="nx">possibleYs</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 분할선 후보가 없으면 중단</span>
            <span class="k">return</span><span class="p">;</span> 
        <span class="p">}</span>
        <span class="kd">const</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">possibleYs</span><span class="p">[</span><span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">possibleYs</span><span class="p">.</span><span class="nx">length</span><span class="p">)];</span>

        <span class="c1">// 통로 후보(홀수)</span>
        <span class="kd">const</span> <span class="nx">possiblePassages</span> <span class="o">=</span> <span class="p">[];</span>
        
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">x1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">x2</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">possiblePassages</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="k">if </span><span class="p">(</span><span class="nx">possiblePassages</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 통로 후보가 없으면 중단</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 반드시 하나는 통로로 만들고, 추가로 통로를 더 만들 확률도 부여</span>
        <span class="kd">const</span> <span class="nx">passageCount</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">possiblePassages</span><span class="p">.</span><span class="nx">length</span> <span class="o">/</span> <span class="mi">3</span><span class="p">));</span>
        <span class="kd">const</span> <span class="nx">passages</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="kd">const</span> <span class="nx">passageCandidates</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">possiblePassages</span><span class="p">];</span>
        <span class="k">while </span><span class="p">(</span><span class="nx">passages</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="nx">passageCount</span> <span class="o">&amp;&amp;</span> <span class="nx">passageCandidates</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">idx</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">passageCandidates</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
            <span class="kd">const</span> <span class="nx">px</span> <span class="o">=</span> <span class="nx">passageCandidates</span><span class="p">.</span><span class="nf">splice</span><span class="p">(</span><span class="nx">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
            <span class="nx">passages</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">px</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// 벽 생성 (통로 제외)</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">x1</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;=</span> <span class="nx">x2</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">passages</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span> <span class="p">{</span>
                <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

        <span class="c1">// 위/아래 영역 재귀 호출</span>
        <span class="k">await</span> <span class="nf">generateRecursiveDivision</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">vertical</span><span class="dl">'</span><span class="p">);</span>
        <span class="k">await</span> <span class="nf">generateRecursiveDivision</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">,</span> <span class="dl">'</span><span class="s1">vertical</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// 수직</span>
        <span class="c1">// 분할선 후보(짝수)</span>
        <span class="kd">const</span> <span class="nx">possibleXs</span> <span class="o">=</span> <span class="p">[];</span>
        
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">x1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">x2</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">possibleXs</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if </span><span class="p">(</span><span class="nx">possibleXs</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 분할선 후보가 없으면 중단</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">possibleXs</span><span class="p">[</span><span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">possibleXs</span><span class="p">.</span><span class="nx">length</span><span class="p">)];</span>

        <span class="c1">// 통로 후보(홀수)</span>
        <span class="kd">const</span> <span class="nx">possiblePassages</span> <span class="o">=</span> <span class="p">[];</span>

        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">y1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">y2</span><span class="p">;</span> <span class="nx">y</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">possiblePassages</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if </span><span class="p">(</span><span class="nx">possiblePassages</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 통로 후보가 없으면 중단</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 반드시 하나는 통로로 만들고, 추가로 통로를 더 만들 확률도 부여</span>
        <span class="kd">const</span> <span class="nx">passageCount</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">possiblePassages</span><span class="p">.</span><span class="nx">length</span> <span class="o">/</span> <span class="mi">3</span><span class="p">));</span>
        <span class="kd">const</span> <span class="nx">passages</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="kd">const</span> <span class="nx">passageCandidates</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">possiblePassages</span><span class="p">];</span>
        <span class="k">while </span><span class="p">(</span><span class="nx">passages</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="nx">passageCount</span> <span class="o">&amp;&amp;</span> <span class="nx">passageCandidates</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">idx</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">passageCandidates</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
            <span class="kd">const</span> <span class="nx">py</span> <span class="o">=</span> <span class="nx">passageCandidates</span><span class="p">.</span><span class="nf">splice</span><span class="p">(</span><span class="nx">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
            <span class="nx">passages</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">py</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// 벽 생성 (통로 제외)</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">y1</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;=</span> <span class="nx">y2</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">passages</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="nx">y</span><span class="p">))</span> <span class="p">{</span>
                <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

        <span class="c1">// 좌/우 영역 재귀 호출</span>
        <span class="k">await</span> <span class="nf">generateRecursiveDivision</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y2</span><span class="p">,</span> <span class="dl">'</span><span class="s1">horizontal</span><span class="dl">'</span><span class="p">);</span>
        <span class="k">await</span> <span class="nf">generateRecursiveDivision</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">,</span> <span class="dl">'</span><span class="s1">horizontal</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="3-ellers-알고리즘">3. Eller’s 알고리즘</h5>

<p>Eller’s 알고리즘은 각 행마다 집합을 관리하며 벽을 뚫을 때 집합을 병합하거나 새로 부여한다.<br />
한 줄씩 처리하며 집합 연산과 벽 뚫기만 하고 복잡한 경로 탐색이 없어서 <span style="color: orange;"><strong>메모리 접근이 효율적이고 엄청나게 빠르다.</strong></span></p>

<p>실제로 시뮬레이션 돌리면 혼자서 미로를 호다닥 생성해버린다.</p>

<p>엄청나게 빠른게 장점이라면 단점으로는 무작위성이 떨어지며 수평으로 편향되어 있다는 점 정도? 
좀 숭숭 뚫려있는 느낌도 받는다.<br />
수직으로 한 칸 짜리 벽 생성을 지양해야하는데 수평으로 한 줄씩 처리하기 때문에 수직 처리하기 곤란하다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Eller's Algorithm 미로 생성</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">generateEller</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 모든 셀을 벽으로 초기화</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 각 셀의 집합 번호를 저장할 배열</span>
    <span class="kd">let</span> <span class="nx">sets</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">let</span> <span class="nx">nextSet</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// 첫 번째 행 초기화</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">sets</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nextSet</span><span class="o">++</span><span class="p">;</span>
        <span class="nx">maze</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 각 행을 처리</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 1. 오른쪽으로 벽을 뚫을지 결정</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 같은 집합이 아니고, 랜덤하게 벽을 뚫기로 결정하면</span>
            <span class="k">if </span><span class="p">(</span><span class="nx">sets</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">!==</span> <span class="nx">sets</span><span class="p">[</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 벽 뚫기</span>
                <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
                <span class="c1">// 집합 병합</span>
                <span class="kd">const</span> <span class="nx">oldSet</span> <span class="o">=</span> <span class="nx">sets</span><span class="p">[</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
                <span class="kd">const</span> <span class="nx">newSet</span> <span class="o">=</span> <span class="nx">sets</span><span class="p">[</span><span class="nx">x</span><span class="p">];</span>
                <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">if </span><span class="p">(</span><span class="nx">sets</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="nx">oldSet</span><span class="p">)</span> <span class="nx">sets</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">newSet</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 마지막 행이 아니면 아래로 벽을 뚫기</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 각 집합별로 아래로 연결할 셀을 최소 1개 이상 선택</span>
            <span class="kd">const</span> <span class="nx">setCells</span> <span class="o">=</span> <span class="p">{};</span>
            <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">setCells</span><span class="p">[</span><span class="nx">sets</span><span class="p">[</span><span class="nx">x</span><span class="p">]])</span> <span class="nx">setCells</span><span class="p">[</span><span class="nx">sets</span><span class="p">[</span><span class="nx">x</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[];</span>
                <span class="nx">setCells</span><span class="p">[</span><span class="nx">sets</span><span class="p">[</span><span class="nx">x</span><span class="p">]].</span><span class="nf">push</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="c1">// 아래로 연결</span>
            <span class="kd">let</span> <span class="nx">newSets</span> <span class="o">=</span> <span class="p">[];</span>
            <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="kd">set</span> <span class="k">in</span> <span class="nx">setCells</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 반드시 하나는 아래로 연결</span>
                <span class="kd">const</span> <span class="nx">cells</span> <span class="o">=</span> <span class="nx">setCells</span><span class="p">[</span><span class="kd">set</span><span class="p">];</span>
                <span class="kd">const</span> <span class="nx">shuffled</span> <span class="o">=</span> <span class="nx">cells</span><span class="p">.</span><span class="nf">slice</span><span class="p">().</span><span class="nf">sort</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">);</span>
                <span class="kd">const</span> <span class="nx">downCount</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">cells</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
                <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">downCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">shuffled</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
                    <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
                    <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
                    <span class="nx">newSets</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nextSet</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="c1">// 나머지 셀은 새로운 집합 번호 부여</span>
            <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">newSets</span><span class="p">[</span><span class="nx">x</span><span class="p">])</span> <span class="p">{</span>
                    <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
                    <span class="nx">newSets</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nextSet</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nx">sets</span> <span class="o">=</span> <span class="nx">newSets</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="완성">완성</h4>
  <hr />
</blockquote>

<p>Binary Tree 알고리즘 미로</p>

<p><img src="/assets/images/posts/one-pan/JavaScript/2025-05-23-Maze Generator 03/img01.gif" alt="img01" /></p>

<p>Sidewinder 알고리즘 미로</p>

<p><img src="/assets/images/posts/one-pan/JavaScript/2025-05-23-Maze Generator 03/img02.gif" alt="img02" /></p>

<p>Recursive Division 알고리즘 미로</p>

<p><img src="/assets/images/posts/one-pan/JavaScript/2025-05-23-Maze Generator 03/img03.gif" alt="img03" /></p>

<p>Eller’s 알고리즘 미로</p>

<p><img src="/assets/images/posts/one-pan/JavaScript/2025-05-23-Maze Generator 03/img04.gif" alt="img04" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>7종 알고리즘 미로를 완성했다.<br />
그 외 몇가지 알고리즘이 더 있긴한데, 대표적으로 이 7종이면 더 맛 볼 필요는 없다고 한다.</p>

<p>그리고 미로 알고리즘 짜다가 알게 되었는데 던전 맵 만드는 알고리즘과 미로 알고리즘은 또 다르다고 한다…<br />
정리 되면 던전 맵 시뮬레이터도 만들어봐야겠다.</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="/play/Maze%20Generator.html" target="_blank" rel="noopener noreferrer">
  직접 해보기
</a></p>

<p>Binary Tree<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-23-BinaryTree.js">Link to GitHub</a></p>

<p>Sidewinder<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-23-Sidewinder.js">Link to GitHub</a></p>

<p>Recursive Division<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-23-RecursiveDivision.js">Link to GitHub</a></p>

<p>Eller’s<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-23-Eller.js">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="one-pan/JavaScript/" /><summary type="html"><![CDATA[개요 남은 알고리즘 미로 추가하여 미로 생성기 완성하기. 구현 시작 전에 길찾고 그리는 부분이 중복되기 때문에 공통 함수로 옮겨줬다. 1. Binary Tree 알고리즘과 Sidewinder 알고리즘 두 알고리즘의 미로 생성 과정이나 결과물은 상당히 유사해보인다. 셀에서 방향을 무작위로 선택해 벽을 제거하고 나아가는 방식이다. 차이점을 정리해보면 Binary Tree 각 셀마다 독립적으로 결정을 내림 대각선 방향의 경향 Sidewinder 연속된 동쪽 경로인 run이라는 개념을 활용, 동쪽으로 진행 현재 run에서 무작위 셀을 남쪽으로 연결하며 run 종료 이전 셀들의 선택이 다음 셀 선택에 영향을 줌 수평 방향의 경향 실제 입구 출구를 이어보면 이는 더 명확하게 드러난다. 전통적인 Sidewinder 알고리즘 사용시 동쪽과 북쪽을 선택하는데 시작 좌표를 [0, 0] 으로 잡기 때문에 동쪽과 남쪽으로 진행하게 방향을 잡았다. // Binary Tree 알고리즘 async function generateBinaryTree() { // 모든 셀을 벽으로 초기화 for (let y = 0; y &lt; rows; y++) { for (let x = 0; x &lt; cols; x++) { maze[y][x] = 1; drawCell(x, y, 'black'); } } // 각 셀에 대해 for (let y = 0; y &lt; rows; y += 2) { for (let x = 0; x &lt; cols; x += 2) { // 현재 셀을 통로로 만들기 maze[y][x] = 0; drawCell(x, y, 'white'); // 동쪽과 남쪽 중 하나를 무작위로 선택 const canGoEast = x + 2 &lt; cols; const canGoSouth = y + 2 &lt; rows; if (canGoEast &amp;&amp; canGoSouth) { // 둘 다 가능하면 무작위로 선택 if (Math.random() &lt; 0.5) { // 동쪽으로 maze[y][x + 1] = 0; drawCell(x + 1, y, 'white'); } else { // 남쪽으로 maze[y + 1][x] = 0; drawCell(x, y + 1, 'white'); } } else if (canGoEast) { // 동쪽만 가능 maze[y][x + 1] = 0; drawCell(x + 1, y, 'white'); } else if (canGoSouth) { // 남쪽만 가능 maze[y + 1][x] = 0; drawCell(x, y + 1, 'white'); } await sleep(5); } } } // Sidewinder 알고리즘 // 전통적인 Sidewinder 알고리즘은 북쪽으로 길을 파는데 입구가 0,0이라 남쪽으로 파는 것으로 변경 async function generateSidewinder() { // 모든 셀을 벽으로 초기화 for (let y = 0; y &lt; rows; y++) { for (let x = 0; x &lt; cols; x++) { maze[y][x] = 1; drawCell(x, y, 'black'); } } // 각 행을 처리 for (let y = 0; y &lt; rows; y += 2) { let run = []; // 현재 실행 중인 경로 (연속된 동쪽 경로) for (let x = 0; x &lt; cols; x += 2) { // 현재 셀을 통로로 만들기 maze[y][x] = 0; drawCell(x, y, 'white'); run.push([x, y]); // 현재 셀을 run에 추가 // 동쪽으로 갈 수 있는지 확인 const canGoEast = x + 2 &lt; cols; // 남쪽으로 갈 수 있는지 확인 const canGoSouth = y + 2 &lt; rows; // 동쪽으로 계속 진행할지, 남쪽으로 연결할지 결정 // 1. 동쪽으로 갈 수 없거나 // 2. 남쪽으로 갈 수 있고 50% 확률로 run을 종료 const shouldCloseOut = !canGoEast || (canGoSouth &amp;&amp; Math.random() &lt; 0.5); if (shouldCloseOut) { // 현재 run에서 무작위로 선택된 셀을 남쪽과 연결 const [rx, ry] = run[Math.floor(Math.random() * run.length)]; if (canGoSouth) { maze[ry + 1][rx] = 0; drawCell(rx, ry + 1, 'white'); } run = []; // run 초기화 } else { // 동쪽으로 계속 진행 (run 확장) maze[y][x + 1] = 0; drawCell(x + 1, y, 'white'); } await sleep(5); } } } 2. Recursive Division 알고리즘 Resursive Division 알고리즘으로 생성된 미로를 보면 다른 미로들과 비교해 상당히 이질적이다. 마치 던전 맵 같은 방 구조로 되어있으며 접근할 수 없는 갇힌 방도 만들어진다. 공간을 분할하며 한 줄짜리 벽을 만들고 벽에 단 하나의 통로만 뚫는다. 이 과정이 반복되며 어떤 영역은 한 통로만 생기고 나머지는 벽으로 막혀버릴 수 있다. 모든 칸이 연결된 완전 미로를 만들기 위해 코드를 약간 수정했다. 벽을 만들 때 이미 통로가 있는지 확인하고 막히게 된다면 추가로 통로를 더 뚫어주는 로직을 넣어주었다. 그래도 막힌 방이 생성됨… 좀 벽을 더 뚫어줘야할 것 같다. // Recursive Division 알고리즘 // 완전 미로를 만들기 위한 커스텀 // 분할선 크기 조정 시 방 크기 조정 async function generateRecursiveDivision(x1, y1, x2, y2, orientation) { // 방이 너무 작으면 중단 if (x2 - x1 &lt; 2 || y2 - y1 &lt; 2) { return; } // 수평 if (orientation === 'horizontal') { // 분할선 후보(짝수) const possibleYs = []; for (let y = y1 + 2; y &lt; y2; y += 2) { possibleYs.push(y); } if (possibleYs.length === 0) { // 분할선 후보가 없으면 중단 return; } const y = possibleYs[Math.floor(Math.random() * possibleYs.length)]; // 통로 후보(홀수) const possiblePassages = []; for (let x = x1 + 1; x &lt; x2; x += 2) { possiblePassages.push(x); } if (possiblePassages.length === 0) { // 통로 후보가 없으면 중단 return; } // 반드시 하나는 통로로 만들고, 추가로 통로를 더 만들 확률도 부여 const passageCount = 1 + Math.floor(Math.random() * Math.max(1, possiblePassages.length / 3)); const passages = []; const passageCandidates = [...possiblePassages]; while (passages.length &lt; passageCount &amp;&amp; passageCandidates.length &gt; 0) { const idx = Math.floor(Math.random() * passageCandidates.length); const px = passageCandidates.splice(idx, 1)[0]; passages.push(px); } // 벽 생성 (통로 제외) for (let x = x1; x &lt;= x2; x++) { if (!passages.includes(x)) { maze[y][x] = 1; drawCell(x, y, 'black'); } } await sleep(5); // 위/아래 영역 재귀 호출 await generateRecursiveDivision(x1, y1, x2, y - 1, 'vertical'); await generateRecursiveDivision(x1, y + 1, x2, y2, 'vertical'); } else { // 수직 // 분할선 후보(짝수) const possibleXs = []; for (let x = x1 + 2; x &lt; x2; x += 2) { possibleXs.push(x); } if (possibleXs.length === 0) { // 분할선 후보가 없으면 중단 return; } const x = possibleXs[Math.floor(Math.random() * possibleXs.length)]; // 통로 후보(홀수) const possiblePassages = []; for (let y = y1 + 1; y &lt; y2; y += 2) { possiblePassages.push(y); } if (possiblePassages.length === 0) { // 통로 후보가 없으면 중단 return; } // 반드시 하나는 통로로 만들고, 추가로 통로를 더 만들 확률도 부여 const passageCount = 1 + Math.floor(Math.random() * Math.max(1, possiblePassages.length / 3)); const passages = []; const passageCandidates = [...possiblePassages]; while (passages.length &lt; passageCount &amp;&amp; passageCandidates.length &gt; 0) { const idx = Math.floor(Math.random() * passageCandidates.length); const py = passageCandidates.splice(idx, 1)[0]; passages.push(py); } // 벽 생성 (통로 제외) for (let y = y1; y &lt;= y2; y++) { if (!passages.includes(y)) { maze[y][x] = 1; drawCell(x, y, 'black'); } } await sleep(5); // 좌/우 영역 재귀 호출 await generateRecursiveDivision(x1, y1, x - 1, y2, 'horizontal'); await generateRecursiveDivision(x + 1, y1, x2, y2, 'horizontal'); } } 3. Eller’s 알고리즘 Eller’s 알고리즘은 각 행마다 집합을 관리하며 벽을 뚫을 때 집합을 병합하거나 새로 부여한다. 한 줄씩 처리하며 집합 연산과 벽 뚫기만 하고 복잡한 경로 탐색이 없어서 메모리 접근이 효율적이고 엄청나게 빠르다. 실제로 시뮬레이션 돌리면 혼자서 미로를 호다닥 생성해버린다. 엄청나게 빠른게 장점이라면 단점으로는 무작위성이 떨어지며 수평으로 편향되어 있다는 점 정도? 좀 숭숭 뚫려있는 느낌도 받는다. 수직으로 한 칸 짜리 벽 생성을 지양해야하는데 수평으로 한 줄씩 처리하기 때문에 수직 처리하기 곤란하다. // Eller's Algorithm 미로 생성 async function generateEller() { // 모든 셀을 벽으로 초기화 for (let y = 0; y &lt; rows; y++) { for (let x = 0; x &lt; cols; x++) { maze[y][x] = 1; drawCell(x, y, 'black'); } } // 각 셀의 집합 번호를 저장할 배열 let sets = []; let nextSet = 1; // 첫 번째 행 초기화 for (let x = 0; x &lt; cols; x += 2) { sets[x] = nextSet++; maze[0][x] = 0; drawCell(x, 0, 'white'); } // 각 행을 처리 for (let y = 0; y &lt; rows; y += 2) { // 1. 오른쪽으로 벽을 뚫을지 결정 for (let x = 0; x &lt; cols - 2; x += 2) { // 같은 집합이 아니고, 랜덤하게 벽을 뚫기로 결정하면 if (sets[x] !== sets[x + 2] &amp;&amp; Math.random() &lt; 0.5) { // 벽 뚫기 maze[y][x + 1] = 0; drawCell(x + 1, y, 'white'); // 집합 병합 const oldSet = sets[x + 2]; const newSet = sets[x]; for (let i = 0; i &lt; cols; i += 2) { if (sets[i] === oldSet) sets[i] = newSet; } } } // 마지막 행이 아니면 아래로 벽을 뚫기 if (y + 2 &lt; rows) { // 각 집합별로 아래로 연결할 셀을 최소 1개 이상 선택 const setCells = {}; for (let x = 0; x &lt; cols; x += 2) { if (!setCells[sets[x]]) setCells[sets[x]] = []; setCells[sets[x]].push(x); } // 아래로 연결 let newSets = []; for (const set in setCells) { // 반드시 하나는 아래로 연결 const cells = setCells[set]; const shuffled = cells.slice().sort(() =&gt; Math.random() - 0.5); const downCount = 1 + Math.floor(Math.random() * cells.length); for (let i = 0; i &lt; downCount; i++) { const x = shuffled[i]; maze[y + 1][x] = 0; drawCell(x, y + 1, 'white'); maze[y + 2][x] = 0; drawCell(x, y + 2, 'white'); newSets[x] = nextSet++; } } // 나머지 셀은 새로운 집합 번호 부여 for (let x = 0; x &lt; cols; x += 2) { if (!newSets[x]) { maze[y + 2][x] = 0; drawCell(x, y + 2, 'white'); newSets[x] = nextSet++; } } sets = newSets; } await sleep(10); } } 완성 Binary Tree 알고리즘 미로 Sidewinder 알고리즘 미로 Recursive Division 알고리즘 미로 Eller’s 알고리즘 미로 반성 7종 알고리즘 미로를 완성했다. 그 외 몇가지 알고리즘이 더 있긴한데, 대표적으로 이 7종이면 더 맛 볼 필요는 없다고 한다. 그리고 미로 알고리즘 짜다가 알게 되었는데 던전 맵 만드는 알고리즘과 미로 알고리즘은 또 다르다고 한다… 정리 되면 던전 맵 시뮬레이터도 만들어봐야겠다. 코드 확인 직접 해보기 Binary Tree Link to GitHub Sidewinder Link to GitHub Recursive Division Link to GitHub Eller’s Link to GitHub]]></summary></entry><entry><title type="html">26489번 Gum Gum for Jay Jay</title><link href="https://movingwoo.com/random-solve/python/2025/05/22/26489.html" rel="alternate" type="text/html" title="26489번 Gum Gum for Jay Jay" /><published>2025-05-22T02:00:00+00:00</published><updated>2025-05-22T02:00:00+00:00</updated><id>https://movingwoo.com/random-solve/python/2025/05/22/26489</id><content type="html" xml:base="https://movingwoo.com/random-solve/python/2025/05/22/26489.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Python/2025-05-22-26489/img01.jpg" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/26489">26489번 Gum Gum for Jay Jay - 백준</a></p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>엌ㅋㅋㅋㅋㅋ 개날먹 문제 ㅋㅋㅋㅋㅋ<br />
좋아좋아 이런 날도 있어야지.</p>

<p>입력 들어오는 라인 수를 세기만 하면 되는 개꿀문제다.</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">try</span><span class="p">:</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="nf">input</span><span class="p">()</span>
        <span class="n">n</span><span class="o">+=</span><span class="mi">1</span>
<span class="k">except</span> <span class="nb">EOFError</span><span class="p">:</span>
    <span class="k">pass</span> 

<span class="nf">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</code></pre></div></div>

<p>끝이다.<br />
<span style="color: red;"><strong>아니 내 컨텐츠가!!!!!!!</strong></span><br />
너무 쉬운 문제는 이런게 문제구나.</p>

<p>이왕 이렇게 된 것, C++과 Java로도 처리하자.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>자바는 스캐너로 EOF 판단하는게 낫다.<br />
어차피 속도가 중요한 문제도 아니니</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">Scanner</span> <span class="n">sc</span><span class="o">=</span><span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
		<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>

		<span class="k">while</span><span class="o">(</span><span class="n">sc</span><span class="o">.</span><span class="na">hasNextLine</span><span class="o">())</span> <span class="o">{</span>
			<span class="n">sc</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span>
			<span class="n">n</span><span class="o">++;</span>
		<span class="o">}</span>

		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/Python/2025-05-22-26489/img02.jpg" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p><span style="color: red;"><strong>뭐???? 파이썬에서 틀렸습니다가 발생했다고???????</strong></span><br />
파이썬은 ++n이 없고 n+=1을 해야하는데 자연스럽게 ++n한 나의 실수다.<br />
이렇게 개꿀문제에서도 반성할 점은 있는 법.</p>

<p>날먹 날먹 신나는 날먹</p>]]></content><author><name>movingwoo</name></author><category term="random-solve/Python/" /><summary type="html"><![CDATA[문제 26489번 Gum Gum for Jay Jay - 백준 설계 엌ㅋㅋㅋㅋㅋ 개날먹 문제 ㅋㅋㅋㅋㅋ 좋아좋아 이런 날도 있어야지. 입력 들어오는 라인 수를 세기만 하면 되는 개꿀문제다. 구현 n = 0 try: while True: input() n+=1 except EOFError: pass print(n) 끝이다. 아니 내 컨텐츠가!!!!!!! 너무 쉬운 문제는 이런게 문제구나. 이왕 이렇게 된 것, C++과 Java로도 처리하자. #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { int n = 0; string s; while (getline(cin, s)) { ++n; } cout &lt;&lt; n; return 0; } 자바는 스캐너로 EOF 판단하는게 낫다. 어차피 속도가 중요한 문제도 아니니 import java.util.*; public class Main { public static void main(String[] args) { Scanner sc=new Scanner(System.in); int n=0; while(sc.hasNextLine()) { sc.nextLine(); n++; } System.out.print(n); } } 채점 반성 뭐???? 파이썬에서 틀렸습니다가 발생했다고??????? 파이썬은 ++n이 없고 n+=1을 해야하는데 자연스럽게 ++n한 나의 실수다. 이렇게 개꿀문제에서도 반성할 점은 있는 법. 날먹 날먹 신나는 날먹]]></summary></entry><entry><title type="html">미로 생성기 02</title><link href="https://movingwoo.com/one-pan/javascript/2025/05/21/Maze-Generator-02.html" rel="alternate" type="text/html" title="미로 생성기 02" /><published>2025-05-21T23:00:00+00:00</published><updated>2025-05-21T23:00:00+00:00</updated><id>https://movingwoo.com/one-pan/javascript/2025/05/21/Maze%20Generator%2002</id><content type="html" xml:base="https://movingwoo.com/one-pan/javascript/2025/05/21/Maze-Generator-02.html"><![CDATA[<blockquote>
  <h4 id="개요">개요</h4>
  <hr />
</blockquote>

<p>Prim’s 알고리즘과 Kruskal’s 알고리즘의 미로를 추가하기</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<p>시작 전에 공통으로 사용할 함수를 index로 몰아준다.</p>

<h5 id="1-prims-알고리즘">1. Prim’s 알고리즘</h5>

<p>DFS와 Prim의 미로는 겉으로는 제법 유사해보이는데 Prim은 탈출 경로가 훨씬 단순해진다.<br />
DFS는 한 방향으로 쭈욱 파다가 막히면 돌아가서 새로운 길을 찾는데,<br />
Prim은 미로의 경계에서 새로운 길을 만들기 때문이다.</p>

<p>느낌으로 비교하자면 DFS는 <span style="color: orange;"><strong>‘길을 파는 것’</strong></span>이고 Prim은 <span style="color: orange;"><strong>‘벽을 뚫는 것’</strong></span>이다.<br />
벽을 뚫는 것이기 때문에 인접한 벽(여기서는 프론티어)을 모아두고 랜덤으로 선택해서 뚫어나간다.</p>

<p>DFS와 마찬가지로 js를 작성하고 기존 html에 스크립트를 추가한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Prim's 알고리즘</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">generatePrim</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 시작점 (0,0)</span>
    <span class="kd">const</span> <span class="nx">startX</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">startY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">maze</span><span class="p">[</span><span class="nx">startY</span><span class="p">][</span><span class="nx">startX</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">startX</span><span class="p">,</span> <span class="nx">startY</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>

    <span class="c1">// 프론티어 셀</span>
    <span class="kd">const</span> <span class="nx">frontiers</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">const</span> <span class="nx">frontierSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">();</span>
    <span class="nf">addFrontiers</span><span class="p">(</span><span class="nx">startX</span><span class="p">,</span> <span class="nx">startY</span><span class="p">,</span> <span class="nx">frontiers</span><span class="p">,</span> <span class="nx">frontierSet</span><span class="p">);</span>

    <span class="k">while </span><span class="p">(</span><span class="nx">frontiers</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 무작위 프론티어 선택</span>
        <span class="kd">const</span> <span class="nx">randomIndex</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">frontiers</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
        <span class="kd">const</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">]</span> <span class="o">=</span> <span class="nx">frontiers</span><span class="p">.</span><span class="nf">splice</span><span class="p">(</span><span class="nx">randomIndex</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
        <span class="nx">frontierSet</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">x</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">y</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>

        <span class="c1">// 인접한 통로 찾기 (경계 포함)</span>
        <span class="kd">const</span> <span class="nx">neighbors</span> <span class="o">=</span> <span class="nf">getNeighbors</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>

        <span class="k">if </span><span class="p">(</span><span class="nx">neighbors</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 인접 통로 없으면 무시</span>
            <span class="k">continue</span><span class="p">;</span> 
        <span class="p">}</span>

        <span class="c1">// 무작위 인접 통로 선택</span>
        <span class="kd">const</span> <span class="p">[</span><span class="nx">nx</span><span class="p">,</span> <span class="nx">ny</span><span class="p">]</span> <span class="o">=</span> <span class="nx">neighbors</span><span class="p">[</span><span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">neighbors</span><span class="p">.</span><span class="nx">length</span><span class="p">)];</span>

        <span class="c1">// 벽 뚫기</span>
        <span class="kd">const</span> <span class="nx">wallX</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">nx</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">wallY</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">ny</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="nx">maze</span><span class="p">[</span><span class="nx">wallY</span><span class="p">][</span><span class="nx">wallX</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        
        <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
        <span class="nf">drawCell</span><span class="p">(</span><span class="nx">wallX</span><span class="p">,</span> <span class="nx">wallY</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>

        <span class="c1">// 새로운 프론티어 추가</span>
        <span class="nf">addFrontiers</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">frontiers</span><span class="p">,</span> <span class="nx">frontierSet</span><span class="p">);</span>
        <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 프론티어 셀 추가 (중복 방지, 경계 포함)</span>
<span class="kd">function</span> <span class="nf">addFrontiers</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">frontiers</span><span class="p">,</span> <span class="nx">frontierSet</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">dirs</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]];</span>

    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">]</span> <span class="k">of</span> <span class="nx">dirs</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">nx</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">ny</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">nx</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">ny</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>

        <span class="k">if </span><span class="p">(</span><span class="nx">nx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nx</span> <span class="o">&lt;</span> <span class="nx">cols</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&lt;</span> <span class="nx">rows</span> <span class="o">&amp;&amp;</span> <span class="nx">maze</span><span class="p">[</span><span class="nx">ny</span><span class="p">][</span><span class="nx">nx</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">frontierSet</span><span class="p">.</span><span class="nf">has</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">frontiers</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">nx</span><span class="p">,</span> <span class="nx">ny</span><span class="p">]);</span>
            <span class="nx">frontierSet</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 인접한 통로 찾기 (경계 포함)</span>
<span class="kd">function</span> <span class="nf">getNeighbors</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">neighbors</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">const</span> <span class="nx">dirs</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]];</span>

    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">]</span> <span class="k">of</span> <span class="nx">dirs</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">nx</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">ny</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">;</span>

        <span class="k">if </span><span class="p">(</span><span class="nx">nx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nx</span> <span class="o">&lt;</span> <span class="nx">cols</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">ny</span> <span class="o">&lt;</span> <span class="nx">rows</span> <span class="o">&amp;&amp;</span> <span class="nx">maze</span><span class="p">[</span><span class="nx">ny</span><span class="p">][</span><span class="nx">nx</span><span class="p">]</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">neighbors</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">nx</span><span class="p">,</span> <span class="nx">ny</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">neighbors</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">async</span> <span class="kd">function</span> <span class="nf">startPrim</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">initMaze</span><span class="p">();</span>
    <span class="k">await</span> <span class="nf">generatePrim</span><span class="p">();</span>
    <span class="c1">// 입구 표시</span>
    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">entrance</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">entrance</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="dl">'</span><span class="s1">lime</span><span class="dl">'</span><span class="p">);</span>

    <span class="c1">// 가장 먼 곳이 출구</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">ex</span><span class="p">,</span> <span class="nx">ey</span><span class="p">]</span> <span class="o">=</span> <span class="nf">findFurthestCell</span><span class="p">(</span><span class="nx">entrance</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">entrance</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="nx">exit</span> <span class="o">=</span> <span class="p">[</span><span class="nx">ex</span><span class="p">,</span> <span class="nx">ey</span><span class="p">];</span>
    <span class="c1">// 출구 표시</span>
    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">exit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">exit</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="dl">'</span><span class="s1">blue</span><span class="dl">'</span><span class="p">);</span>

    <span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nf">findPathBFS</span><span class="p">(</span><span class="nx">entrance</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">entrance</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">exit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">exit</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">await</span> <span class="nf">drawPathAnimated</span><span class="p">(</span><span class="nx">path</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="2-kruskals-알고리즘">2. Kruskal’s 알고리즘</h5>

<p>Kruskal 미로는 벽에 갇힌 통로를 생성해두고 무작위로 벽을 뚫어 통로를 연결하는 방식이다.<br />
복잡도로 따지면 Prim 보다는 복잡하고 DFS보다는 덜 복잡한 느낌이다.</p>

<p>Prim도 벽을 뚫고 Kruskal도 벽을 뚫는데 차이가 있다면<br />
Prim은 현재 통로와 인접한 벽만 뚫어서 확장해 나가는 것이고<br />
Kruskal은 <span style="color: oragne;"><strong>미로 전체 벽에서 무작위로 통로가 합쳐지도록 뚫는 것</strong></span>이다.<br />
그러니 Prim보다 더 복잡해 보일 수 밖에.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Kruskal's 알고리즘</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">generateKruskal</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">sets</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Map</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">walls</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="c1">// 짝수 좌표만 통로로 초기화, 집합 생성</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;=</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;=</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">maze</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
            <span class="nx">sets</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">x</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">y</span><span class="p">}</span><span class="s2">`</span><span class="p">,</span> <span class="s2">`</span><span class="p">${</span><span class="nx">x</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">y</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 통로 사이의 벽만 벽 리스트에 추가</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;=</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;=</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if </span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 수평 벽</span>
                <span class="nx">walls</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">y</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="k">if </span><span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 수직 벽</span>
                <span class="nx">walls</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 벽을 무작위로 섞기</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">walls</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">j</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
        <span class="p">[</span><span class="nx">walls</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">walls</span><span class="p">[</span><span class="nx">j</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">walls</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">walls</span><span class="p">[</span><span class="nx">i</span><span class="p">]];</span>
    <span class="p">}</span>

    <span class="c1">// 하나씩 꺼내서 뚫기</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">wx</span><span class="p">,</span> <span class="nx">wy</span><span class="p">,</span> <span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">]</span> <span class="k">of</span> <span class="nx">walls</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">set1</span> <span class="o">=</span> <span class="nf">findSet</span><span class="p">(</span><span class="nx">sets</span><span class="p">,</span> <span class="s2">`</span><span class="p">${</span><span class="nx">x1</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">y1</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">set2</span> <span class="o">=</span> <span class="nf">findSet</span><span class="p">(</span><span class="nx">sets</span><span class="p">,</span> <span class="s2">`</span><span class="p">${</span><span class="nx">x2</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">y2</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>

        <span class="k">if </span><span class="p">(</span><span class="nx">set1</span> <span class="o">!==</span> <span class="nx">set2</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">maze</span><span class="p">[</span><span class="nx">wy</span><span class="p">][</span><span class="nx">wx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="nf">drawCell</span><span class="p">(</span><span class="nx">wx</span><span class="p">,</span> <span class="nx">wy</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
            <span class="nf">union</span><span class="p">(</span><span class="nx">sets</span><span class="p">,</span> <span class="nx">set1</span><span class="p">,</span> <span class="nx">set2</span><span class="p">);</span>
            <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 경로 압축을 위한 집합 찾기</span>
<span class="kd">function</span> <span class="nf">findSet</span><span class="p">(</span><span class="nx">sets</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">sets</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="o">!==</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">sets</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nf">findSet</span><span class="p">(</span><span class="nx">sets</span><span class="p">,</span> <span class="nx">sets</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">key</span><span class="p">)));</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">sets</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 집합 합치기</span>
<span class="kd">function</span> <span class="nf">union</span><span class="p">(</span><span class="nx">sets</span><span class="p">,</span> <span class="nx">set1</span><span class="p">,</span> <span class="nx">set2</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sets</span><span class="p">.</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">v</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">v</span> <span class="o">===</span> <span class="nx">set2</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">sets</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">set1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="k">async</span> <span class="kd">function</span> <span class="nf">startKruskal</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">initMaze</span><span class="p">();</span>
    <span class="k">await</span> <span class="nf">generateKruskal</span><span class="p">();</span>
    
    <span class="c1">// 입구 표시</span>
    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">entrance</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">entrance</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="dl">'</span><span class="s1">lime</span><span class="dl">'</span><span class="p">);</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">ex</span><span class="p">,</span> <span class="nx">ey</span><span class="p">]</span> <span class="o">=</span> <span class="nf">findFurthestCell</span><span class="p">(</span><span class="nx">entrance</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">entrance</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="nx">exit</span> <span class="o">=</span> <span class="p">[</span><span class="nx">ex</span><span class="p">,</span> <span class="nx">ey</span><span class="p">];</span>
    <span class="c1">// 출구 표시</span>
    <span class="nf">drawCell</span><span class="p">(</span><span class="nx">exit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">exit</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="dl">'</span><span class="s1">blue</span><span class="dl">'</span><span class="p">);</span>
    
    <span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nf">findPathBFS</span><span class="p">(</span><span class="nx">entrance</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">entrance</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">exit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">exit</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">await</span> <span class="nf">drawPathAnimated</span><span class="p">(</span><span class="nx">path</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="완성">완성</h4>
  <hr />
</blockquote>

<p>Prim’s 알고리즘 미로</p>

<p><img src="/assets/images/posts/one-pan/JavaScript/2025-05-22-Maze Generator 02/img01.gif" alt="img01" /></p>

<p>Kruskal’s 알고리즘 미로</p>

<p><img src="/assets/images/posts/one-pan/JavaScript/2025-05-22-Maze Generator 02/img02.gif" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>미로 그려지는게 예쁘다.<br />
가만히 보고 있으면 기분이 좋아진다.</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="/play/Maze%20Generator.html" target="_blank" rel="noopener noreferrer">
  직접 해보기
</a></p>

<p>Prim’s<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-22-Prim.js">Link to GitHub</a></p>

<p>Kruskal’s<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-22-Kruskal.js">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="one-pan/JavaScript/" /><summary type="html"><![CDATA[개요 Prim’s 알고리즘과 Kruskal’s 알고리즘의 미로를 추가하기 구현 시작 전에 공통으로 사용할 함수를 index로 몰아준다. 1. Prim’s 알고리즘 DFS와 Prim의 미로는 겉으로는 제법 유사해보이는데 Prim은 탈출 경로가 훨씬 단순해진다. DFS는 한 방향으로 쭈욱 파다가 막히면 돌아가서 새로운 길을 찾는데, Prim은 미로의 경계에서 새로운 길을 만들기 때문이다. 느낌으로 비교하자면 DFS는 ‘길을 파는 것’이고 Prim은 ‘벽을 뚫는 것’이다. 벽을 뚫는 것이기 때문에 인접한 벽(여기서는 프론티어)을 모아두고 랜덤으로 선택해서 뚫어나간다. DFS와 마찬가지로 js를 작성하고 기존 html에 스크립트를 추가한다. // Prim's 알고리즘 async function generatePrim() { // 시작점 (0,0) const startX = 0; const startY = 0; maze[startY][startX] = 0; drawCell(startX, startY, 'white'); // 프론티어 셀 const frontiers = []; const frontierSet = new Set(); addFrontiers(startX, startY, frontiers, frontierSet); while (frontiers.length &gt; 0) { // 무작위 프론티어 선택 const randomIndex = Math.floor(Math.random() * frontiers.length); const [x, y] = frontiers.splice(randomIndex, 1)[0]; frontierSet.delete(`${x},${y}`); // 인접한 통로 찾기 (경계 포함) const neighbors = getNeighbors(x, y); if (neighbors.length === 0) { // 인접 통로 없으면 무시 continue; } // 무작위 인접 통로 선택 const [nx, ny] = neighbors[Math.floor(Math.random() * neighbors.length)]; // 벽 뚫기 const wallX = (x + nx) / 2; const wallY = (y + ny) / 2; maze[y][x] = 0; maze[wallY][wallX] = 0; drawCell(x, y, 'white'); drawCell(wallX, wallY, 'white'); // 새로운 프론티어 추가 addFrontiers(x, y, frontiers, frontierSet); await sleep(5); } } // 프론티어 셀 추가 (중복 방지, 경계 포함) function addFrontiers(x, y, frontiers, frontierSet) { const dirs = [[0, -2], [2, 0], [0, 2], [-2, 0]]; for (let [dx, dy] of dirs) { const nx = x + dx; const ny = y + dy; const key = `${nx},${ny}`; if (nx &gt;= 0 &amp;&amp; nx &lt; cols &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; rows &amp;&amp; maze[ny][nx] === 1 &amp;&amp; !frontierSet.has(key)) { frontiers.push([nx, ny]); frontierSet.add(key); } } } // 인접한 통로 찾기 (경계 포함) function getNeighbors(x, y) { const neighbors = []; const dirs = [[0, -2], [2, 0], [0, 2], [-2, 0]]; for (let [dx, dy] of dirs) { const nx = x + dx; const ny = y + dy; if (nx &gt;= 0 &amp;&amp; nx &lt; cols &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; rows &amp;&amp; maze[ny][nx] === 0) { neighbors.push([nx, ny]); } } return neighbors; } async function startPrim() { initMaze(); await generatePrim(); // 입구 표시 drawCell(entrance[0], entrance[1], 'lime'); // 가장 먼 곳이 출구 const [ex, ey] = findFurthestCell(entrance[0], entrance[1]); exit = [ex, ey]; // 출구 표시 drawCell(exit[0], exit[1], 'blue'); const path = findPathBFS(entrance[0], entrance[1], exit[0], exit[1]); await drawPathAnimated(path); } 2. Kruskal’s 알고리즘 Kruskal 미로는 벽에 갇힌 통로를 생성해두고 무작위로 벽을 뚫어 통로를 연결하는 방식이다. 복잡도로 따지면 Prim 보다는 복잡하고 DFS보다는 덜 복잡한 느낌이다. Prim도 벽을 뚫고 Kruskal도 벽을 뚫는데 차이가 있다면 Prim은 현재 통로와 인접한 벽만 뚫어서 확장해 나가는 것이고 Kruskal은 미로 전체 벽에서 무작위로 통로가 합쳐지도록 뚫는 것이다. 그러니 Prim보다 더 복잡해 보일 수 밖에. // Kruskal's 알고리즘 async function generateKruskal() { const sets = new Map(); const walls = []; // 짝수 좌표만 통로로 초기화, 집합 생성 for (let y = 0; y &lt;= rows; y += 2) { for (let x = 0; x &lt;= cols; x += 2) { maze[y][x] = 0; drawCell(x, y, 'white'); sets.set(`${x},${y}`, `${x},${y}`); } } // 통로 사이의 벽만 벽 리스트에 추가 for (let y = 0; y &lt;= rows; y += 2) { for (let x = 0; x &lt;= cols; x += 2) { if (x + 2 &lt; cols) { // 수평 벽 walls.push([x + 1, y, x, y, x + 2, y]); } if (y + 2 &lt; rows) { // 수직 벽 walls.push([x, y + 1, x, y, x, y + 2]); } } } // 벽을 무작위로 섞기 for (let i = walls.length - 1; i &gt; 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [walls[i], walls[j]] = [walls[j], walls[i]]; } // 하나씩 꺼내서 뚫기 for (let [wx, wy, x1, y1, x2, y2] of walls) { const set1 = findSet(sets, `${x1},${y1}`); const set2 = findSet(sets, `${x2},${y2}`); if (set1 !== set2) { maze[wy][wx] = 0; drawCell(wx, wy, 'white'); union(sets, set1, set2); await sleep(5); } } } // 경로 압축을 위한 집합 찾기 function findSet(sets, key) { if (sets.get(key) !== key) { sets.set(key, findSet(sets, sets.get(key))); } return sets.get(key); } // 집합 합치기 function union(sets, set1, set2) { sets.forEach((v, k) =&gt; { if (v === set2) { sets.set(k, set1); } }); } async function startKruskal() { initMaze(); await generateKruskal(); // 입구 표시 drawCell(entrance[0], entrance[1], 'lime'); const [ex, ey] = findFurthestCell(entrance[0], entrance[1]); exit = [ex, ey]; // 출구 표시 drawCell(exit[0], exit[1], 'blue'); const path = findPathBFS(entrance[0], entrance[1], exit[0], exit[1]); await drawPathAnimated(path); } 완성 Prim’s 알고리즘 미로 Kruskal’s 알고리즘 미로 반성 미로 그려지는게 예쁘다. 가만히 보고 있으면 기분이 좋아진다. 코드 확인 직접 해보기 Prim’s Link to GitHub Kruskal’s Link to GitHub]]></summary></entry><entry><title type="html">26226번 Autocomplete</title><link href="https://movingwoo.com/random-solve/c++/2025/05/21/26226.html" rel="alternate" type="text/html" title="26226번 Autocomplete" /><published>2025-05-21T06:00:00+00:00</published><updated>2025-05-21T06:00:00+00:00</updated><id>https://movingwoo.com/random-solve/c++/2025/05/21/26226</id><content type="html" xml:base="https://movingwoo.com/random-solve/c++/2025/05/21/26226.html"><![CDATA[<blockquote>
  <h4 id="문제">문제</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/C++/2025-05-21-26226/img01.jpg" alt="img01" /></p>

<p><a href="https://www.acmicpc.net/problem/26226">26226번 Autocomplete - 백준</a></p>

<blockquote>
  <h4 id="설계">설계</h4>
  <hr />
</blockquote>

<p>앗 영어 문제</p>

<p>단어를 비교하는 문제이다.<br />
두 단어가 “비슷하다”고 말하는 조건은 다음과 같다.</p>
<ul>
  <li>대소문자 구분 없이 비교했을 때 완전히 같음</li>
  <li>대소문자를 구분하면 서로 다른 문자의 위치가 K개 이하</li>
</ul>

<p>단어의 길이 최대 2000, 단어 사전 1000개, 질의 1000개다.<br />
생각보다 숫자가 좀 크다?</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-시간-초과의-역사">1. 시간 초과의 역사</h5>

<p><span style="color: orange;"><strong>2000 * 1000 * 1000 = 2000000000</strong></span><br />
<span style="color: red;"><strong>이런 미친 숫자가!</strong></span></p>

<p>문제의 제한시간은 1초다.<br />
탐색범위를 최대한 줄여야한다.<br />
K는 최대 5기 때문에 빠른 탈출 트리거로 사용할 수 있는데<br />
나머지 숫자는 커서 잘 생각해야한다.</p>

<p>아래는 시간 초과난 경우</p>
<ol>
  <li>문자열 전체 비교하면 터져서 소문자 변환 후 별도 저장했지만 터짐</li>
  <li>마스킹 처리 후 비트기반 xor 연산했지만 터짐</li>
  <li>K가 작기 때문에 가능한 모든 마스크 조합을 만들어봤지만 터짐</li>
  <li>bitset 구조로 바꿨는데 터짐</li>
  <li>다 때려치우고 소문자 정렬 후 이진탐색했는데 터짐</li>
</ol>

<p>결국 초심으로 돌아가 단순하게 후보군 필터링 후 해시 기반 탐색하니 통과되었다.</p>

<h5 id="2-입력-받아-필터링-후-탐색">2. 입력 받아 필터링 후 탐색</h5>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
    <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">K</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">Q</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">K</span> <span class="o">&gt;&gt;</span> <span class="n">W</span><span class="p">;</span>

    <span class="c1">// 소문자 + 길이 기준</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;&gt;</span> <span class="n">words</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">W</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">word</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">word</span><span class="p">;</span>

        <span class="n">string</span> <span class="n">lower</span> <span class="o">=</span> <span class="n">toLower</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">word</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

        <span class="n">words</span><span class="p">[</span><span class="n">lower</span><span class="p">][</span><span class="n">length</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">Q</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Q</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">query</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">query</span><span class="p">;</span>

        <span class="n">string</span> <span class="n">lowerQuery</span> <span class="o">=</span> <span class="n">toLower</span><span class="p">(</span><span class="n">query</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">query</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="c1">// 소문자 + 길이 일치하는 단어만 대상으로 필터링</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">lowerQuery</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">words</span><span class="p">[</span><span class="n">lowerQuery</span><span class="p">].</span><span class="n">count</span><span class="p">(</span><span class="n">length</span><span class="p">))</span> <span class="p">{</span>

            <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="n">lowerQuery</span><span class="p">][</span><span class="n">length</span><span class="p">];</span>

            <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">target</span> <span class="o">:</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">caseDifference</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;=</span> <span class="n">K</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">result</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="채점">채점</h4>
  <hr />
</blockquote>

<p><img src="/assets/images/posts/random-solve/C++/2025-05-21-26226/img02.jpg" alt="img02" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>괜시리 머리 굴려서 살 붙이며 비대해지는 것 보다 가끔은 초심으로 돌아갈 필요가 있다.</p>

<p>그건 그렇고 왜 쉬운 문제는 안나오지?<br />
처음에 조건보고 할만한데? 하고 덤볐다가 피봤다.</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/random-solve/C%2B%2B/2025-05-21-26226.cpp">Link to GitHub</a></p>]]></content><author><name>movingwoo</name></author><category term="random-solve/C++/" /><summary type="html"><![CDATA[문제 26226번 Autocomplete - 백준 설계 앗 영어 문제 단어를 비교하는 문제이다. 두 단어가 “비슷하다”고 말하는 조건은 다음과 같다. 대소문자 구분 없이 비교했을 때 완전히 같음 대소문자를 구분하면 서로 다른 문자의 위치가 K개 이하 단어의 길이 최대 2000, 단어 사전 1000개, 질의 1000개다. 생각보다 숫자가 좀 크다? 구현 1. 시간 초과의 역사 2000 * 1000 * 1000 = 2000000000 이런 미친 숫자가! 문제의 제한시간은 1초다. 탐색범위를 최대한 줄여야한다. K는 최대 5기 때문에 빠른 탈출 트리거로 사용할 수 있는데 나머지 숫자는 커서 잘 생각해야한다. 아래는 시간 초과난 경우 문자열 전체 비교하면 터져서 소문자 변환 후 별도 저장했지만 터짐 마스킹 처리 후 비트기반 xor 연산했지만 터짐 K가 작기 때문에 가능한 모든 마스크 조합을 만들어봤지만 터짐 bitset 구조로 바꿨는데 터짐 다 때려치우고 소문자 정렬 후 이진탐색했는데 터짐 결국 초심으로 돌아가 단순하게 후보군 필터링 후 해시 기반 탐색하니 통과되었다. 2. 입력 받아 필터링 후 탐색 int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int K, W, Q; cin &gt;&gt; K &gt;&gt; W; // 소문자 + 길이 기준 unordered_map&lt;string, unordered_map&lt;int, vector&lt;string&gt;&gt;&gt; words; for (int i = 0; i &lt; W; ++i) { string word; cin &gt;&gt; word; string lower = toLower(word); int length = word.size(); words[lower][length].push_back(word); } cin &gt;&gt; Q; for (int i = 0; i &lt; Q; ++i) { string query; cin &gt;&gt; query; string lowerQuery = toLower(query); int length = query.size(); int result = 0; // 소문자 + 길이 일치하는 단어만 대상으로 필터링 if (words.count(lowerQuery) &amp;&amp; words[lowerQuery].count(length)) { const vector&lt;string&gt;&amp; list = words[lowerQuery][length]; for (const string&amp; target : list) { int cnt = caseDifference(query, target, K); if (cnt &lt;= K) { result++; } } } cout &lt;&lt; result &lt;&lt; '\n'; } return 0; } 채점 반성 괜시리 머리 굴려서 살 붙이며 비대해지는 것 보다 가끔은 초심으로 돌아갈 필요가 있다. 그건 그렇고 왜 쉬운 문제는 안나오지? 처음에 조건보고 할만한데? 하고 덤볐다가 피봤다. 코드 확인 Link to GitHub]]></summary></entry></feed>