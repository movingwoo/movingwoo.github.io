<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="ko" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>던전 생성기 01 - 뭐라도 하겠지</title>
<meta name="description" content="개요      신나는 던전 맵 생성기 5종 알고리즘과 함께     구현      1. 설계  던전 맵 생성 관련 대표 알고리즘에 대해 찾아보았다.                 알고리즘       스타일       특징       용도                       BSP (Binary Space Partitioning)       직사각형 방 + 복도       공간을 재귀적으로 분할, 각 방을 연결       방 중심의 던전, 구조적 배치                 Random Walk (Drunkard’s Walk)       유기적 경로, 비정형       무작위 방향 이동, 비선형 구조       자연 동굴, 탐험 중심 던전                 Cellular Automata       자연 동굴 형태, 굴곡 많음       셀 규칙 반복으로 패턴 정제       동굴 스타일 던전, 유기적 형태                 Delaunay Triangulation + MST       방 중심 + 경로 연결       무작위 방 &gt; 삼각분할 &gt; 최소 연결       모든 방 연결 보장, 전략적 맵                 Wave Function Collapse (WFC)       타일 기반, 정교한 제약       타일 제약 기반 패턴 구성       정교한 던전, 룰 기반 구조           맵을 그릴 캔버스가 있는 html은 이전 미로 생성기의 것을 그대로 가져와서 사용한다.  2. BSP 알고리즘  BSP 알고리즘을 공간을 재귀적으로 분할한다. 분할 과정이 이진트리 형태로 표현되며 방 설정을 통해 크기와 개수를 쉽게 조절 가능하다. 통로는 각 방의 중심을 직선 또는 L자로 적당히 연결한다.  방이 완전히 랜덤한 위치에 생성되기 때문에 방의 중심을 연결하는 통로의 특성 상 통로가 겹치기도 하고 두껍게 이어지기도 한다.  또 현재 입구 생성을 [0, 0]에서 가장 가까운 셀로 해두었는데 랜덤하게 생성되어 이어지는 구조 특성 상 통로가 가장 가까운 경우 통로에 입구가 생길 수도 있다. 강제로 가까운 셀을 껴서 생성시키기에는 BSP의 취지에 맞지 않은 것 같고 방과 통로를 구분할 수 있게 방 데이터를 가져오려면 공통함수로 쓰기 애매하다. 그냥 복도에 입구가 생기면 운이 나쁜걸로…  // 방 클래스 정의 class Room {   constructor(x, y, w, h) {     this.x = x;     this.y = y;     this.w = w;     this.h = h;   }    // 방의 중심 좌표   center() {     return [       Math.floor(this.x + this.w / 2),       Math.floor(this.y + this.h / 2)     ];   }    // 다른 방과 겹치는지 판정   intersects(other) {     return (       this.x &lt; other.x + other.w &amp;&amp;       this.x + this.w &gt; other.x &amp;&amp;       this.y &lt; other.y + other.h &amp;&amp;       this.y + this.h &gt; other.y     );   } }    async function startBSP() {    const MIN_SIZE = 4; // 방 최소 크기   const MAX_SIZE = 6; // 방 최대 크기   const partitions = [{ x: 0, y: 0, w: cols, h: rows }];   const rooms = []; // 생성된 방 목록    // 공간을 재귀적으로 분할   async function splitSpace(space) {     const { x, y, w, h } = space;     const horizontal = Math.random() &lt; 0.5; // 분할 방향 랜덤(수평/수직)      // 더 이상 분할이 불가능할 때(최소 크기 이하)     if ((horizontal &amp;&amp; h &lt;= 2 * MIN_SIZE) || (!horizontal &amp;&amp; w &lt;= 2 * MIN_SIZE)) {       // 방 생성 시도 (겹쳐서 실패할 경우 10회까지 재시도)       let tryCount = 0;       let room;       let overlapped;       do {         if (w - 2 &lt; MIN_SIZE || h - 2 &lt; MIN_SIZE) break; // 공간이 너무 작으면 중단          // 방 크기 랜덤 (MIN_SIZE~MAX_SIZE), 위치도 랜덤(테두리와 1칸 이상 띄움)         const rw = Math.min(           Math.floor(Math.random() * (w - 2 - MIN_SIZE + 1)) + MIN_SIZE,           MAX_SIZE         );         const rh = Math.min(           Math.floor(Math.random() * (h - 2 - MIN_SIZE + 1)) + MIN_SIZE,           MAX_SIZE         );         const rx = Math.floor(Math.random() * (w - 2 - rw + 1)) + x + 1;         const ry = Math.floor(Math.random() * (h - 2 - rh + 1)) + y + 1;         room = new Room(rx, ry, rw, rh);         overlapped = rooms.some(r =&gt; room.intersects(r));         tryCount++;       } while (overlapped &amp;&amp; tryCount &lt; 10);        // 겹치지 않는 방만 생성       if (!overlapped &amp;&amp; room) {         rooms.push(room);         // 방 내부를 흰색칠         for (let i = room.y; i &lt; room.y + room.h; i++) {           for (let j = room.x; j &lt; room.x + room.w; j++) {             map[i][j] = 0;             drawCell(j, i, &#39;white&#39;);             await sleep(1);           }         }       }       return;     }      // 분할: 수평 또는 수직으로 영역을 나눔     if (horizontal) {       // 수평 분할       const split = Math.floor(Math.random() * (h - MIN_SIZE * 2) + MIN_SIZE);       const top = { x, y, w, h: split };       const bottom = { x, y: y + split, w, h: h - split };       await splitSpace(top);       await splitSpace(bottom);     } else {       // 수직 분할       const split = Math.floor(Math.random() * (w - MIN_SIZE * 2) + MIN_SIZE);       const left = { x, y, w: split, h };       const right = { x: x + split, y, w: w - split, h };       await splitSpace(left);       await splitSpace(right);     }   }    // 터널 뚫는 함수   async function tunneling(x1, y1, x2, y2) {     const dx = Math.sign(x2 - x1);     const dy = Math.sign(y2 - y1);     // x축 방향으로 먼저 이동     while (x1 !== x2) {       map[y1][x1] = 0;       drawCell(x1, y1, &#39;white&#39;);       x1 += dx;       await sleep(1);     }     // y축 방향으로 이동     while (y1 !== y2) {       map[y1][x1] = 0;       drawCell(x1, y1, &#39;white&#39;);       y1 += dy;       await sleep(1);     }   }    await splitSpace(partitions[0]);    // 생성된 방들의 중심을 순서대로 복도로 연결   for (let i = 1; i &lt; rooms.length; i++) {     const [x1, y1] = rooms[i - 1].center();     const [x2, y2] = rooms[i].center();      if (Math.random() &lt; 0.5) {       await tunneling(x1, y1, x2, y1);       await tunneling(x2, y1, x2, y2);     } else {       await tunneling(x1, y1, x1, y2);       await tunneling(x1, y2, x2, y2);     }   }    // 입출구 생성   generateEntrance(); }   3. Random Walk 알고리즘  굉장히 간단한 알고리즘이다. 이름에서 볼 수 있듯 방향을 랜덤으로 움직이며 길을 채우고 정해둔 만큼 맵을 채우면 종료한다.  통로나 방이 곡선형으로 잘 생성되는데 랜덤으로 여기저기 쑤시다보니 통로가 너무 좁을 수 있고 전체적인 구조를 제어하기 힙들다.  async function startRandomWalk() {   initMap();      // 시작점 (중앙)   let x = Math.floor(cols / 2);   let y = Math.floor(rows / 2);      // 방문한 셀 수를 추적   let visitedCells = 0;   const targetCells = Math.floor((cols * rows) * 0.4); // 전체 셀의 40% 채우면 종료      // 4방향 이동    const directions = [       [0, -1],       [1, 0],       [0, 1],       [-1, 0]   ];      // 현재 위치를 통로로 만들고 방문 표시   map[y][x] = 0;   drawCell(x, y, &#39;white&#39;);   visitedCells++;      while (visitedCells &lt; targetCells) {       // 랜덤한 방향 선택       const [dx, dy] = directions[Math.floor(Math.random() * 4)];       const newX = x + dx;       const newY = y + dy;              // 경계 체크       if (newX &gt;= 0 &amp;&amp; newX &lt; cols &amp;&amp; newY &gt;= 0 &amp;&amp; newY &lt; rows) {           // 새로운 위치가 벽이면 통로로 만들기           if (map[newY][newX] === 1) {               map[newY][newX] = 0;               drawCell(newX, newY, &#39;white&#39;);               visitedCells++;           }           x = newX;           y = newY;       }              await sleep(1);   }      generateEntrance(); }   4. Cellular Automata 알고리즘  셀의 상태를 바탕으로 다음 상태를 결정해 갱신하는 알고리즘이다.  규칙은 어떻게 정하느냐에 따라 다르겠지마는 초기에 랜덤하게 벽을 뚫어두고 4번에 거쳐 다듬어나간다. 규칙은 아래와 같이 정했다.    현재 셀이 벽인데 주변 벽이 4개 이상이면 벽 유지, 그렇지 않으면 통로로 변경   현재 셀이 통로인데 주변 벽이 5개 이상이변 벽으로 변경, 그렇지 않으면 통로 유지   위 과정을 거쳐 자연스러운 동굴 형태의 맵이 완성된다. 엄격한 규칙을 기반으로 다듬어나가기 때문에 뭔가 틀에 박힌 BSP와 자유롭게 칠렐레 팔렐레 뻗은 Random Walk보다 보기 좋다.  이 알고리즘도 고립된 공간이 생길 수 있는데 이는 추가적인 알고리즘을 통해 고립된 방과 통로로 연결하거나 제거하면 된다. 하지만 이번 구현에서 그 부분은 패스.  async function startCellularAutomata() {   initMap();      // 초기 랜덤 상태 생성 (약 45%의 벽)   for (let y = 0; y &lt; rows; y++) {       for (let x = 0; x &lt; cols; x++) {           // 테두리는 벽으로 설정           if (x === 0 || x === cols - 1 || y === 0 || y === rows - 1) {               map[y][x] = 1;               drawCell(x, y, &#39;black&#39;);           } else {               map[y][x] = Math.random() &lt; 0.45 ? 1 : 0;               drawCell(x, y, map[y][x] === 1 ? &#39;black&#39; : &#39;white&#39;);           }           await sleep(1);       }   }      // Cellular Automata 규칙 적용 (4회 반복)   for (let generation = 0; generation &lt; 4; generation++) {       const newMap = Array.from({ length: rows }, () =&gt; Array(cols).fill(0));              for (let y = 0; y &lt; rows; y++) {           for (let x = 0; x &lt; cols; x++) {               // 테두리는 벽 유지               if (x === 0 || x === cols - 1 || y === 0 || y === rows - 1) {                   newMap[y][x] = 1;                   continue;               }                              // 주변 8칸의 벽 개수 세기               let wallCount = 0;               for (let dy = -1; dy &lt;= 1; dy++) {                   for (let dx = -1; dx &lt;= 1; dx++) {                       if (dx === 0 &amp;&amp; dy === 0) continue;                       if (map[y + dy][x + dx] === 1) wallCount++;                   }               }                              //현재 셀이 벽인데 주변 벽이 4개 이상이면 벽 유지, 그렇지 않으면 통로로 변경               //현재 셀이 통로인데 주변 벽이 5개 이상이변 벽으로 변경, 그렇지 않으면 통로 유지               if (map[y][x] === 1) {                   newMap[y][x] = wallCount &gt;= 4 ? 1 : 0;               } else {                   newMap[y][x] = wallCount &gt;= 5 ? 1 : 0;               }                              drawCell(x, y, newMap[y][x] === 1 ? &#39;black&#39; : &#39;white&#39;);               await sleep(1);           }       }              map = newMap;   }      generateEntrance(); }      완성      BSP   Random Walk   Cellular Automata      반성      Random Walk 알고리즘과 Cellular Automata 알고리즘을 구현하며 즐거워졌다. 오래된 피쳐폰게임의 작은 미니맵을 보는 기분이다. 아 마음이 충만해진다…     코드 확인         직접 해보기   BSP Link to GitHub  Random Walk Link to GitHub  Cellular Automata Link to GitHub">



<meta property="og:type" content="article">
<meta property="og:locale" content="ko_KR">
<meta property="og:site_name" content="뭐라도 하겠지">
<meta property="og:title" content="던전 생성기 01">
<meta property="og:url" content="https://movingwoo.com/one-pan/javascript/2025/05/27/Dungeon-Generator-01.html">


  <meta property="og:description" content="개요      신나는 던전 맵 생성기 5종 알고리즘과 함께     구현      1. 설계  던전 맵 생성 관련 대표 알고리즘에 대해 찾아보았다.                 알고리즘       스타일       특징       용도                       BSP (Binary Space Partitioning)       직사각형 방 + 복도       공간을 재귀적으로 분할, 각 방을 연결       방 중심의 던전, 구조적 배치                 Random Walk (Drunkard’s Walk)       유기적 경로, 비정형       무작위 방향 이동, 비선형 구조       자연 동굴, 탐험 중심 던전                 Cellular Automata       자연 동굴 형태, 굴곡 많음       셀 규칙 반복으로 패턴 정제       동굴 스타일 던전, 유기적 형태                 Delaunay Triangulation + MST       방 중심 + 경로 연결       무작위 방 &gt; 삼각분할 &gt; 최소 연결       모든 방 연결 보장, 전략적 맵                 Wave Function Collapse (WFC)       타일 기반, 정교한 제약       타일 제약 기반 패턴 구성       정교한 던전, 룰 기반 구조           맵을 그릴 캔버스가 있는 html은 이전 미로 생성기의 것을 그대로 가져와서 사용한다.  2. BSP 알고리즘  BSP 알고리즘을 공간을 재귀적으로 분할한다. 분할 과정이 이진트리 형태로 표현되며 방 설정을 통해 크기와 개수를 쉽게 조절 가능하다. 통로는 각 방의 중심을 직선 또는 L자로 적당히 연결한다.  방이 완전히 랜덤한 위치에 생성되기 때문에 방의 중심을 연결하는 통로의 특성 상 통로가 겹치기도 하고 두껍게 이어지기도 한다.  또 현재 입구 생성을 [0, 0]에서 가장 가까운 셀로 해두었는데 랜덤하게 생성되어 이어지는 구조 특성 상 통로가 가장 가까운 경우 통로에 입구가 생길 수도 있다. 강제로 가까운 셀을 껴서 생성시키기에는 BSP의 취지에 맞지 않은 것 같고 방과 통로를 구분할 수 있게 방 데이터를 가져오려면 공통함수로 쓰기 애매하다. 그냥 복도에 입구가 생기면 운이 나쁜걸로…  // 방 클래스 정의 class Room {   constructor(x, y, w, h) {     this.x = x;     this.y = y;     this.w = w;     this.h = h;   }    // 방의 중심 좌표   center() {     return [       Math.floor(this.x + this.w / 2),       Math.floor(this.y + this.h / 2)     ];   }    // 다른 방과 겹치는지 판정   intersects(other) {     return (       this.x &lt; other.x + other.w &amp;&amp;       this.x + this.w &gt; other.x &amp;&amp;       this.y &lt; other.y + other.h &amp;&amp;       this.y + this.h &gt; other.y     );   } }    async function startBSP() {    const MIN_SIZE = 4; // 방 최소 크기   const MAX_SIZE = 6; // 방 최대 크기   const partitions = [{ x: 0, y: 0, w: cols, h: rows }];   const rooms = []; // 생성된 방 목록    // 공간을 재귀적으로 분할   async function splitSpace(space) {     const { x, y, w, h } = space;     const horizontal = Math.random() &lt; 0.5; // 분할 방향 랜덤(수평/수직)      // 더 이상 분할이 불가능할 때(최소 크기 이하)     if ((horizontal &amp;&amp; h &lt;= 2 * MIN_SIZE) || (!horizontal &amp;&amp; w &lt;= 2 * MIN_SIZE)) {       // 방 생성 시도 (겹쳐서 실패할 경우 10회까지 재시도)       let tryCount = 0;       let room;       let overlapped;       do {         if (w - 2 &lt; MIN_SIZE || h - 2 &lt; MIN_SIZE) break; // 공간이 너무 작으면 중단          // 방 크기 랜덤 (MIN_SIZE~MAX_SIZE), 위치도 랜덤(테두리와 1칸 이상 띄움)         const rw = Math.min(           Math.floor(Math.random() * (w - 2 - MIN_SIZE + 1)) + MIN_SIZE,           MAX_SIZE         );         const rh = Math.min(           Math.floor(Math.random() * (h - 2 - MIN_SIZE + 1)) + MIN_SIZE,           MAX_SIZE         );         const rx = Math.floor(Math.random() * (w - 2 - rw + 1)) + x + 1;         const ry = Math.floor(Math.random() * (h - 2 - rh + 1)) + y + 1;         room = new Room(rx, ry, rw, rh);         overlapped = rooms.some(r =&gt; room.intersects(r));         tryCount++;       } while (overlapped &amp;&amp; tryCount &lt; 10);        // 겹치지 않는 방만 생성       if (!overlapped &amp;&amp; room) {         rooms.push(room);         // 방 내부를 흰색칠         for (let i = room.y; i &lt; room.y + room.h; i++) {           for (let j = room.x; j &lt; room.x + room.w; j++) {             map[i][j] = 0;             drawCell(j, i, &#39;white&#39;);             await sleep(1);           }         }       }       return;     }      // 분할: 수평 또는 수직으로 영역을 나눔     if (horizontal) {       // 수평 분할       const split = Math.floor(Math.random() * (h - MIN_SIZE * 2) + MIN_SIZE);       const top = { x, y, w, h: split };       const bottom = { x, y: y + split, w, h: h - split };       await splitSpace(top);       await splitSpace(bottom);     } else {       // 수직 분할       const split = Math.floor(Math.random() * (w - MIN_SIZE * 2) + MIN_SIZE);       const left = { x, y, w: split, h };       const right = { x: x + split, y, w: w - split, h };       await splitSpace(left);       await splitSpace(right);     }   }    // 터널 뚫는 함수   async function tunneling(x1, y1, x2, y2) {     const dx = Math.sign(x2 - x1);     const dy = Math.sign(y2 - y1);     // x축 방향으로 먼저 이동     while (x1 !== x2) {       map[y1][x1] = 0;       drawCell(x1, y1, &#39;white&#39;);       x1 += dx;       await sleep(1);     }     // y축 방향으로 이동     while (y1 !== y2) {       map[y1][x1] = 0;       drawCell(x1, y1, &#39;white&#39;);       y1 += dy;       await sleep(1);     }   }    await splitSpace(partitions[0]);    // 생성된 방들의 중심을 순서대로 복도로 연결   for (let i = 1; i &lt; rooms.length; i++) {     const [x1, y1] = rooms[i - 1].center();     const [x2, y2] = rooms[i].center();      if (Math.random() &lt; 0.5) {       await tunneling(x1, y1, x2, y1);       await tunneling(x2, y1, x2, y2);     } else {       await tunneling(x1, y1, x1, y2);       await tunneling(x1, y2, x2, y2);     }   }    // 입출구 생성   generateEntrance(); }   3. Random Walk 알고리즘  굉장히 간단한 알고리즘이다. 이름에서 볼 수 있듯 방향을 랜덤으로 움직이며 길을 채우고 정해둔 만큼 맵을 채우면 종료한다.  통로나 방이 곡선형으로 잘 생성되는데 랜덤으로 여기저기 쑤시다보니 통로가 너무 좁을 수 있고 전체적인 구조를 제어하기 힙들다.  async function startRandomWalk() {   initMap();      // 시작점 (중앙)   let x = Math.floor(cols / 2);   let y = Math.floor(rows / 2);      // 방문한 셀 수를 추적   let visitedCells = 0;   const targetCells = Math.floor((cols * rows) * 0.4); // 전체 셀의 40% 채우면 종료      // 4방향 이동    const directions = [       [0, -1],       [1, 0],       [0, 1],       [-1, 0]   ];      // 현재 위치를 통로로 만들고 방문 표시   map[y][x] = 0;   drawCell(x, y, &#39;white&#39;);   visitedCells++;      while (visitedCells &lt; targetCells) {       // 랜덤한 방향 선택       const [dx, dy] = directions[Math.floor(Math.random() * 4)];       const newX = x + dx;       const newY = y + dy;              // 경계 체크       if (newX &gt;= 0 &amp;&amp; newX &lt; cols &amp;&amp; newY &gt;= 0 &amp;&amp; newY &lt; rows) {           // 새로운 위치가 벽이면 통로로 만들기           if (map[newY][newX] === 1) {               map[newY][newX] = 0;               drawCell(newX, newY, &#39;white&#39;);               visitedCells++;           }           x = newX;           y = newY;       }              await sleep(1);   }      generateEntrance(); }   4. Cellular Automata 알고리즘  셀의 상태를 바탕으로 다음 상태를 결정해 갱신하는 알고리즘이다.  규칙은 어떻게 정하느냐에 따라 다르겠지마는 초기에 랜덤하게 벽을 뚫어두고 4번에 거쳐 다듬어나간다. 규칙은 아래와 같이 정했다.    현재 셀이 벽인데 주변 벽이 4개 이상이면 벽 유지, 그렇지 않으면 통로로 변경   현재 셀이 통로인데 주변 벽이 5개 이상이변 벽으로 변경, 그렇지 않으면 통로 유지   위 과정을 거쳐 자연스러운 동굴 형태의 맵이 완성된다. 엄격한 규칙을 기반으로 다듬어나가기 때문에 뭔가 틀에 박힌 BSP와 자유롭게 칠렐레 팔렐레 뻗은 Random Walk보다 보기 좋다.  이 알고리즘도 고립된 공간이 생길 수 있는데 이는 추가적인 알고리즘을 통해 고립된 방과 통로로 연결하거나 제거하면 된다. 하지만 이번 구현에서 그 부분은 패스.  async function startCellularAutomata() {   initMap();      // 초기 랜덤 상태 생성 (약 45%의 벽)   for (let y = 0; y &lt; rows; y++) {       for (let x = 0; x &lt; cols; x++) {           // 테두리는 벽으로 설정           if (x === 0 || x === cols - 1 || y === 0 || y === rows - 1) {               map[y][x] = 1;               drawCell(x, y, &#39;black&#39;);           } else {               map[y][x] = Math.random() &lt; 0.45 ? 1 : 0;               drawCell(x, y, map[y][x] === 1 ? &#39;black&#39; : &#39;white&#39;);           }           await sleep(1);       }   }      // Cellular Automata 규칙 적용 (4회 반복)   for (let generation = 0; generation &lt; 4; generation++) {       const newMap = Array.from({ length: rows }, () =&gt; Array(cols).fill(0));              for (let y = 0; y &lt; rows; y++) {           for (let x = 0; x &lt; cols; x++) {               // 테두리는 벽 유지               if (x === 0 || x === cols - 1 || y === 0 || y === rows - 1) {                   newMap[y][x] = 1;                   continue;               }                              // 주변 8칸의 벽 개수 세기               let wallCount = 0;               for (let dy = -1; dy &lt;= 1; dy++) {                   for (let dx = -1; dx &lt;= 1; dx++) {                       if (dx === 0 &amp;&amp; dy === 0) continue;                       if (map[y + dy][x + dx] === 1) wallCount++;                   }               }                              //현재 셀이 벽인데 주변 벽이 4개 이상이면 벽 유지, 그렇지 않으면 통로로 변경               //현재 셀이 통로인데 주변 벽이 5개 이상이변 벽으로 변경, 그렇지 않으면 통로 유지               if (map[y][x] === 1) {                   newMap[y][x] = wallCount &gt;= 4 ? 1 : 0;               } else {                   newMap[y][x] = wallCount &gt;= 5 ? 1 : 0;               }                              drawCell(x, y, newMap[y][x] === 1 ? &#39;black&#39; : &#39;white&#39;);               await sleep(1);           }       }              map = newMap;   }      generateEntrance(); }      완성      BSP   Random Walk   Cellular Automata      반성      Random Walk 알고리즘과 Cellular Automata 알고리즘을 구현하며 즐거워졌다. 오래된 피쳐폰게임의 작은 미니맵을 보는 기분이다. 아 마음이 충만해진다…     코드 확인         직접 해보기   BSP Link to GitHub  Random Walk Link to GitHub  Cellular Automata Link to GitHub">







  <meta property="article:published_time" content="2025-05-27T02:00:00+00:00">



  <meta property="article:modified_time" content="2025-05-27T02:00:00+00:00">




<link rel="canonical" href="https://movingwoo.com/one-pan/javascript/2025/05/27/Dungeon-Generator-01.html">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "뭐라도 하겠지",
      "url": "https://movingwoo.com/"
    
  }
</script>







<!-- end _includes/seo.html -->


<!-- Favicon -->
<link rel="icon" type="image/png" sizes="32x32" href="/assets/images/common/favicon_32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/images/common/favicon_16x16.png">
<link rel="apple-touch-icon" sizes="180x180" href="/assets/images/common/favicon_180x180.png">
<link rel="manifest" href="/assets/site.webmanifest">


  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="뭐라도 하겠지 Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<script>
document.addEventListener('DOMContentLoaded', function() {
  const dropdownBtn = document.querySelector('.head-content-btn');
  const dropdownContent = document.querySelector('.game-dropdown-content');
  let isOpen = false;

  // 드롭다운 버튼 클릭 이벤트
  dropdownBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    isOpen = !isOpen;
    if (isOpen) {
      const rect = dropdownBtn.getBoundingClientRect();
      dropdownContent.style.top = rect.bottom + 'px';
      dropdownContent.style.left = rect.left + 'px';
      dropdownContent.classList.add('show');
    } else {
      dropdownContent.classList.remove('show');
    }
  });

  // 외부 클릭 시 드롭다운 닫기
  document.addEventListener('click', function(e) {
    if (isOpen && !dropdownContent.contains(e.target) && !dropdownBtn.contains(e.target)) {
      isOpen = false;
      dropdownContent.classList.remove('show');
    }
  });
});
</script>

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/common/favicon_180x180.png" alt="뭐라도 하겠지"></a>
        
        <a class="site-title" href="/">
          뭐라도 하겠지
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
            <div class="game-dropdown">
              <button class="head-content-btn">
                play <i class="fas fa-caret-down"></i>
              </button>
              <div class="game-dropdown-content">
                <a href="/play/Flappy%20Bird.html" target="_blank">Flappy Bird</a>
                <a href="/play/Minesweeper.html" target="_blank">Minesweeper</a>
                <a href="/play/Random%20Printer.html" target="_blank">Random Printer</a>
                <a href="/play/Maze%20Generator.html" target="_blank">Maze Generator</a>
                <a href="/play/Dungeon%20Generator.html" target="_blank">Dungeon Generator</a>
              </div>
            </div>
          </li>
          <li class="masthead__menu-item">
            <button class="head-content-btn" onclick="window.location.href='/board?path='">
              explorer
            </button>
          </li>
        </ul>
        <div class="search-container">
          <input type="text" id="search-input" placeholder="제목 검색" class="search-input">
          <button class="search-button" type="button">
            <i class="fas fa-search"></i>
          </button>
        </div>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>

<!-- 
  <h1 class="title__logo"><a href="https://movingwoo.com/">뭐라도 하겠지</a></h1>
 -->



<script src="/assets/js/search.js"></script>


    <div class="initial-content">
      



<div class="home-layout">
  <div class="home-sidebar">
    







<aside class="sidebar__left">
  <div class="toc-wrapper">
    <nav class="toc">
      <header>
        <h4 class="nav__title">
          <span class="title-text">
            <i class="fas fa-sitemap"></i> Archive
          </span>
          <a href="/board?path=" class="search-link" title="탐색">
            <i class="fas fa-list-ul"></i>
          </a>
        </h4>
      </header>

      <ul class="toc__menu">
        
          
          
          
          
          
          
          <li class="toc__item depth-0" data-path="AI-playground/" data-total-posts="0">
            <div class="toc__menu-title">
              <span class="folder-toggle">
                <i class="fas fa-folder-open"></i>
              </span>
              <span class="folder-name">AI-playground</span>
              
              
            </div>
            
            
            
            <ul class="toc__menu submenu">
              
                
              
                
                  
                  
                  
                
              
                
                  
                  
                  
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
            </ul>
          </li>
        
          
          
          
          
          
          
          <li class="toc__item depth-1" data-path="AI-playground/Claude/" data-total-posts="2">
            <div class="toc__menu-title">
              <span class="folder-toggle">
                <i class="fas fa-folder-open"></i>
              </span>
              <span class="folder-name">Claude</span>
              
              
                <span class="post-count">2</span>
              
            </div>
            
            
              <ul class="toc__menu posts-list">
                
                  <li>
                    <a href="/ai-playground/claude/2025/05/01/Claude.html" class="toc__link">
                      <i class="fas fa-file-alt"></i> 즐거운 연휴, 어떻게 보내면 좋을까?
                    </a>
                  </li>
                
                  <li>
                    <a href="/ai-playground/claude/2025/04/30/Claude.html" class="toc__link">
                      <i class="fas fa-file-alt"></i> AI 시대의 개발자, 어떻게 준비해야 할까?
                    </a>
                  </li>
                
                
              </ul>
            
            
            <ul class="toc__menu submenu">
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
            </ul>
          </li>
        
          
          
          
          
          
          
          <li class="toc__item depth-1" data-path="AI-playground/GPT/" data-total-posts="3">
            <div class="toc__menu-title">
              <span class="folder-toggle">
                <i class="fas fa-folder-open"></i>
              </span>
              <span class="folder-name">GPT</span>
              
              
                <span class="post-count">3</span>
              
            </div>
            
            
              <ul class="toc__menu posts-list">
                
                  <li>
                    <a href="/ai-playground/gpt/2025/05/14/GPT.html" class="toc__link">
                      <i class="fas fa-file-alt"></i> 파이썬으로 CLI TODO 리스트 만들어보기
                    </a>
                  </li>
                
                  <li>
                    <a href="/ai-playground/gpt/2025/05/01/GPT.html" class="toc__link">
                      <i class="fas fa-file-alt"></i> 즐거운 연휴
                    </a>
                  </li>
                
                  <li>
                    <a href="/ai-playground/gpt/2025/04/30/GPT.html" class="toc__link">
                      <i class="fas fa-file-alt"></i> 프로그래머를 위한 생산성 툴 TOP 5 🧰
                    </a>
                  </li>
                
                
              </ul>
            
            
            <ul class="toc__menu submenu">
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
            </ul>
          </li>
        
          
          
          
          
          
          
          <li class="toc__item depth-0" data-path="one-pan/" data-total-posts="0">
            <div class="toc__menu-title">
              <span class="folder-toggle">
                <i class="fas fa-folder-open"></i>
              </span>
              <span class="folder-name">one-pan</span>
              
              
            </div>
            
            
            
            <ul class="toc__menu submenu">
              
                
              
                
              
                
              
                
              
                
                  
                  
                  
                
              
                
                  
                  
                  
                
              
                
                  
                  
                  
                
              
                
                  
                  
                  
                
              
                
                  
                  
                  
                
              
                
              
                
              
                
              
                
              
            </ul>
          </li>
        
          
          
          
          
          
          
          <li class="toc__item depth-1" data-path="one-pan/Java/" data-total-posts="1">
            <div class="toc__menu-title">
              <span class="folder-toggle">
                <i class="fas fa-folder-open"></i>
              </span>
              <span class="folder-name">Java</span>
              
              
                <span class="post-count">1</span>
              
            </div>
            
            
              <ul class="toc__menu posts-list">
                
                  <li>
                    <a href="/one-pan/java/2025/05/11/Bulls-and-Cows.html" class="toc__link">
                      <i class="fas fa-file-alt"></i> 숫자야구
                    </a>
                  </li>
                
                
              </ul>
            
            
            <ul class="toc__menu submenu">
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
            </ul>
          </li>
        
          
          
          
          
          
          
          <li class="toc__item depth-1" data-path="one-pan/JavaScript/" data-total-posts="8">
            <div class="toc__menu-title">
              <span class="folder-toggle">
                <i class="fas fa-folder-open"></i>
              </span>
              <span class="folder-name">JavaScript</span>
              
              
                <span class="post-count">8</span>
              
            </div>
            
            
              <ul class="toc__menu posts-list">
                
                  <li>
                    <a href="/one-pan/javascript/2025/05/28/Dungeon-Generator-02.html" class="toc__link">
                      <i class="fas fa-file-alt"></i> 던전 생성기 02
                    </a>
                  </li>
                
                  <li>
                    <a href="/one-pan/javascript/2025/05/27/Dungeon-Generator-01.html" class="toc__link">
                      <i class="fas fa-file-alt"></i> 던전 생성기 01
                    </a>
                  </li>
                
                  <li>
                    <a href="/one-pan/javascript/2025/05/23/Maze-Generator-03.html" class="toc__link">
                      <i class="fas fa-file-alt"></i> 미로 생성기 03
                    </a>
                  </li>
                
                
                  <li>
                    <a href="/board?path=one-pan%2FJavaScript%2F" class="toc__link more-posts">
                      <i class="fas fa-ellipsis-h"></i> 더보기
                    </a>
                  </li>
                
              </ul>
            
            
            <ul class="toc__menu submenu">
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
            </ul>
          </li>
        
          
          
          
          
          
          
          <li class="toc__item depth-1" data-path="one-pan/Python/" data-total-posts="2">
            <div class="toc__menu-title">
              <span class="folder-toggle">
                <i class="fas fa-folder-open"></i>
              </span>
              <span class="folder-name">Python</span>
              
              
                <span class="post-count">2</span>
              
            </div>
            
            
              <ul class="toc__menu posts-list">
                
                  <li>
                    <a href="/one-pan/python/2025/06/04/WebP-Converter.html" class="toc__link">
                      <i class="fas fa-file-alt"></i> WebP 변환기
                    </a>
                  </li>
                
                  <li>
                    <a href="/one-pan/python/2025/05/13/Clicker.html" class="toc__link">
                      <i class="fas fa-file-alt"></i> 클리커
                    </a>
                  </li>
                
                
              </ul>
            
            
            <ul class="toc__menu submenu">
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
            </ul>
          </li>
        
          
          
          
          
          
          
          <li class="toc__item depth-1" data-path="one-pan/ShellScript/" data-total-posts="2">
            <div class="toc__menu-title">
              <span class="folder-toggle">
                <i class="fas fa-folder-open"></i>
              </span>
              <span class="folder-name">ShellScript</span>
              
              
                <span class="post-count">2</span>
              
            </div>
            
            
              <ul class="toc__menu posts-list">
                
                  <li>
                    <a href="/one-pan/shellscript/2025/05/12/File-Copier.html" class="toc__link">
                      <i class="fas fa-file-alt"></i> 파일 복사기
                    </a>
                  </li>
                
                  <li>
                    <a href="/one-pan/shellscript/2025/04/28/Server-Manage-Console.html" class="toc__link">
                      <i class="fas fa-file-alt"></i> 서버 관리 콘솔
                    </a>
                  </li>
                
                
              </ul>
            
            
            <ul class="toc__menu submenu">
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
            </ul>
          </li>
        
          
          
          
          
          
          
          <li class="toc__item depth-1" data-path="one-pan/Shortcuts/" data-total-posts="1">
            <div class="toc__menu-title">
              <span class="folder-toggle">
                <i class="fas fa-folder-open"></i>
              </span>
              <span class="folder-name">Shortcuts</span>
              
              
                <span class="post-count">1</span>
              
            </div>
            
            
              <ul class="toc__menu posts-list">
                
                  <li>
                    <a href="/one-pan/shortcuts/2025/06/02/Magic-Conch-Shell.html" class="toc__link">
                      <i class="fas fa-file-alt"></i> 마법의 소라고둥
                    </a>
                  </li>
                
                
              </ul>
            
            
            <ul class="toc__menu submenu">
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
            </ul>
          </li>
        
          
          
          
          
          
          
          <li class="toc__item depth-0" data-path="random-solve/" data-total-posts="0">
            <div class="toc__menu-title">
              <span class="folder-toggle">
                <i class="fas fa-folder-open"></i>
              </span>
              <span class="folder-name">random-solve</span>
              
              
            </div>
            
            
            
            <ul class="toc__menu submenu">
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
                  
                  
                  
                
              
                
                  
                  
                  
                
              
                
                  
                  
                  
                
              
            </ul>
          </li>
        
          
          
          
          
          
          
          <li class="toc__item depth-1" data-path="random-solve/C++/" data-total-posts="5">
            <div class="toc__menu-title">
              <span class="folder-toggle">
                <i class="fas fa-folder-open"></i>
              </span>
              <span class="folder-name">C++</span>
              
              
                <span class="post-count">5</span>
              
            </div>
            
            
              <ul class="toc__menu posts-list">
                
                  <li>
                    <a href="/random-solve/c++/2025/05/30/7663.html" class="toc__link">
                      <i class="fas fa-file-alt"></i> 7663번 Dreadful Deadlines
                    </a>
                  </li>
                
                  <li>
                    <a href="/random-solve/c++/2025/05/28/16085.html" class="toc__link">
                      <i class="fas fa-file-alt"></i> 16085번 Гэмт хэрэг
                    </a>
                  </li>
                
                  <li>
                    <a href="/random-solve/c++/2025/05/23/25245.html" class="toc__link">
                      <i class="fas fa-file-alt"></i> 25245번 Amusement Arcade
                    </a>
                  </li>
                
                
                  <li>
                    <a href="/board?path=random-solve%2FC%2B%2B%2F" class="toc__link more-posts">
                      <i class="fas fa-ellipsis-h"></i> 더보기
                    </a>
                  </li>
                
              </ul>
            
            
            <ul class="toc__menu submenu">
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
            </ul>
          </li>
        
          
          
          
          
          
          
          <li class="toc__item depth-1" data-path="random-solve/Java/" data-total-posts="5">
            <div class="toc__menu-title">
              <span class="folder-toggle">
                <i class="fas fa-folder-open"></i>
              </span>
              <span class="folder-name">Java</span>
              
              
                <span class="post-count">5</span>
              
            </div>
            
            
              <ul class="toc__menu posts-list">
                
                  <li>
                    <a href="/random-solve/java/2025/06/02/1148.html" class="toc__link">
                      <i class="fas fa-file-alt"></i> 1148번 단어 만들기
                    </a>
                  </li>
                
                  <li>
                    <a href="/random-solve/java/2025/05/30/6862.html" class="toc__link">
                      <i class="fas fa-file-alt"></i> 6862번 Tin Can Telephone
                    </a>
                  </li>
                
                  <li>
                    <a href="/random-solve/java/2025/05/28/11982.html" class="toc__link">
                      <i class="fas fa-file-alt"></i> 11982번 Angry Cows (Gold)
                    </a>
                  </li>
                
                
                  <li>
                    <a href="/board?path=random-solve%2FJava%2F" class="toc__link more-posts">
                      <i class="fas fa-ellipsis-h"></i> 더보기
                    </a>
                  </li>
                
              </ul>
            
            
            <ul class="toc__menu submenu">
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
            </ul>
          </li>
        
          
          
          
          
          
          
          <li class="toc__item depth-1" data-path="random-solve/Python/" data-total-posts="8">
            <div class="toc__menu-title">
              <span class="folder-toggle">
                <i class="fas fa-folder-open"></i>
              </span>
              <span class="folder-name">Python</span>
              
              
                <span class="post-count">8</span>
              
            </div>
            
            
              <ul class="toc__menu posts-list">
                
                  <li>
                    <a href="/random-solve/python/2025/06/04/4676.html" class="toc__link">
                      <i class="fas fa-file-alt"></i> 4676번 Haiku Review
                    </a>
                  </li>
                
                  <li>
                    <a href="/random-solve/python/2025/06/02/11761.html" class="toc__link">
                      <i class="fas fa-file-alt"></i> 11761번 Shuffling Along
                    </a>
                  </li>
                
                  <li>
                    <a href="/random-solve/python/2025/05/30/15654.html" class="toc__link">
                      <i class="fas fa-file-alt"></i> 15654번 N과 M (5)
                    </a>
                  </li>
                
                
                  <li>
                    <a href="/board?path=random-solve%2FPython%2F" class="toc__link more-posts">
                      <i class="fas fa-ellipsis-h"></i> 더보기
                    </a>
                  </li>
                
              </ul>
            
            
            <ul class="toc__menu submenu">
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
            </ul>
          </li>
        
      </ul>
    </nav>
  </div>
</aside>

<link rel="stylesheet" href="/assets/css/main.css">
<script src="/assets/js/toc.js"></script> 
  </div>

  <div class="home-content">
    <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
      <meta itemprop="headline" content="던전 생성기 01">
      <meta itemprop="description" content="  개요  신나는 던전 맵 생성기5종 알고리즘과 함께  구현  1. 설계던전 맵 생성 관련 대표 알고리즘에 대해 찾아보았다.            알고리즘      스타일      특징      용도                  BSP (Binary Space Partitioning)      직사각형 방 + 복도      공간을 재귀적으로 분할, 각 방을 연결      방 중심의 던전, 구조적 배치              Random Walk (Drunkard’s Walk)      유기적 경로, 비정형      무작위 방향 이동, 비선형 구조      자연 동굴, 탐험 중심 던전              Cellular Automata      자연 동굴 형태, 굴곡 많음      셀 규칙 반복으로 패턴 정제      동굴 스타일 던전, 유기적 형태              Delaunay Triangulation + MST      방 중심 + 경로 연결      무작위 방 &gt; 삼각분할 &gt; 최소 연결      모든 방 연결 보장, 전략적 맵              Wave Function Collapse (WFC)      타일 기반, 정교한 제약      타일 제약 기반 패턴 구성      정교한 던전, 룰 기반 구조      맵을 그릴 캔버스가 있는 html은 이전 미로 생성기의 것을 그대로 가져와서 사용한다.2. BSP 알고리즘BSP 알고리즘을 공간을 재귀적으로 분할한다.분할 과정이 이진트리 형태로 표현되며 방 설정을 통해 크기와 개수를 쉽게 조절 가능하다.통로는 각 방의 중심을 직선 또는 L자로 적당히 연결한다.방이 완전히 랜덤한 위치에 생성되기 때문에 방의 중심을 연결하는 통로의 특성 상통로가 겹치기도 하고 두껍게 이어지기도 한다.또 현재 입구 생성을 [0, 0]에서 가장 가까운 셀로 해두었는데랜덤하게 생성되어 이어지는 구조 특성 상 통로가 가장 가까운 경우 통로에 입구가 생길 수도 있다.강제로 가까운 셀을 껴서 생성시키기에는 BSP의 취지에 맞지 않은 것 같고방과 통로를 구분할 수 있게 방 데이터를 가져오려면 공통함수로 쓰기 애매하다.그냥 복도에 입구가 생기면 운이 나쁜걸로…// 방 클래스 정의class Room {  constructor(x, y, w, h) {    this.x = x;    this.y = y;    this.w = w;    this.h = h;  }  // 방의 중심 좌표  center() {    return [      Math.floor(this.x + this.w / 2),      Math.floor(this.y + this.h / 2)    ];  }  // 다른 방과 겹치는지 판정  intersects(other) {    return (      this.x &lt; other.x + other.w &amp;&amp;      this.x + this.w &gt; other.x &amp;&amp;      this.y &lt; other.y + other.h &amp;&amp;      this.y + this.h &gt; other.y    );  }}  async function startBSP() {  const MIN_SIZE = 4; // 방 최소 크기  const MAX_SIZE = 6; // 방 최대 크기  const partitions = [{ x: 0, y: 0, w: cols, h: rows }];  const rooms = []; // 생성된 방 목록  // 공간을 재귀적으로 분할  async function splitSpace(space) {    const { x, y, w, h } = space;    const horizontal = Math.random() &lt; 0.5; // 분할 방향 랜덤(수평/수직)    // 더 이상 분할이 불가능할 때(최소 크기 이하)    if ((horizontal &amp;&amp; h &lt;= 2 * MIN_SIZE) || (!horizontal &amp;&amp; w &lt;= 2 * MIN_SIZE)) {      // 방 생성 시도 (겹쳐서 실패할 경우 10회까지 재시도)      let tryCount = 0;      let room;      let overlapped;      do {        if (w - 2 &lt; MIN_SIZE || h - 2 &lt; MIN_SIZE) break; // 공간이 너무 작으면 중단        // 방 크기 랜덤 (MIN_SIZE~MAX_SIZE), 위치도 랜덤(테두리와 1칸 이상 띄움)        const rw = Math.min(          Math.floor(Math.random() * (w - 2 - MIN_SIZE + 1)) + MIN_SIZE,          MAX_SIZE        );        const rh = Math.min(          Math.floor(Math.random() * (h - 2 - MIN_SIZE + 1)) + MIN_SIZE,          MAX_SIZE        );        const rx = Math.floor(Math.random() * (w - 2 - rw + 1)) + x + 1;        const ry = Math.floor(Math.random() * (h - 2 - rh + 1)) + y + 1;        room = new Room(rx, ry, rw, rh);        overlapped = rooms.some(r =&gt; room.intersects(r));        tryCount++;      } while (overlapped &amp;&amp; tryCount &lt; 10);      // 겹치지 않는 방만 생성      if (!overlapped &amp;&amp; room) {        rooms.push(room);        // 방 내부를 흰색칠        for (let i = room.y; i &lt; room.y + room.h; i++) {          for (let j = room.x; j &lt; room.x + room.w; j++) {            map[i][j] = 0;            drawCell(j, i, &#39;white&#39;);            await sleep(1);          }        }      }      return;    }    // 분할: 수평 또는 수직으로 영역을 나눔    if (horizontal) {      // 수평 분할      const split = Math.floor(Math.random() * (h - MIN_SIZE * 2) + MIN_SIZE);      const top = { x, y, w, h: split };      const bottom = { x, y: y + split, w, h: h - split };      await splitSpace(top);      await splitSpace(bottom);    } else {      // 수직 분할      const split = Math.floor(Math.random() * (w - MIN_SIZE * 2) + MIN_SIZE);      const left = { x, y, w: split, h };      const right = { x: x + split, y, w: w - split, h };      await splitSpace(left);      await splitSpace(right);    }  }  // 터널 뚫는 함수  async function tunneling(x1, y1, x2, y2) {    const dx = Math.sign(x2 - x1);    const dy = Math.sign(y2 - y1);    // x축 방향으로 먼저 이동    while (x1 !== x2) {      map[y1][x1] = 0;      drawCell(x1, y1, &#39;white&#39;);      x1 += dx;      await sleep(1);    }    // y축 방향으로 이동    while (y1 !== y2) {      map[y1][x1] = 0;      drawCell(x1, y1, &#39;white&#39;);      y1 += dy;      await sleep(1);    }  }  await splitSpace(partitions[0]);  // 생성된 방들의 중심을 순서대로 복도로 연결  for (let i = 1; i &lt; rooms.length; i++) {    const [x1, y1] = rooms[i - 1].center();    const [x2, y2] = rooms[i].center();    if (Math.random() &lt; 0.5) {      await tunneling(x1, y1, x2, y1);      await tunneling(x2, y1, x2, y2);    } else {      await tunneling(x1, y1, x1, y2);      await tunneling(x1, y2, x2, y2);    }  }  // 입출구 생성  generateEntrance();}3. Random Walk 알고리즘굉장히 간단한 알고리즘이다.이름에서 볼 수 있듯 방향을 랜덤으로 움직이며 길을 채우고정해둔 만큼 맵을 채우면 종료한다.통로나 방이 곡선형으로 잘 생성되는데 랜덤으로 여기저기 쑤시다보니통로가 너무 좁을 수 있고 전체적인 구조를 제어하기 힙들다.async function startRandomWalk() {  initMap();    // 시작점 (중앙)  let x = Math.floor(cols / 2);  let y = Math.floor(rows / 2);    // 방문한 셀 수를 추적  let visitedCells = 0;  const targetCells = Math.floor((cols * rows) * 0.4); // 전체 셀의 40% 채우면 종료    // 4방향 이동   const directions = [      [0, -1],      [1, 0],      [0, 1],      [-1, 0]  ];    // 현재 위치를 통로로 만들고 방문 표시  map[y][x] = 0;  drawCell(x, y, &#39;white&#39;);  visitedCells++;    while (visitedCells &lt; targetCells) {      // 랜덤한 방향 선택      const [dx, dy] = directions[Math.floor(Math.random() * 4)];      const newX = x + dx;      const newY = y + dy;            // 경계 체크      if (newX &gt;= 0 &amp;&amp; newX &lt; cols &amp;&amp; newY &gt;= 0 &amp;&amp; newY &lt; rows) {          // 새로운 위치가 벽이면 통로로 만들기          if (map[newY][newX] === 1) {              map[newY][newX] = 0;              drawCell(newX, newY, &#39;white&#39;);              visitedCells++;          }          x = newX;          y = newY;      }            await sleep(1);  }    generateEntrance();}4. Cellular Automata 알고리즘셀의 상태를 바탕으로 다음 상태를 결정해 갱신하는 알고리즘이다.규칙은 어떻게 정하느냐에 따라 다르겠지마는초기에 랜덤하게 벽을 뚫어두고 4번에 거쳐 다듬어나간다.규칙은 아래와 같이 정했다.  현재 셀이 벽인데 주변 벽이 4개 이상이면 벽 유지, 그렇지 않으면 통로로 변경  현재 셀이 통로인데 주변 벽이 5개 이상이변 벽으로 변경, 그렇지 않으면 통로 유지위 과정을 거쳐 자연스러운 동굴 형태의 맵이 완성된다.엄격한 규칙을 기반으로 다듬어나가기 때문에 뭔가 틀에 박힌 BSP와 자유롭게 칠렐레 팔렐레 뻗은 Random Walk보다 보기 좋다.이 알고리즘도 고립된 공간이 생길 수 있는데 이는 추가적인 알고리즘을 통해 고립된 방과 통로로 연결하거나 제거하면 된다.하지만 이번 구현에서 그 부분은 패스.async function startCellularAutomata() {  initMap();    // 초기 랜덤 상태 생성 (약 45%의 벽)  for (let y = 0; y &lt; rows; y++) {      for (let x = 0; x &lt; cols; x++) {          // 테두리는 벽으로 설정          if (x === 0 || x === cols - 1 || y === 0 || y === rows - 1) {              map[y][x] = 1;              drawCell(x, y, &#39;black&#39;);          } else {              map[y][x] = Math.random() &lt; 0.45 ? 1 : 0;              drawCell(x, y, map[y][x] === 1 ? &#39;black&#39; : &#39;white&#39;);          }          await sleep(1);      }  }    // Cellular Automata 규칙 적용 (4회 반복)  for (let generation = 0; generation &lt; 4; generation++) {      const newMap = Array.from({ length: rows }, () =&gt; Array(cols).fill(0));            for (let y = 0; y &lt; rows; y++) {          for (let x = 0; x &lt; cols; x++) {              // 테두리는 벽 유지              if (x === 0 || x === cols - 1 || y === 0 || y === rows - 1) {                  newMap[y][x] = 1;                  continue;              }                            // 주변 8칸의 벽 개수 세기              let wallCount = 0;              for (let dy = -1; dy &lt;= 1; dy++) {                  for (let dx = -1; dx &lt;= 1; dx++) {                      if (dx === 0 &amp;&amp; dy === 0) continue;                      if (map[y + dy][x + dx] === 1) wallCount++;                  }              }                            //현재 셀이 벽인데 주변 벽이 4개 이상이면 벽 유지, 그렇지 않으면 통로로 변경              //현재 셀이 통로인데 주변 벽이 5개 이상이변 벽으로 변경, 그렇지 않으면 통로 유지              if (map[y][x] === 1) {                  newMap[y][x] = wallCount &gt;= 4 ? 1 : 0;              } else {                  newMap[y][x] = wallCount &gt;= 5 ? 1 : 0;              }                            drawCell(x, y, newMap[y][x] === 1 ? &#39;black&#39; : &#39;white&#39;);              await sleep(1);          }      }            map = newMap;  }    generateEntrance();}  완성  BSPRandom WalkCellular Automata  반성  Random Walk 알고리즘과 Cellular Automata 알고리즘을 구현하며 즐거워졌다.오래된 피쳐폰게임의 작은 미니맵을 보는 기분이다.아 마음이 충만해진다…  코드 확인    직접 해보기BSPLink to GitHubRandom WalkLink to GitHubCellular AutomataLink to GitHub">
      <meta itemprop="datePublished" content="2025-05-27T02:00:00+00:00">
      <meta itemprop="dateModified" content="2025-05-27T02:00:00+00:00">

      <div class="page__inner-wrap">
        
          <header>
            
<div class="post-category">
  <div class="category-path">
    <a href="/board?path=" class="category-link">Archive</a>
    
    
    
      <span class="separator">/</span>
      
      <a href="/board?path=one-pan" class="category-link">
        one-pan
      </a>
      
    
      <span class="separator">/</span>
      
      <a href="/board?path=one-pan%2FJavaScript" class="category-link">
        JavaScript
      </a>
      
    
  </div>
  <a href="/board?path=one-pan%2FJavaScript%2F" class="category-icon" title="리스트">
    <i class="fas fa-list-ul" aria-hidden="true"></i>
  </a>
</div>
 
            <h1 id="page-title" class="page__title" itemprop="headline">던전 생성기 01
</h1>
            


          </header>
        

        <section class="page__content" itemprop="text">
          <blockquote>
  <h4 id="개요">개요</h4>
  <hr />
</blockquote>

<p>신나는 던전 맵 생성기<br />
5종 알고리즘과 함께</p>

<blockquote>
  <h4 id="구현">구현</h4>
  <hr />
</blockquote>

<h5 id="1-설계">1. 설계</h5>

<p>던전 맵 생성 관련 대표 알고리즘에 대해 찾아보았다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">알고리즘</th>
      <th style="text-align: left">스타일</th>
      <th style="text-align: left">특징</th>
      <th style="text-align: left">용도</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">BSP (Binary Space Partitioning)</td>
      <td style="text-align: left">직사각형 방 + 복도</td>
      <td style="text-align: left">공간을 재귀적으로 분할, 각 방을 연결</td>
      <td style="text-align: left">방 중심의 던전, 구조적 배치</td>
    </tr>
    <tr>
      <td style="text-align: left">Random Walk (Drunkard’s Walk)</td>
      <td style="text-align: left">유기적 경로, 비정형</td>
      <td style="text-align: left">무작위 방향 이동, 비선형 구조</td>
      <td style="text-align: left">자연 동굴, 탐험 중심 던전</td>
    </tr>
    <tr>
      <td style="text-align: left">Cellular Automata</td>
      <td style="text-align: left">자연 동굴 형태, 굴곡 많음</td>
      <td style="text-align: left">셀 규칙 반복으로 패턴 정제</td>
      <td style="text-align: left">동굴 스타일 던전, 유기적 형태</td>
    </tr>
    <tr>
      <td style="text-align: left">Delaunay Triangulation + MST</td>
      <td style="text-align: left">방 중심 + 경로 연결</td>
      <td style="text-align: left">무작위 방 &gt; 삼각분할 &gt; 최소 연결</td>
      <td style="text-align: left">모든 방 연결 보장, 전략적 맵</td>
    </tr>
    <tr>
      <td style="text-align: left">Wave Function Collapse (WFC)</td>
      <td style="text-align: left">타일 기반, 정교한 제약</td>
      <td style="text-align: left">타일 제약 기반 패턴 구성</td>
      <td style="text-align: left">정교한 던전, 룰 기반 구조</td>
    </tr>
  </tbody>
</table>

<p>맵을 그릴 캔버스가 있는 html은 이전 미로 생성기의 것을 그대로 가져와서 사용한다.</p>

<h5 id="2-bsp-알고리즘">2. BSP 알고리즘</h5>

<p>BSP 알고리즘을 공간을 재귀적으로 분할한다.<br />
분할 과정이 이진트리 형태로 표현되며 방 설정을 통해 크기와 개수를 쉽게 조절 가능하다.<br />
통로는 각 방의 중심을 직선 또는 L자로 적당히 연결한다.</p>

<p>방이 완전히 랜덤한 위치에 생성되기 때문에 방의 중심을 연결하는 통로의 특성 상<br />
<span style="color: orange;"><strong>통로가 겹치기도 하고 두껍게 이어지기도 한다.</strong></span></p>

<p>또 현재 입구 생성을 [0, 0]에서 가장 가까운 셀로 해두었는데<br />
랜덤하게 생성되어 이어지는 구조 특성 상 통로가 가장 가까운 경우 통로에 입구가 생길 수도 있다.<br />
강제로 가까운 셀을 껴서 생성시키기에는 BSP의 취지에 맞지 않은 것 같고<br />
방과 통로를 구분할 수 있게 방 데이터를 가져오려면 공통함수로 쓰기 애매하다.<br />
그냥 복도에 입구가 생기면 운이 나쁜걸로…</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 방 클래스 정의</span>
<span class="kd">class</span> <span class="nc">Room</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">h</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">w</span> <span class="o">=</span> <span class="nx">w</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">h</span> <span class="o">=</span> <span class="nx">h</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 방의 중심 좌표</span>
  <span class="nf">center</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span>
      <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">w</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
      <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">h</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">// 다른 방과 겹치는지 판정</span>
  <span class="nf">intersects</span><span class="p">(</span><span class="nx">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return </span><span class="p">(</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">other</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">other</span><span class="p">.</span><span class="nx">w</span> <span class="o">&amp;&amp;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">w</span> <span class="o">&gt;</span> <span class="nx">other</span><span class="p">.</span><span class="nx">x</span> <span class="o">&amp;&amp;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">other</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">other</span><span class="p">.</span><span class="nx">h</span> <span class="o">&amp;&amp;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">h</span> <span class="o">&gt;</span> <span class="nx">other</span><span class="p">.</span><span class="nx">y</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
  
<span class="k">async</span> <span class="kd">function</span> <span class="nf">startBSP</span><span class="p">()</span> <span class="p">{</span>

  <span class="kd">const</span> <span class="nx">MIN_SIZE</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// 방 최소 크기</span>
  <span class="kd">const</span> <span class="nx">MAX_SIZE</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="c1">// 방 최대 크기</span>
  <span class="kd">const</span> <span class="nx">partitions</span> <span class="o">=</span> <span class="p">[{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">w</span><span class="p">:</span> <span class="nx">cols</span><span class="p">,</span> <span class="na">h</span><span class="p">:</span> <span class="nx">rows</span> <span class="p">}];</span>
  <span class="kd">const</span> <span class="nx">rooms</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// 생성된 방 목록</span>

  <span class="c1">// 공간을 재귀적으로 분할</span>
  <span class="k">async</span> <span class="kd">function</span> <span class="nf">splitSpace</span><span class="p">(</span><span class="nx">space</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">h</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">space</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">horizontal</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">;</span> <span class="c1">// 분할 방향 랜덤(수평/수직)</span>

    <span class="c1">// 더 이상 분할이 불가능할 때(최소 크기 이하)</span>
    <span class="k">if </span><span class="p">((</span><span class="nx">horizontal</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">MIN_SIZE</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="nx">horizontal</span> <span class="o">&amp;&amp;</span> <span class="nx">w</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">MIN_SIZE</span><span class="p">))</span> <span class="p">{</span>
      <span class="c1">// 방 생성 시도 (겹쳐서 실패할 경우 10회까지 재시도)</span>
      <span class="kd">let</span> <span class="nx">tryCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="kd">let</span> <span class="nx">room</span><span class="p">;</span>
      <span class="kd">let</span> <span class="nx">overlapped</span><span class="p">;</span>
      <span class="k">do</span> <span class="p">{</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">w</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">MIN_SIZE</span> <span class="o">||</span> <span class="nx">h</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nx">MIN_SIZE</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="c1">// 공간이 너무 작으면 중단</span>

        <span class="c1">// 방 크기 랜덤 (MIN_SIZE~MAX_SIZE), 위치도 랜덤(테두리와 1칸 이상 띄움)</span>
        <span class="kd">const</span> <span class="nx">rw</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span>
          <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">w</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="nx">MIN_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="nx">MIN_SIZE</span><span class="p">,</span>
          <span class="nx">MAX_SIZE</span>
        <span class="p">);</span>
        <span class="kd">const</span> <span class="nx">rh</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span>
          <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">h</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="nx">MIN_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="nx">MIN_SIZE</span><span class="p">,</span>
          <span class="nx">MAX_SIZE</span>
        <span class="p">);</span>
        <span class="kd">const</span> <span class="nx">rx</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">w</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="nx">rw</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">ry</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">h</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="nx">rh</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nx">room</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Room</span><span class="p">(</span><span class="nx">rx</span><span class="p">,</span> <span class="nx">ry</span><span class="p">,</span> <span class="nx">rw</span><span class="p">,</span> <span class="nx">rh</span><span class="p">);</span>
        <span class="nx">overlapped</span> <span class="o">=</span> <span class="nx">rooms</span><span class="p">.</span><span class="nf">some</span><span class="p">(</span><span class="nx">r</span> <span class="o">=&gt;</span> <span class="nx">room</span><span class="p">.</span><span class="nf">intersects</span><span class="p">(</span><span class="nx">r</span><span class="p">));</span>
        <span class="nx">tryCount</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">while </span><span class="p">(</span><span class="nx">overlapped</span> <span class="o">&amp;&amp;</span> <span class="nx">tryCount</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">);</span>

      <span class="c1">// 겹치지 않는 방만 생성</span>
      <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">overlapped</span> <span class="o">&amp;&amp;</span> <span class="nx">room</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">rooms</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">room</span><span class="p">);</span>
        <span class="c1">// 방 내부를 흰색칠</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">room</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">room</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">room</span><span class="p">.</span><span class="nx">h</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">room</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">room</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">room</span><span class="p">.</span><span class="nx">w</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">map</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="nf">drawCell</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
            <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 분할: 수평 또는 수직으로 영역을 나눔</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">horizontal</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 수평 분할</span>
      <span class="kd">const</span> <span class="nx">split</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">h</span> <span class="o">-</span> <span class="nx">MIN_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nx">MIN_SIZE</span><span class="p">);</span>
      <span class="kd">const</span> <span class="nx">top</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="na">h</span><span class="p">:</span> <span class="nx">split</span> <span class="p">};</span>
      <span class="kd">const</span> <span class="nx">bottom</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">split</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="na">h</span><span class="p">:</span> <span class="nx">h</span> <span class="o">-</span> <span class="nx">split</span> <span class="p">};</span>
      <span class="k">await</span> <span class="nf">splitSpace</span><span class="p">(</span><span class="nx">top</span><span class="p">);</span>
      <span class="k">await</span> <span class="nf">splitSpace</span><span class="p">(</span><span class="nx">bottom</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// 수직 분할</span>
      <span class="kd">const</span> <span class="nx">split</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">w</span> <span class="o">-</span> <span class="nx">MIN_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nx">MIN_SIZE</span><span class="p">);</span>
      <span class="kd">const</span> <span class="nx">left</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="na">w</span><span class="p">:</span> <span class="nx">split</span><span class="p">,</span> <span class="nx">h</span> <span class="p">};</span>
      <span class="kd">const</span> <span class="nx">right</span> <span class="o">=</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">split</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="na">w</span><span class="p">:</span> <span class="nx">w</span> <span class="o">-</span> <span class="nx">split</span><span class="p">,</span> <span class="nx">h</span> <span class="p">};</span>
      <span class="k">await</span> <span class="nf">splitSpace</span><span class="p">(</span><span class="nx">left</span><span class="p">);</span>
      <span class="k">await</span> <span class="nf">splitSpace</span><span class="p">(</span><span class="nx">right</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 터널 뚫는 함수</span>
  <span class="k">async</span> <span class="kd">function</span> <span class="nf">tunneling</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">dx</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sign</span><span class="p">(</span><span class="nx">x2</span> <span class="o">-</span> <span class="nx">x1</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">dy</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sign</span><span class="p">(</span><span class="nx">y2</span> <span class="o">-</span> <span class="nx">y1</span><span class="p">);</span>
    <span class="c1">// x축 방향으로 먼저 이동</span>
    <span class="k">while </span><span class="p">(</span><span class="nx">x1</span> <span class="o">!==</span> <span class="nx">x2</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">map</span><span class="p">[</span><span class="nx">y1</span><span class="p">][</span><span class="nx">x1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
      <span class="nx">x1</span> <span class="o">+=</span> <span class="nx">dx</span><span class="p">;</span>
      <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// y축 방향으로 이동</span>
    <span class="k">while </span><span class="p">(</span><span class="nx">y1</span> <span class="o">!==</span> <span class="nx">y2</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">map</span><span class="p">[</span><span class="nx">y1</span><span class="p">][</span><span class="nx">x1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
      <span class="nx">y1</span> <span class="o">+=</span> <span class="nx">dy</span><span class="p">;</span>
      <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">await</span> <span class="nf">splitSpace</span><span class="p">(</span><span class="nx">partitions</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

  <span class="c1">// 생성된 방들의 중심을 순서대로 복도로 연결</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">rooms</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">rooms</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="nf">center</span><span class="p">();</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">rooms</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nf">center</span><span class="p">();</span>

    <span class="k">if </span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">await</span> <span class="nf">tunneling</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y1</span><span class="p">);</span>
      <span class="k">await</span> <span class="nf">tunneling</span><span class="p">(</span><span class="nx">x2</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">await</span> <span class="nf">tunneling</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">x1</span><span class="p">,</span> <span class="nx">y2</span><span class="p">);</span>
      <span class="k">await</span> <span class="nf">tunneling</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">y2</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">y2</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 입출구 생성</span>
  <span class="nf">generateEntrance</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="3-random-walk-알고리즘">3. Random Walk 알고리즘</h5>

<p>굉장히 간단한 알고리즘이다.<br />
이름에서 볼 수 있듯 방향을 랜덤으로 움직이며 길을 채우고<br />
정해둔 만큼 맵을 채우면 종료한다.</p>

<p>통로나 방이 곡선형으로 잘 생성되는데 랜덤으로 여기저기 쑤시다보니<br />
통로가 너무 좁을 수 있고 전체적인 구조를 제어하기 힙들다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nf">startRandomWalk</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">initMap</span><span class="p">();</span>
  
  <span class="c1">// 시작점 (중앙)</span>
  <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nx">cols</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nx">rows</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
  
  <span class="c1">// 방문한 셀 수를 추적</span>
  <span class="kd">let</span> <span class="nx">visitedCells</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">targetCells</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">((</span><span class="nx">cols</span> <span class="o">*</span> <span class="nx">rows</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.4</span><span class="p">);</span> <span class="c1">// 전체 셀의 40% 채우면 종료</span>
  
  <span class="c1">// 4방향 이동 </span>
  <span class="kd">const</span> <span class="nx">directions</span> <span class="o">=</span> <span class="p">[</span>
      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
      <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
      <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
  <span class="p">];</span>
  
  <span class="c1">// 현재 위치를 통로로 만들고 방문 표시</span>
  <span class="nx">map</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">visitedCells</span><span class="o">++</span><span class="p">;</span>
  
  <span class="k">while </span><span class="p">(</span><span class="nx">visitedCells</span> <span class="o">&lt;</span> <span class="nx">targetCells</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 랜덤한 방향 선택</span>
      <span class="kd">const</span> <span class="p">[</span><span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">]</span> <span class="o">=</span> <span class="nx">directions</span><span class="p">[</span><span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)];</span>
      <span class="kd">const</span> <span class="nx">newX</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">;</span>
      <span class="kd">const</span> <span class="nx">newY</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">;</span>
      
      <span class="c1">// 경계 체크</span>
      <span class="k">if </span><span class="p">(</span><span class="nx">newX</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">newX</span> <span class="o">&lt;</span> <span class="nx">cols</span> <span class="o">&amp;&amp;</span> <span class="nx">newY</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">newY</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// 새로운 위치가 벽이면 통로로 만들기</span>
          <span class="k">if </span><span class="p">(</span><span class="nx">map</span><span class="p">[</span><span class="nx">newY</span><span class="p">][</span><span class="nx">newX</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">map</span><span class="p">[</span><span class="nx">newY</span><span class="p">][</span><span class="nx">newX</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
              <span class="nf">drawCell</span><span class="p">(</span><span class="nx">newX</span><span class="p">,</span> <span class="nx">newY</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
              <span class="nx">visitedCells</span><span class="o">++</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="nx">x</span> <span class="o">=</span> <span class="nx">newX</span><span class="p">;</span>
          <span class="nx">y</span> <span class="o">=</span> <span class="nx">newY</span><span class="p">;</span>
      <span class="p">}</span>
      
      <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="nf">generateEntrance</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="4-cellular-automata-알고리즘">4. Cellular Automata 알고리즘</h5>

<p><span style="color: orange;"><strong>셀의 상태를 바탕으로 다음 상태를 결정해 갱신</strong></span>하는 알고리즘이다.</p>

<p>규칙은 어떻게 정하느냐에 따라 다르겠지마는<br />
초기에 랜덤하게 벽을 뚫어두고 4번에 거쳐 다듬어나간다.<br />
규칙은 아래와 같이 정했다.</p>
<ul>
  <li>현재 셀이 벽인데 주변 벽이 4개 이상이면 벽 유지, 그렇지 않으면 통로로 변경</li>
  <li>현재 셀이 통로인데 주변 벽이 5개 이상이변 벽으로 변경, 그렇지 않으면 통로 유지</li>
</ul>

<p>위 과정을 거쳐 자연스러운 동굴 형태의 맵이 완성된다.<br />
엄격한 규칙을 기반으로 다듬어나가기 때문에 뭔가 틀에 박힌 BSP와 자유롭게 칠렐레 팔렐레 뻗은 Random Walk보다 보기 좋다.</p>

<p>이 알고리즘도 고립된 공간이 생길 수 있는데 이는 추가적인 알고리즘을 통해 고립된 방과 통로로 연결하거나 제거하면 된다.<br />
하지만 이번 구현에서 그 부분은 패스.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nf">startCellularAutomata</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">initMap</span><span class="p">();</span>
  
  <span class="c1">// 초기 랜덤 상태 생성 (약 45%의 벽)</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// 테두리는 벽으로 설정</span>
          <span class="k">if </span><span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">x</span> <span class="o">===</span> <span class="nx">cols</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">===</span> <span class="nx">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">map</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
              <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span><span class="p">);</span>
          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
              <span class="nx">map</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.45</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
              <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">map</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
  
  <span class="c1">// Cellular Automata 규칙 적용 (4회 반복)</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">generation</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">generation</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="nx">generation</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">newMap</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">({</span> <span class="na">length</span><span class="p">:</span> <span class="nx">rows</span> <span class="p">},</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nc">Array</span><span class="p">(</span><span class="nx">cols</span><span class="p">).</span><span class="nf">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
      
      <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// 테두리는 벽 유지</span>
              <span class="k">if </span><span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">x</span> <span class="o">===</span> <span class="nx">cols</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">===</span> <span class="nx">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">newMap</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                  <span class="k">continue</span><span class="p">;</span>
              <span class="p">}</span>
              
              <span class="c1">// 주변 8칸의 벽 개수 세기</span>
              <span class="kd">let</span> <span class="nx">wallCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
              <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">dy</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">dy</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">dy</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">dx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">dx</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">dx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">if </span><span class="p">(</span><span class="nx">dx</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">dy</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
                      <span class="k">if </span><span class="p">(</span><span class="nx">map</span><span class="p">[</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">][</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="nx">wallCount</span><span class="o">++</span><span class="p">;</span>
                  <span class="p">}</span>
              <span class="p">}</span>
              
              <span class="c1">//현재 셀이 벽인데 주변 벽이 4개 이상이면 벽 유지, 그렇지 않으면 통로로 변경</span>
              <span class="c1">//현재 셀이 통로인데 주변 벽이 5개 이상이변 벽으로 변경, 그렇지 않으면 통로 유지</span>
              <span class="k">if </span><span class="p">(</span><span class="nx">map</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">newMap</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nx">wallCount</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
              <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                  <span class="nx">newMap</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nx">wallCount</span> <span class="o">&gt;=</span> <span class="mi">5</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
              <span class="p">}</span>
              
              <span class="nf">drawCell</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">newMap</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
              <span class="k">await</span> <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">}</span>
      
      <span class="nx">map</span> <span class="o">=</span> <span class="nx">newMap</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="nf">generateEntrance</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <h4 id="완성">완성</h4>
  <hr />
</blockquote>

<p>BSP<br />
<img src="/assets/images/posts/one-pan/JavaScript/2025-05-27-Dungeon Generator 01/img01.gif" alt="img01" /></p>

<p>Random Walk<br />
<img src="/assets/images/posts/one-pan/JavaScript/2025-05-27-Dungeon Generator 01/img02.gif" alt="img02" /></p>

<p>Cellular Automata<br />
<img src="/assets/images/posts/one-pan/JavaScript/2025-05-27-Dungeon Generator 01/img03.gif" alt="img03" /></p>

<blockquote>
  <h4 id="반성">반성</h4>
  <hr />
</blockquote>

<p>Random Walk 알고리즘과 Cellular Automata 알고리즘을 구현하며 즐거워졌다.<br />
오래된 피쳐폰게임의 작은 미니맵을 보는 기분이다.<br />
아 마음이 충만해진다…</p>

<blockquote>
  <h4 id="코드-확인">코드 확인</h4>
  <hr />
</blockquote>

<p><a href="/play/Dungeon%20Generator.html" target="_blank" rel="noopener noreferrer">
  직접 해보기
</a></p>

<p>BSP<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-27-BSP.js">Link to GitHub</a></p>

<p>Random Walk<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-27-RandomWalk.js">Link to GitHub</a></p>

<p>Cellular Automata<br />
<a href="https://raw.githubusercontent.com/movingwoo/movingwoo-snippets/refs/heads/main/one-pan/JavaScript/2025-05-27-CellularAutomata.js">Link to GitHub</a></p>

          
        </section>

        <footer class="page__meta">
          
          

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2025-05-27">May 27, 2025</time></p>


        </footer>

        

        
<nav class="post-navigation">
  <div id="postNavigation" class="post-navigation__container"></div>

  <script>
    // 별도 js로 post data 넘겨주기만
    window.postData = {
      currentPost: {
        title: "던전 생성기 01",
        url: "/one-pan/javascript/2025/05/27/Dungeon-Generator-01.html",
        date: "2025-05-27",
        categories: ["one-pan/JavaScript/"]
      },
      allPosts: [
        
        
          
          
          {
            title: "4676번 Haiku Review",
            url: "/random-solve/python/2025/06/04/4676.html",
            date: "2025-06-04",
            categories: ["random-solve/Python/"]
          },
          
        
          
          
          {
            title: "WebP 변환기",
            url: "/one-pan/python/2025/06/04/WebP-Converter.html",
            date: "2025-06-04",
            categories: ["one-pan/Python/"]
          },
          
        
          
          
          {
            title: "마법의 소라고둥",
            url: "/one-pan/shortcuts/2025/06/02/Magic-Conch-Shell.html",
            date: "2025-06-02",
            categories: ["one-pan/Shortcuts/"]
          },
          
        
          
          
          {
            title: "1148번 단어 만들기",
            url: "/random-solve/java/2025/06/02/1148.html",
            date: "2025-06-02",
            categories: ["random-solve/Java/"]
          },
          
        
          
          
          {
            title: "11761번 Shuffling Along",
            url: "/random-solve/python/2025/06/02/11761.html",
            date: "2025-06-02",
            categories: ["random-solve/Python/"]
          },
          
        
          
          
          {
            title: "7663번 Dreadful Deadlines",
            url: "/random-solve/c++/2025/05/30/7663.html",
            date: "2025-05-30",
            categories: ["random-solve/C++/"]
          },
          
        
          
          
          {
            title: "6862번 Tin Can Telephone",
            url: "/random-solve/java/2025/05/30/6862.html",
            date: "2025-05-30",
            categories: ["random-solve/Java/"]
          },
          
        
          
          
          {
            title: "15654번 N과 M (5)",
            url: "/random-solve/python/2025/05/30/15654.html",
            date: "2025-05-30",
            categories: ["random-solve/Python/"]
          },
          
        
          
          
          {
            title: "21308번 Ternary Machine",
            url: "/random-solve/python/2025/05/30/21308.html",
            date: "2025-05-30",
            categories: ["random-solve/Python/"]
          },
          
        
          
          
          {
            title: "11982번 Angry Cows (Gold)",
            url: "/random-solve/java/2025/05/28/11982.html",
            date: "2025-05-28",
            categories: ["random-solve/Java/"]
          },
          
        
          
          
          {
            title: "16085번 Гэмт хэрэг",
            url: "/random-solve/c++/2025/05/28/16085.html",
            date: "2025-05-28",
            categories: ["random-solve/C++/"]
          },
          
        
          
          
          {
            title: "던전 생성기 02",
            url: "/one-pan/javascript/2025/05/28/Dungeon-Generator-02.html",
            date: "2025-05-28",
            categories: ["one-pan/JavaScript/"]
          },
          
        
          
          
          {
            title: "7106번 Wonderful Fours",
            url: "/random-solve/python/2025/05/27/7106.html",
            date: "2025-05-27",
            categories: ["random-solve/Python/"]
          },
          
        
          
          
          {
            title: "던전 생성기 01",
            url: "/one-pan/javascript/2025/05/27/Dungeon-Generator-01.html",
            date: "2025-05-27",
            categories: ["one-pan/JavaScript/"]
          },
          
        
          
          
          {
            title: "5101번 Sequences",
            url: "/random-solve/python/2025/05/23/5101.html",
            date: "2025-05-23",
            categories: ["random-solve/Python/"]
          },
          
        
          
          
          {
            title: "27391번 Platform Placing",
            url: "/random-solve/java/2025/05/23/27391.html",
            date: "2025-05-23",
            categories: ["random-solve/Java/"]
          },
          
        
          
          
          {
            title: "25245번 Amusement Arcade",
            url: "/random-solve/c++/2025/05/23/25245.html",
            date: "2025-05-23",
            categories: ["random-solve/C++/"]
          },
          
        
          
          
          {
            title: "미로 생성기 03",
            url: "/one-pan/javascript/2025/05/23/Maze-Generator-03.html",
            date: "2025-05-23",
            categories: ["one-pan/JavaScript/"]
          },
          
        
          
          
          {
            title: "26489번 Gum Gum for Jay Jay",
            url: "/random-solve/python/2025/05/22/26489.html",
            date: "2025-05-22",
            categories: ["random-solve/Python/"]
          },
          
        
          
          
          {
            title: "미로 생성기 02",
            url: "/one-pan/javascript/2025/05/21/Maze-Generator-02.html",
            date: "2025-05-21",
            categories: ["one-pan/JavaScript/"]
          },
          
        
          
          
          {
            title: "26226번 Autocomplete",
            url: "/random-solve/c++/2025/05/21/26226.html",
            date: "2025-05-21",
            categories: ["random-solve/C++/"]
          },
          
        
          
          
          {
            title: "미로 생성기 01",
            url: "/one-pan/javascript/2025/05/20/Maze-Generator-01.html",
            date: "2025-05-20",
            categories: ["one-pan/JavaScript/"]
          },
          
        
          
          
          {
            title: "15936번 Hypercube",
            url: "/random-solve/java/2025/05/20/15936.html",
            date: "2025-05-20",
            categories: ["random-solve/Java/"]
          },
          
        
          
          
          {
            title: "29348번 Скользкий путь",
            url: "/random-solve/c++/2025/05/16/29348.html",
            date: "2025-05-16",
            categories: ["random-solve/C++/"]
          },
          
        
          
          
          {
            title: "18382번 2048",
            url: "/random-solve/python/2025/05/15/18382.html",
            date: "2025-05-15",
            categories: ["random-solve/Python/"]
          },
          
        
          
          
          {
            title: "랜덤 출력기",
            url: "/one-pan/javascript/2025/05/14/Random-Printer.html",
            date: "2025-05-14",
            categories: ["one-pan/JavaScript/"]
          },
          
        
          
          
          {
            title: "파이썬으로 CLI TODO 리스트 만들어보기",
            url: "/ai-playground/gpt/2025/05/14/GPT.html",
            date: "2025-05-14",
            categories: ["AI-playground/GPT/"]
          },
          
        
          
          
          {
            title: "플래피 버드",
            url: "/one-pan/javascript/2025/05/13/Flappy-Bird.html",
            date: "2025-05-13",
            categories: ["one-pan/JavaScript/"]
          },
          
        
          
          
          {
            title: "클리커",
            url: "/one-pan/python/2025/05/13/Clicker.html",
            date: "2025-05-13",
            categories: ["one-pan/Python/"]
          },
          
        
          
          
          {
            title: "파일 복사기",
            url: "/one-pan/shellscript/2025/05/12/File-Copier.html",
            date: "2025-05-12",
            categories: ["one-pan/ShellScript/"]
          },
          
        
          
          
          {
            title: "숫자야구",
            url: "/one-pan/java/2025/05/11/Bulls-and-Cows.html",
            date: "2025-05-11",
            categories: ["one-pan/Java/"]
          },
          
        
          
          
          {
            title: "즐거운 연휴",
            url: "/ai-playground/gpt/2025/05/01/GPT.html",
            date: "2025-05-01",
            categories: ["AI-playground/GPT/"]
          },
          
        
          
          
          {
            title: "즐거운 연휴, 어떻게 보내면 좋을까?",
            url: "/ai-playground/claude/2025/05/01/Claude.html",
            date: "2025-05-01",
            categories: ["AI-playground/Claude/"]
          },
          
        
          
          
          {
            title: "프로그래머를 위한 생산성 툴 TOP 5 🧰",
            url: "/ai-playground/gpt/2025/04/30/GPT.html",
            date: "2025-04-30",
            categories: ["AI-playground/GPT/"]
          },
          
        
          
          
          {
            title: "AI 시대의 개발자, 어떻게 준비해야 할까?",
            url: "/ai-playground/claude/2025/04/30/Claude.html",
            date: "2025-04-30",
            categories: ["AI-playground/Claude/"]
          },
          
        
          
          
          {
            title: "지뢰찾기",
            url: "/one-pan/javascript/2025/04/29/Minesweeper.html",
            date: "2025-04-29",
            categories: ["one-pan/JavaScript/"]
          },
          
        
          
          
          {
            title: "서버 관리 콘솔",
            url: "/one-pan/shellscript/2025/04/28/Server-Manage-Console.html",
            date: "2025-04-28",
            categories: ["one-pan/ShellScript/"]
          }
          
        
      ]
    };
  </script>
  <script src="/assets/js/post_pagination.js" defer></script>
</nav>

      </div>

      
      
      
        <script src="https://giscus.app/client.js"
        data-repo="movingwoo/movingwoo.github.io"
        data-repo-id="R_kgDOORY1lQ"
        data-category="Announcements"
        data-category-id="DIC_kwDOORY1lc4CpoFq"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="0"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="https://movingwoo.com/assets/css/giscus-theme.css"
        data-lang="ko"
        crossorigin="anonymous"
        async>
</script>
      
    </article>

    
    
  </div>
</div>

<style>
.home-layout {
  display: flex;
  max-width: 1500px;
  margin: 0 auto;
  padding: 0;
}

.home-sidebar {
  flex-shrink: 0;
  width: 300px;
  margin-right: 1rem;
  position: relative;
  display: block !important;
}

.home-content {
  flex-grow: 1;
  min-width: 0;
  width: 100%;
}

@media (max-width: 64em) {
  .home-layout {
    flex-direction: column;
  }
  
  .home-sidebar {
    width: 100%;
    margin-right: 0;
    margin-bottom: 1rem;
  }
  
  .home-content {
    padding: 0;
  }
}
</style>

    </div>

    
    
    <div class="page__footer">
  <div class="page__footer-copyright">
    Visit: <a href="https://github.com/movingwoo/movingwoo.github.io">https://github.com/movingwoo/movingwoo.github.io</a>
    <br>
    <span class="theme-credit">Theme customized from Minimal Mistakes by Michael Rose (MIT License).</span>
  </div>
</div>

    <div class="scroll-button">
  <div class="scroll-button__container">
    <button class="scroll-button__area scroll-button__area--top" onclick="window.scrollTo({top: 0, behavior: 'smooth'})" title="위로">
      <i class="fas fa-arrow-up"></i>
    </button>
    <button class="scroll-button__area scroll-button__area--bottom" onclick="window.scrollTo({top: document.body.scrollHeight, behavior: 'smooth'})" title="아래로">
      <i class="fas fa-arrow-down"></i>
    </button>
  </div>
</div>

<style>
.scroll-button {
  position: fixed;
  right: 20px;
  bottom: 20px;
  z-index: 1000;
}

.scroll-button__container {
  width: 60px;
  height: 60px;
  border-radius: 50%;
  border: 2px solid rgba(220, 20, 60, 0.6);
  background-color: transparent;
  position: relative;
  overflow: hidden;
}

.scroll-button__area {
  position: absolute;
  width: 100%;
  height: 50%;
  left: 0;
  background: transparent;
  border: none;
  color: rgba(220, 20, 60, 0.6);
  cursor: pointer;
  padding: 0;
  transition: all 0.3s ease;
  outline: none;
  display: flex;
  align-items: center;
  justify-content: center;
}

.scroll-button__area--top {
  top: 0;
}

.scroll-button__area--bottom {
  bottom: 0;
}

.scroll-button__area:focus {
  outline: none;
}

.scroll-button__area:hover {
  color: rgba(220, 20, 60, 1);
}

.scroll-button__area:hover i {
  transform: scale(1.2);
}

.scroll-button__area i {
  font-size: 1rem;
  transition: transform 0.3s ease;
}

@media (max-width: 768px) {
  .scroll-button {
    right: 10px;
    bottom: 10px;
  }
  
  .scroll-button__container {
    width: 50px;
    height: 50px;
  }
}
</style> 
    
  <script src="/assets/js/main.min.js"></script>









<script>
document.addEventListener('contextmenu', function(e) {
    e.preventDefault();
});
document.addEventListener('selectstart', function(e) {
    e.preventDefault();
});
document.addEventListener('copy', function(e) {
    e.preventDefault();
});
</script>


  </body>
</html>
